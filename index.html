<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Larkkkkkkk</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Larkkkkkkk">
<meta property="og:url" content="https://larkkkkkkk.github.io/index.html">
<meta property="og:site_name" content="Larkkkkkkk">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Larkkkkkkk">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Larkkkkkkk" type="application/atom+xml">
  
  
    <link rel="icon" href="/http://oayoilchh.bkt.clouddn.com/2016/07/27/18:05:26%20">
  
  
      
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="img/head.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Larkkkkkkk</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="https://github.com/Larkkkkkkk" target="_blank" rel="noopener">博客首页</a></li>
                        
                            <li><a  href="/archives">文章归档</a></li>
                        
                            <li><a  href="/CTFStudy">学习导航</a></li>
                        
                            <li><a  href="/PWNABLE">PWNABLE</a></li>
                        
                            <li><a  href="/resume">个人简历</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail"  target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=U2JgZ2ZlY2VmamATIiJ9MDw_" title="mail">mail</a>
                            
                                <a class="fl github"  target="_blank" href="https://github.com/Larkkkkkkk" title="github">github</a>
                            
                                <a class="fl zhihu"  target="_blank" href="https://www.zhihu.com/people/plain-3-78/activities" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo"  target="_blank" href="https://weibo.com/5304208276/profile?topnav=1&wvr=6" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Ajax/" style="font-size: 11.82px;">Ajax</a> <a href="/tags/Cookie%E5%92%8CSession/" style="font-size: 13.64px;">Cookie和Session</a> <a href="/tags/DBUtils/" style="font-size: 10.91px;">DBUtils</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">EL表达式</a> <a href="/tags/Elasticsearch/" style="font-size: 10.91px;">Elasticsearch</a> <a href="/tags/Filter/" style="font-size: 10.91px;">Filter</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPServletReauest%E5%92%8CHTTPServletResponse/" style="font-size: 10px;">HTTPServletReauest和HTTPServletResponse</a> <a href="/tags/Hexo%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">Hexo博客</a> <a href="/tags/IDEA%E5%AE%89%E8%A3%85%E5%92%8C%E7%A0%B4%E8%A7%A3/" style="font-size: 10px;">IDEA安装和破解</a> <a href="/tags/JAVA/" style="font-size: 19.09px;">JAVA</a> <a href="/tags/JAVA-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">JAVA-Lambda表达式</a> <a href="/tags/JAVA-Set%E9%9B%86%E5%90%88/" style="font-size: 10px;">JAVA-Set集合</a> <a href="/tags/JAVA-%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">JAVA-反射</a> <a href="/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 11.82px;">JAVA-多线程</a> <a href="/tags/JAVA-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">JAVA-正则表达式</a> <a href="/tags/JAVA-%E6%B3%9B%E5%9E%8B/" style="font-size: 10px;">JAVA-泛型</a> <a href="/tags/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 11.82px;">JAVA-网络编程</a> <a href="/tags/JAVA-%E9%9B%86%E5%90%88/" style="font-size: 11.82px;">JAVA-集合</a> <a href="/tags/JAVA%E7%BB%83%E4%B9%A0/" style="font-size: 10.91px;">JAVA练习</a> <a href="/tags/JAVA%E7%BB%83%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">JAVA练习-动态规划</a> <a href="/tags/JQuery/" style="font-size: 12.73px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Jmeter/" style="font-size: 10px;">Jmeter</a> <a href="/tags/LeetCode/" style="font-size: 17.27px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 15.45px;">Linux</a> <a href="/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/tags/Mybatis/" style="font-size: 18.18px;">Mybatis</a> <a href="/tags/MybatisPlus/" style="font-size: 10px;">MybatisPlus</a> <a href="/tags/Mysql/" style="font-size: 11.82px;">Mysql</a> <a href="/tags/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CJDBC/" style="font-size: 15.45px;">Mysql数据库和JDBC</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Servlet/" style="font-size: 10.91px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 16.36px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 15.45px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 20px;">Web前端知识点</a> <a href="/tags/XML/" style="font-size: 10.91px;">XML</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/flask%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">flask框架</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/jsp%E6%A0%87%E5%87%86%E6%A0%87%E7%AD%BE%E5%BA%93/" style="font-size: 10px;">jsp标准标签库</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/picture/" style="font-size: 10px;">picture</a> <a href="/tags/python/" style="font-size: 11.82px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/ssm%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BF/" style="font-size: 10px;">ssm框架模板</a> <a href="/tags/webserver%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">webserver编程</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BA%AC%E4%B8%9C/" style="font-size: 10.91px;">京东</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%90%8E%E7%BC%80%E6%A0%91/" style="font-size: 10px;">后缀树</a> <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 10px;">哈希表</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/" style="font-size: 10px;">复杂度分析</a> <a href="/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">学生管理系统</a> <a href="/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F2-0/" style="font-size: 11.82px;">学生管理系统2.0</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 14.55px;">微服务</a> <a href="/tags/%E6%8B%BC%E5%A4%9A%E5%A4%9A/" style="font-size: 10px;">拼多多</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 10px;">数据分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" style="font-size: 10px;">数据库连接池</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数据结构-稀疏数组</a> <a href="/tags/%E6%96%87%E5%AD%97%E7%AF%87-%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">文字篇-记录</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 11.82px;">机器学习</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 11.82px;">树</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">注解</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 13.64px;">深度学习</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10.91px;">爬虫</a> <a href="/tags/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/" style="font-size: 10px;">生物信息学</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 11.82px;">知识图谱</a> <a href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%88%9D%E8%AF%95/" style="font-size: 11.82px;">研究生初试</a> <a href="/tags/%E7%A7%8B%E6%8B%9B/" style="font-size: 10px;">秋招</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法-动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/" style="font-size: 10px;">算法-回溯法</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法-贪心算法</a> <a href="/tags/%E8%80%83%E7%A0%94/" style="font-size: 10px;">考研</a> <a href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 12.73px;">蓝桥杯</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10.91px;">计算机网络</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE-%E8%BD%AF%E4%BB%B6%E4%B8%93%E4%B8%9A%E9%A2%98%E7%9B%AE/" style="font-size: 10px;">计算机网络课设(软件专业题目)</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 11.82px;">设计模式</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" style="font-size: 10px;">软件体系结构</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 10px;">递归</a> <a href="/tags/%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">重新部署</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/tags/%E9%A1%B5%E9%9D%A2%EF%BC%88H5-CSS%EF%BC%89/" style="font-size: 10px;">页面（H5+CSS）</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0/" style="font-size: 10px;">项目上传</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://ring3.xyz/">Yllen</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://mxny.org/">麦香浓郁</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://whereisk0shl.top/">K0sh1</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.ycjcl.cc/">信鑫</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://bystudent.com/">ByStundet表哥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.jarviswang.me/">汪神_Jarvis</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sh3ll.me/">Chu</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.hackfun.org/">4ido10n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/iamstudy">L3m0n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://o0xmuhe.me/">muhe</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.nuptzj.cn/">_画船听雨</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.virzz.com/index.html">Virink</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.sqlsec.com/">国光</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bodkin.ren/">老锥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cizel.cn/">C1zel</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://1phan.cc">1phan</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.liuil.top/">liuil</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/Ox9A82/">Ox9A82</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://burnegg.com/">burnegg</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://jwrsec.cn/">jwr-sec</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sudalover.cn/">苏打</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.binklac.com">VeroFess</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bendawang.site/">bendawang</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://weeklyalgo.codes/">hook</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.flier.net.cn/">Flier&#39;blog</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mutepig.club">mutepig</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.iret.xyz/list.aspx">Silver</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://simp1e.leanote.com/">Simple</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://processor.pub/">Processor</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一只淹死在二进制海洋里的二进制狗!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Larkkkkkkk</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Larkkkkkkk</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="https://github.com/Larkkkkkkk" target="_blank" rel="noopener">博客首页</a></li>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="/CTFStudy">学习导航</a></li>
                
                    <li><a href="/PWNABLE">PWNABLE</a></li>
                
                    <li><a href="/resume">个人简历</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=U2JgZ2ZlY2VmamATIiJ9MDw_" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/Larkkkkkkk" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/plain-3-78/activities" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="https://weibo.com/5304208276/profile?topnav=1&wvr=6" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-东林在线微课堂" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/08/12/%E4%B8%9C%E6%9E%97%E5%9C%A8%E7%BA%BF%E5%BE%AE%E8%AF%BE%E5%A0%82/" class="article-date">
      <time datetime="2024-08-12T02:14:44.000Z" itemprop="datePublished">2024-08-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/08/12/%E4%B8%9C%E6%9E%97%E5%9C%A8%E7%BA%BF%E5%BE%AE%E8%AF%BE%E5%A0%82/">东林在线微课堂</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-持续集成" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/08/12/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/" class="article-date">
      <time datetime="2024-08-12T01:43:11.000Z" itemprop="datePublished">2024-08-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/08/12/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">持续集成</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1-项目部署"><a href="#1-项目部署" class="headerlink" title="1.项目部署"></a>1.项目部署</h1><ul>
<li>项目打成jar包</li>
<li>Docker部署(项目打成jar包 —&gt;docker镜像文件—&gt;docker容器)</li>
<li>K8S</li>
</ul>
<h1 id="2-持续集成CI"><a href="#2-持续集成CI" class="headerlink" title="2.持续集成CI"></a>2.持续集成CI</h1><p>持续集成是一种<strong>软件开发实践</strong>，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，就意味着每天有多次集成。每次集成都通过自动化的构建(包括编译，发布，自动化测试)来验证，从而尽早发现集成错误。</p>
<h2 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h2><ul>
<li>1.自动构建，发布，测试</li>
<li>2.降低风险</li>
</ul>
<h2 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h2><ul>
<li>Jenkins[tk旧项目使用]</li>
<li>坎特[tk新项目使用]</li>
</ul>
<h1 id="3-Jenkins-老头"><a href="#3-Jenkins-老头" class="headerlink" title="3.Jenkins(老头)"></a>3.Jenkins(老头)</h1><p>Jenkins是一个开源的实现持续集成的软件工具：<a href="https://www.jenkins.io/zh/" target="_blank" rel="noopener">Jenkins</a></p>
<p>==<strong>原理图</strong>：==</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202408121010483.png" alt="image-20240812101022218" style="zoom:150%;">

<p>项目已经基于Jenkins实现持续集成；每当我们push代码时候就触发项目完成自动编译和打包。</p>
<p>如果需要运行某个微服务时，只需要以下两步：</p>
<ul>
<li>第一步：访问Jenkins控制台</li>
<li>第二步：点击对应微服务后面的绿色运行按钮</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Mysql分表分库-Sharding-Sphere" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/07/22/Mysql%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93-Sharding-Sphere/" class="article-date">
      <time datetime="2024-07-22T01:39:47.000Z" itemprop="datePublished">2024-07-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/07/22/Mysql%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93-Sharding-Sphere/">Mysql分表分库-Sharding-Sphere</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1-分表分库概念"><a href="#1-分表分库概念" class="headerlink" title="1.分表分库概念"></a>1.分表分库概念</h1><h2 id="1-1-分表"><a href="#1-1-分表" class="headerlink" title="1.1 分表"></a>1.1 分表</h2><ul>
<li><strong>水平分表</strong>[根据一些维度横向]</li>
</ul>
<p>水平分表是将表中的数据行拆分到多个不同的表/数据库，通常是根据某种键值来拆分</p>
<ul>
<li><strong>垂直分表</strong>[部分字段拆分到别的表]</li>
</ul>
<p>垂直分表是将表中的列拆分到多个不同的表，通常是根据列的使用频率或者业务逻辑来拆分</p>
<ul>
<li>两者区别</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>垂直分表</th>
<th>水平分表</th>
</tr>
</thead>
<tbody><tr>
<td>拆分依据</td>
<td>列的使用频率/业务逻辑</td>
<td>某种键值[用户ID,时间戳]</td>
</tr>
<tr>
<td>目的</td>
<td>优化表结构，提高访问速度</td>
<td>解决单表数据量过大导致性能问题，分散数据到多个表提高查询和更新性能</td>
</tr>
<tr>
<td>优点</td>
<td>1.可以减少页面加载时间，只查询必要的列2.降低数据冗余，提高存储效率</td>
<td>1.减少单个表数据量，提高单表管理能力和访问速度2.易于实现，大多数据库中间件都支持水平分表</td>
</tr>
<tr>
<td>缺点</td>
<td>1.增加了数据库复杂性，需要更多join连接合并数据2.分表策略要根据业务仔细设计</td>
<td>1.例如联表查询就需要额外的逻辑处理[有的符合行在A，有的符合行在B]2.键值需要谨慎设计</td>
</tr>
<tr>
<td>应用场景</td>
<td>表中有大量列，但是访问只有少数几个列情况</td>
<td>处理具有明显数据划分界限情况</td>
</tr>
<tr>
<td>注意事项</td>
<td></td>
<td>1.分表操作可能会影响数据库的事务管理，需要考虑跨表操作的一致性2.分表策略应该基于实际的业务需求和数据访问模式来设计3.分表后的数据迁移和数据完整性保持是实施过程中最难的挑战</td>
</tr>
</tbody></table>
<h2 id="1-2-分库"><a href="#1-2-分库" class="headerlink" title="1.2 分库"></a>1.2 分库</h2><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407220944195.png" alt="image-20240722094437153"></p>
<ul>
<li>1.考虑分库的目标：提高读写性能，写入性能还是两者兼顾</li>
<li>2.考虑分片键的选择：通常是表中某个字段</li>
<li>3.考虑分片策略：①范围分片(基于数值范围)②哈希分片(基于哈希算法)③列表分片(基于枚举值)</li>
</ul>
<h1 id="2-Sharding-Sphere概念"><a href="#2-Sharding-Sphere概念" class="headerlink" title="2.Sharding-Sphere概念"></a>2.Sharding-Sphere概念</h1><h2 id="2-1-Sharding-JDBC框架简介-配置麻烦"><a href="#2-1-Sharding-JDBC框架简介-配置麻烦" class="headerlink" title="2.1 Sharding-JDBC框架简介[配置麻烦]"></a>2.1 Sharding-JDBC框架简介[配置麻烦]</h2><p><code>Sharding-JDBC</code>的定位是一款轻量级<code>Java</code>框架，它会以<code>POM</code>依赖的形式嵌入程序，运行期间会和<code>Java</code>应用共享资源，这款框架的本质可以理解成是<code>JDBC</code>的增强版，只不过<code>Java</code>原生的<code>JDBC</code>仅支持单数据源的连接，而<code>Sharding-JDBC</code>则支持多数据源的管理，部署形态如下:</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407220946256.png" alt="image-20240722094656183"></p>
<p><code>Java-ORM</code>框架在执行<code>SQL</code>语句时，<code>Sharding-JDBC</code>会以切面的形式拦截发往数据库的语句，接着根据配置好的数据源、分片规则和路由键，为<code>SQL</code>选择一个目标数据源，然后再发往对应的数据库节点处理。</p>
<blockquote>
<p><code>Sharding-JDBC</code>在整个业务系统中对性能损耗极低，但为何后面又会推出<code>Sharding-Proxy</code>呢？因为<code>Sharding-JDBC</code>配置较为麻烦，比如在分布式系统中，任何使用分库分表的服务都需要单独配置多数据源地址、路由键、分片策略….等信息，同时它也仅支持<code>Java</code>语言，当一个系统是用多语言异构的，此时其他语言开发的子服务，则无法使用分库分表策略。</p>
</blockquote>
<h2 id="2-2-Sharding-Proxy中间件简介-成本过大"><a href="#2-2-Sharding-Proxy中间件简介-成本过大" class="headerlink" title="2.2 Sharding-Proxy中间件简介[成本过大]"></a>2.2 Sharding-Proxy中间件简介[成本过大]</h2><p>也正是由于配置无法统一管理、不支持异构系统的原因，后面又引入<code>Sharding-Proxy</code>来解决这两个问题，<code>Sharding-Proxy</code>可以将其理解成一个伪数据库，对于应用程序而言是完全透明的，它会以中间件的形式独立部署在系统中，部署形态如下：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407220951753.png" alt="image-20240722095156667"></p>
<p>使用<code>Sharding-Proxy</code>的子服务都会以连接数据库的形式，与其先建立数据库连接，然后将<code>SQL</code>发给它执行，<code>Sharding-Proxy</code>会根据分片规则和路由键，将<code>SQL</code>语句发给具体的数据库节点处理，数据库节点处理完成后，又会将结果集返回给<code>Sharding-Proxy</code>，最终再由它将结果集返回给具体的子服务。</p>
<blockquote>
<p>但<code>Sharding-Proxy</code>虽然可以实现分库分表配置的统一管理，以及支持异构的系统，但因为需要使用独立的机器部署，同时还会依赖<code>Zookeeper</code>作为注册中心，所以硬件成本会直线增高，至少需要多出<code>3~4</code>台服务器来部署。</p>
</blockquote>
<p>同时<code>SQL</code>执行时，需要先发给<code>Proxy</code>，再由<code>Proxy</code>发给数据库节点，执行完成后又会从数据库返回到<code>Proxy</code>，再由<code>Proxy</code>返回给具体的应用，这个过程会经过四次网络传输的动作，因此相较于原本的<code>Sharding-JDBC</code>来说，性能、资源开销更大，响应速度也会变慢。</p>
<h2 id="2-3-JDBC、Proxy混合部署模式-取长补短"><a href="#2-3-JDBC、Proxy混合部署模式-取长补短" class="headerlink" title="2.3 JDBC、Proxy混合部署模式[取长补短]"></a>2.3 JDBC、Proxy混合部署模式[取长补短]</h2><p>如果用驱动式分库分表，虽然能够让<code>Java</code>程序的性能最好，但无法支持多语言异构的系统，但如果纯用代理式分库分表，这显然会损害<code>Java</code>程序的性能，因此在<code>Sharding-Sphere</code>中也支持<code>JDBC、Proxy</code>做混合式部署，也就是<code>Java</code>程序用<code>JDBC</code>做分库分表，其他语言的子服务用<code>Proxy</code>做分库分表，部署形态如下：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407220952897.png" alt="image-20240722095231817"></p>
<p>这种混合式的部署方案，所有的数据分片策略都会放到<code>Zookeeper</code>中统一管理，然后所有的子服务都去<code>Zookeeper</code>中拉取配置文件，这样就能很方便的根据业务情况，来灵活的搭建适用于各种场景的应用系统，这样也能够让数据源、分片策略、路由键….等配置信息灵活，可以在线上动态修改配置信息，修改后能够在线上环境中动态感知。</p>
<blockquote>
<p>但<code>Sharding-Sphere</code>还提供了一种单机模式，即直接将数据分片配置放在<code>Proxy</code>中，但这种方式仅适用于开发环境，因为无法将分片配置同步给多个实例使用，也就意味着会导致其他实例由于感知不到配置变化，从而造成配置信息不一致的错误。</p>
</blockquote>
<h1 id="3-Sharding-Sphere核心概念—路由键-分片算法"><a href="#3-Sharding-Sphere核心概念—路由键-分片算法" class="headerlink" title="3.Sharding-Sphere核心概念—路由键/分片算法"></a>3.Sharding-Sphere核心概念—路由键/分片算法</h1><ul>
<li><p><strong>路由键/分片键</strong>：作为数据分片的基准字段[可以是一个/多个字段组成]</p>
</li>
<li><p><strong>分片算法</strong>：基于路由键做一定逻辑处理，从而计算出一个最终节点位置的算法</p>
</li>
</ul>
<p>举例：好比按<code>user_id</code>将用户表数据分片，每八百万条数据划分一张表。<code>user_id</code>就是路由键，而按<code>user_id</code>做范围判断则属于分片算法，一张表中的所有数据都会依据这两个基础，后续对所有的读写<code>SQL</code>进行改写，从而定位到具体的库、表位置。</p>
<h1 id="4-Sharding-Sphere分表分库的工作流程"><a href="#4-Sharding-Sphere分表分库的工作流程" class="headerlink" title="4.Sharding-Sphere分表分库的工作流程"></a>4.Sharding-Sphere分表分库的工作流程</h1><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407221014403.png" alt="image-20240722101404319"></p>
<ul>
<li><p>逻辑表：提供给应用程序操作的表名，程序可以像操作原本的单表一样，灵活的操作逻辑表(逻辑表并不是一种真实存在的表结构，而是提供给<code>Sharding-Sphere</code>使用的)</p>
</li>
<li><p>真实表：在各个数据库节点上真实存在的物理表，但表名一般都会和逻辑表存在偏差。</p>
</li>
<li><p>数据节点：主要是用于定位具体真实表的库表名称，如<code>DB1.tb_user1、DB2.tb_user2.....</code></p>
</li>
<li><ul>
<li>均匀分布：指一张表的数量在每个数据源中都是一致的。</li>
<li>自定义分布：指一张表在每个数据源中，具体的数量由自己来定义，上图就是一种自定义分布。</li>
</ul>
</li>
<li></li>
</ul>
<p>Java为例：</p>
<p>编写业务代码的SQL语句直接基于<strong>逻辑表</strong>操作；当<code>Sharding-Sphere</code>接收到一条操作某张逻辑表的<code>SQL</code>语句—–已配置好的路由键和分片算法—–&gt;对相应的SQL语句进行解析，然后计算出<code>SQL</code>要落入的数据节点(是哪个真实表)，最后再将语句发给具体的真实表上处理即可</p>
<blockquote>
<p><code>JDBC和Proxy</code>的主要区别就在于：解析<code>SQL</code>语句计算数据节点的时机不同</p>
<ul>
<li><code>JDBC</code>是在<strong>Java程序中</strong>就完成相应计算，从<code>Java</code>程序中发出SQL语句就已经是操作真实表的SQL</li>
<li><code>Proxy</code>是在<strong>Java程序外</strong>做解析工作，它会接收程序操作逻辑表的<code>SQL</code>语句。然后再做解析得到具体要操作的真实表，然后再执行，同时<code>Proxy</code>还要作为应用程序和数据库之间，传输数据的中间人</li>
</ul>
</blockquote>
<h1 id="5-Sharding-Sphere概念—表"><a href="#5-Sharding-Sphere概念—表" class="headerlink" title="5.Sharding-Sphere概念—表"></a>5.Sharding-Sphere概念—表</h1><h2 id="5-1-绑定表-解决主外键数据落不同库产生跨库查询"><a href="#5-1-绑定表-解决主外键数据落不同库产生跨库查询" class="headerlink" title="5.1 绑定表[解决主外键数据落不同库产生跨库查询]"></a>5.1 绑定表[解决主外键数据落不同库产生跨库查询]</h2><ul>
<li><strong>现有问题：</strong></li>
</ul>
<p>多张表之间存在物理或逻辑上的主外键关系，如果无法保障同一主键值的外键数据落入同一节点，显然在查询时就会发生跨库查询，这无疑对性能影响是极大的。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407221100877.png" alt="image-20240722110038729"></p>
<ul>
<li><strong>解决方案：</strong></li>
</ul>
<p>比如：前面案例中的<code>order_id、order_info_id</code>可以配置一组绑定表关系，这样就能够让订单详情数据随着订单数据一同落库，简单的说就是：配置绑定表的关系后，外键的表数据会随着主键的表数据落入同一个库中，这样在做主外键关联查询时，就能有效避免跨库查询的情景出现。</p>
<h2 id="5-2-广播表-解决跨库join问题"><a href="#5-2-广播表-解决跨库join问题" class="headerlink" title="5.2 广播表[解决跨库join问题]"></a>5.2 广播表[解决跨库join问题]</h2><ul>
<li><strong>现有问题：</strong></li>
</ul>
<p>当有些表需要经常被用来做连表查询时，这种频繁关联查询的表，如果每次都走跨库<code>Join</code>，这显然又会造成一个令人头疼的性能问题。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407221104028.png" alt="image-20240722110446940"></p>
<ul>
<li><strong>解决方案：</strong></li>
</ul>
<p>对于一些经常用来做关联查询的表，就可以将其配置为广播表</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407221129198.png" alt="image-20240722112901134"></p>
<p>广播表是一种会在所有库中都创建的表，以系统字典表为例，将其配置为广播表之后，向其增、删、改一条或多条数据时，所有的写操作都会发给全部库执行，从而确保每个库中的表数据都一致，后续在需要做连表查询时，只需要关联自身库中的字典表即可，从而避免了跨库<code>Join</code>的问题出现。</p>
<h2 id="5-3-单表-不分表分库"><a href="#5-3-单表-不分表分库" class="headerlink" title="5.3 单表[不分表分库]"></a>5.3 单表[不分表分库]</h2><p>单表的含义比较简单，并非所有的表都需要做分库分表操作，所以当一张表的数据无需分片到多个数据源中时，就可将其配置为单表，这样所有的读写操作最终都会落入这一张单表中处理。</p>
<h2 id="5-4-动态表"><a href="#5-4-动态表" class="headerlink" title="5.4 动态表"></a>5.4 动态表</h2><p>动态表是指表会随着数据增长、或随着时间推移，不断的去创建新表，如下：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407221341864.png" alt="image-20240722134127808"></p>
<p>在<code>Sharding-Sphere</code>中可以直接支持配置，无需自己去从头搭建，因此实现起来尤为简单，配置好之后会按照时间或数据量动态创建表。</p>
<h1 id="6-Sharding-Sphere数据分片策略"><a href="#6-Sharding-Sphere数据分片策略" class="headerlink" title="6.Sharding-Sphere数据分片策略"></a>6.Sharding-Sphere数据分片策略</h1><p>分库分表之后读写操作具体会落入哪个库中，这是根据路由键和分片算法来决定的</p>
<p><code>Sharding-Sphere</code>中的数据分片策略又分为：</p>
<ul>
<li><p>1.内置的自动化分片算法：[取模分片、哈希分片、范围分片、时间分片等这积累常规算法]</p>
</li>
<li><p>2.用户自定义的分片算法：[标准分片、复合分片、强制分片]</p>
<ul>
<li><p>2.1 标准分片算法：适合基于单一路由键进行<code>=、in、between、&gt;、&lt;、&gt;=、&lt;=...</code>进行查询的场景。</p>
</li>
<li><p>2.2 复合分片算法：适用于多个字段组成路由键的场景，但路由算法需要自己继承接口重写实现。</p>
</li>
<li><p>2.3 强制分片算法：适用于一些特殊<code>SQL</code>的强制执行，在这种模式中可以强制指定处理语句的节点。</p>
</li>
</ul>
</li>
</ul>
<p>综上所述，在<code>Sharding-Sphere</code>内部将这四种<strong>分片策略</strong>称为：<code>Inline、Standard、Complex、Hint</code>，分别与上述四种策略一一对应，但这四种仅代表四种策略，具体的数据分片算法，可以由使用者自身来定义。</p>
<h1 id="7-Sharding-Sphere分库方式"><a href="#7-Sharding-Sphere分库方式" class="headerlink" title="7.Sharding-Sphere分库方式"></a>7.Sharding-Sphere分库方式</h1><p>在<code>Sharding-Sphere</code>生态中，支持传统的主从集群分库，[如搭建出读写分离架构、双主双写架构]，同时也支持按业务进行垂直分库，也支持对单个库进行横向拓展，做到水平分库。</p>
<blockquote>
<p>但通常都是用它来实现水平分库和读写分离，因为分布式架构的系统默认都有独享库的概念，也就是分布式系统默认就会做垂直分库，因此无需引入<code>Sharding-Sphere</code>来做垂直分库。</p>
</blockquote>
<h1 id="Sharding-Sphere实际操作"><a href="#Sharding-Sphere实际操作" class="headerlink" title="==Sharding-Sphere实际操作=="></a>==Sharding-Sphere实际操作==</h1><p>  之前提到过，<code>Sharding-Sphere</code>的所有产品对业务代码都是零侵入的，无论是<code>Sharding-JDBC</code>也好，<code>Sharding-Proxy</code>也罢，都不需要更改业务代码，这也就意味着大家在分库分表环境下做业务开发时，可以像传统的单库开发一样轻松。</p>
<ul>
<li><code>Sharding-Sphere</code>中最主要的是对配置文件的更改</li>
<li><code>Sharding-JDBC</code>主要修改<code>application.properties/yml</code>文件</li>
<li><code>Sharding-Proxy</code>主要修改自身的配置文件</li>
</ul>
<h1 id="1-配置yml文件-业务代码零侵入"><a href="#1-配置yml文件-业务代码零侵入" class="headerlink" title="1.配置yml文件[业务代码零侵入]"></a>1.配置yml文件[业务代码零侵入]</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;后期补充</span><br></pre></td></tr></table></figure>



<h1 id="Sharding-Sphere工作原理"><a href="#Sharding-Sphere工作原理" class="headerlink" title="==Sharding-Sphere工作原理=="></a>==Sharding-Sphere工作原理==</h1><h1 id="1-核心工作步骤"><a href="#1-核心工作步骤" class="headerlink" title="1.核心工作步骤"></a>1.核心工作步骤</h1><p>其核心工作步骤会分为如下几步：</p>
<ul>
<li>• 配置加载：在程序启动时，会读取用户的配置好的数据源、数据节点、分片规则等信息。</li>
<li>• <code>SQL</code>解析：<code>SQL</code>执行时，会先根据配置的数据源来调用对应的解析器，然后对语句进行拆解。</li>
<li>• <code>SQL</code>路由：拆解<code>SQL</code>后会从中得到路由键的值，接着会根据分片算法选择单或多个数据节点。</li>
<li>• <code>SQL</code>改写：选择了目标数据节点后，接着会改写、优化用户的逻辑<code>SQL</code>，指向真实的库、表。</li>
<li>• <code>SQL</code>执行：对于要在多个数据节点上执行的语句，内部开启多线程执行器异步执行每条<code>SQL</code>。</li>
<li>• 结果归并：持续收集每条线程执行完成后返回的结果集，最终将所有线程的结果集合并。</li>
<li>• 结果处理：如果<code>SQL</code>中使用了<code>order by、max()、count()...</code>等操作，对结果处理后再返回。</li>
</ul>
<p>整个<code>Sharding-Sphere</code>大致工作步骤如上，这个过程相对来说也比较简单，但具体的实现会比较复杂，针对于不同的数据库，内部都会实现不同的解析器，如<code>MySQL</code>有<code>MySQL</code>的解析器，<code>PgSQL</code>也会有对应的解析器，同时还会做<code>SQL</code>语句做优化。而<code>SQL</code>路由时，除开要考虑最基本的数据分片算法外，还需要考虑绑定表、广播表等配置，来对具体的<code>SQL</code>进行路由。</p>
<h1 id="2-分库分表产品对比"><a href="#2-分库分表产品对比" class="headerlink" title="2.分库分表产品对比"></a>2.分库分表产品对比</h1><table>
<thead>
<tr>
<th>对比项</th>
<th>Sharding-JDBC</th>
<th>Sharding-Proxy</th>
<th>MyCat</th>
</tr>
</thead>
<tbody><tr>
<td>性能开销</td>
<td>较低</td>
<td>较高</td>
<td>高</td>
</tr>
<tr>
<td>异构支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>网络次数</td>
<td>最少一次</td>
<td>最少两次</td>
<td>最少两次</td>
</tr>
<tr>
<td>异构语言</td>
<td>仅支持Java</td>
<td>支持异构</td>
<td>支持异构</td>
</tr>
<tr>
<td>数据库支持</td>
<td>任意数据库</td>
<td>MySQL、PgSQL</td>
<td>任意数据库</td>
</tr>
<tr>
<td>配置管理</td>
<td>去中心化</td>
<td>中心化</td>
<td>中心化</td>
</tr>
<tr>
<td>部署方式</td>
<td>依赖工程</td>
<td>中间件</td>
<td>中间件</td>
</tr>
<tr>
<td>业务侵入性</td>
<td>较低</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>连接开销</td>
<td>高</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>事务支持</td>
<td>XA、Base、Local事务</td>
<td>同前者</td>
<td>XA事务</td>
</tr>
<tr>
<td>功能丰富度</td>
<td>多</td>
<td>多</td>
<td>一般</td>
</tr>
<tr>
<td>社区活跃性</td>
<td>活跃</td>
<td>活跃</td>
<td>一言难尽</td>
</tr>
<tr>
<td>版本迭代性</td>
<td>高</td>
<td>高</td>
<td>极低</td>
</tr>
<tr>
<td>多路由键支持</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>集群部署</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>分布式序列</td>
<td>雪花算法</td>
<td>雪花算法</td>
<td>自增序列</td>
</tr>
</tbody></table>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Mysql排查" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/07/10/Mysql%E6%8E%92%E6%9F%A5/" class="article-date">
      <time datetime="2024-07-10T05:31:21.000Z" itemprop="datePublished">2024-07-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/07/10/Mysql%E6%8E%92%E6%9F%A5/">Mysql排查</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>在程序开发与运行过程中，出现<code>Bug</code>问题的几率无可避免，数据库出现问题一般会发生在下述几方面：</p>
<ul>
<li><p>①撰写的<code>SQL</code>语句执行出错，俗称为业务代码<code>Bug</code>。</p>
</li>
<li><p>②开发环境执行一切正常，线上偶发<code>SQL</code>执行缓慢的情况。</p>
</li>
<li><p>③线上部署<code>MySQL</code>的机器故障，如磁盘、内存、<code>CPU100%</code>，<code>MySQL</code>自身故障等。</p>
</li>
</ul>
<h2 id="1-1-线上排查和解决问题思路"><a href="#1-1-线上排查和解决问题思路" class="headerlink" title="1.1 线上排查和解决问题思路"></a>1.1 线上排查和解决问题思路</h2><p> 相对而言，解决故障问题也好，处理性能瓶颈也罢，通常思路大致都是相同的，步骤如下：</p>
<ul>
<li>①分析问题：根据理论知识+经验分析问题，判断问题可能出现的位置或可能引起问题的原因，将目标缩小到一定范围。</li>
<li>②排查问题：基于上一步的结果，从引发问题的“可疑性”角度出发，从高到低依次进行排查，进一步排除一些选项，将目标范围进一步缩小。</li>
<li>③定位问题：通过相关的监控数据的辅助，以更“细粒度”的手段，将引发问题的原因定位到精准位置。</li>
<li>④解决问题：判断到问题出现的具体位置以及引发的原因后，采取相关措施对问题加以解决。</li>
<li>⑤尝试最优解（非必须）：将原有的问题解决后，在能力范围内，且环境允许的情况下，应该适当考虑问题的最优解（可以从性能、拓展性、并发等角度出发）。</li>
</ul>
<p><strong>我的解决方案：</strong></p>
<p>  当然，上述过程是针对特殊问题以及经验老道的开发者而言的，作为“新时代的程序构建者”，那当然得学会合理使用工具来帮助我们快速解决问题：</p>
<ul>
<li>①摘取或复制问题的关键片段。</li>
<li>②打开百度或谷歌后粘贴搜索。</li>
<li>③观察返回结果中，选择标题与描述与自己问题较匹配的资料进入。</li>
<li>④多看几个后，根据其解决方案尝试解决问题。</li>
<li>⑤成功解决后皆大欢喜，尝试无果后“找人/问群”。</li>
<li>⑥“外力”无法解决问题时自己动手，根据之前的步骤依次排查解决。</li>
</ul>
<h2 id="1-2-线上排查方向"><a href="#1-2-线上排查方向" class="headerlink" title="1.2 线上排查方向"></a>1.2 线上排查方向</h2><p>==①发生问题的大体定位，②逐步推导出具体问题的位置==</p>
<ul>
<li><p>1.应用程序本身导致的问题</p>
</li>
<li><ul>
<li>程序内部频繁触发GC，造成系统出现长时间停顿，导致客户端堆积大量请求。</li>
<li>JVM参数配置不合理，导致线上运行失控，如堆内存、各内存区域太小等。【遇到启动项目OOM,在idea创建设置堆空间大小700到10000解决】</li>
<li>Java程序代码存在缺陷，导致线上运行出现Bug，如死锁/内存泄漏、溢出等。</li>
<li>程序内部资源使用不合理，导致出现问题，如线程/DB连接/网络连接/堆外内存等。</li>
</ul>
</li>
<li><p>2.上下游内部系统导致的问题</p>
</li>
<li><ul>
<li>上游服务出现并发情况，导致当前程序请求量急剧增加，从而引发问题拖垮系统。</li>
<li>下游服务出现问题，导致当前程序堆积大量请求拖垮系统，如Redis宕机/DB阻塞等。</li>
</ul>
</li>
<li><p>3.程序所部署的机器本身导致的问题</p>
</li>
<li><ul>
<li>服务器机房网络出现问题，导致网络出现阻塞、当前程序假死等故障。</li>
<li>服务器中因其他程序原因、硬件问题、环境因素（如断电）等原因导致系统不可用。</li>
<li>服务器因遭到入侵导致Java程序受到影响，如木马病毒/矿机、劫持脚本等。</li>
</ul>
</li>
<li><p>4.第三方的RPC远程调用导致的问题</p>
</li>
<li><ul>
<li>作为被调用者提供给第三方调用，第三方流量突增，导致当前程序负载过重出现问题。</li>
<li>作为调用者调用第三方，但因第三方出现问题，引发雪崩问题而造成当前程序崩溃。</li>
</ul>
</li>
</ul>
<h1 id="2-Sql语句执行出错—排查"><a href="#2-Sql语句执行出错—排查" class="headerlink" title="2.Sql语句执行出错—排查"></a>2.Sql语句执行出错—排查</h1><p>作为一个程序员，对<code>MySQL</code>数据库而言，接触最多的就是<code>SQL</code>语句的撰写，和写业务代码时一样，写代码时会碰到异常、错误，而写<code>SQL</code>时同样如此，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1064 (42000):</span><br><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;xxxxxxx&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>Mysql的错误信息会由三部分组成：</p>
<ul>
<li><p>ErrorCode：错误码【1064这种】</p>
</li>
<li><p>SQLState：Sql状态【42000这种】</p>
</li>
<li><p>ErrorInfo：错误详情【；之后跟一长串描述具体错误详情】</p>
</li>
</ul>
<p>Mysql的错误类型：</p>
<ul>
<li>根据ErrorInfo位置根据错误类型定位，认真对准之后百度搜索</li>
<li>没有定位，只能通过SQLstate和网上办法解决</li>
</ul>
<h1 id="3-Mysql线上慢查询语句—排查"><a href="#3-Mysql线上慢查询语句—排查" class="headerlink" title="3.Mysql线上慢查询语句—排查"></a>3.Mysql线上慢查询语句—排查</h1><p>有些SQL可能在开发环境没有任何问题，但放到线上时就会出现偶发式执行耗时较长的情况，所以这类情况就只能真正在线上环境才能测出来，尤其是一些不支持灰度发布的中小企业，也只能放到线上测才能发现问题。</p>
<h2 id="3-1-打开Mysql慢查询日志"><a href="#3-1-打开Mysql慢查询日志" class="headerlink" title="3.1 打开Mysql慢查询日志"></a>3.1 打开Mysql慢查询日志</h2><p>一般在上线前，Mysql手动打开慢查询日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启慢查询日志需要配置两个关键参数：</span><br><span class="line">• slow_query_log：取值为on&#x2F;off[默认]-----项目上线前需要手动开启。</span><br><span class="line">• long_query_time：指定记录慢查询日志的阈值，[单位是秒,指定更细粒度用小数表示]-----阈值根据不同的业务系统取值也不同【①设置一个大概值，灰度发布时走正式运营场景效果更好②开启查询日志，压测所有业务，紧接着分析查询日志中sql的平均耗时，再根据正常的sql执行时间，设置一个偏大的慢查询阈值即可】---公司内设置的是3s</span><br></pre></td></tr></table></figure>



<h2 id="3-2-查看Mysql慢查询日志"><a href="#3-2-查看Mysql慢查询日志" class="headerlink" title="3.2 查看Mysql慢查询日志"></a>3.2 查看Mysql慢查询日志</h2><p>查看慢查询日志的方式：</p>
<ul>
<li>拥有完善的监控系统：【自动】读取磁盘中的慢查询日志，然后可以通过监控系统大屏观察</li>
<li>未拥有完善的监控系统：linux系统通过cat类指令查看本地日志文件/windows记事本打开</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101502616.png" alt="image-20240710150212444"></p>
<p>从上面日志中记录的查询信息来看，可以得知几个信息：</p>
<ul>
<li>• 执行慢查询<code>SQL</code>的用户：<code>root</code>，登录<code>IP</code>为：<code>localhost[127.0.0.1]</code>。</li>
<li>• 慢查询执行的具体耗时为：<code>0.014960s</code>，锁等待时间为<code>0s</code>。</li>
<li>• 本次<code>SQL</code>执行后的结果集为<code>4</code>行数据，累计扫描<code>6</code>行数据。</li>
<li>• 本次慢查询发生在<code>db_zhuzi</code>这个库中，发生时间为<code>1667466932（2022-11-03 17:15:32）</code>。</li>
<li>• 最后一行为具体的慢查询<code>SQL</code>语句。</li>
</ul>
<h2 id="3-3-排查sql执行缓慢问题"><a href="#3-3-排查sql执行缓慢问题" class="headerlink" title="3.3 排查sql执行缓慢问题"></a>3.3 排查sql执行缓慢问题</h2><p>通过3.2步骤我们读取慢查询日志后，能够精准定位到发生慢查询Sql的用户、客户端机器、执行耗时、锁阻塞耗时、结果集行数、扫描行数、发生的库和事件、具体的慢查询sql语句。</p>
<p>得到这些信息之后，其实排查引起慢查询的原因就通过以下<strong>步骤</strong>就可以：</p>
<ul>
<li>①根据本地慢查询日志文件中的记录，得到具体慢查询sql执行的相关信息</li>
<li>②查看lock_time的耗时，判断本次执行缓慢是否由于并发事务导致的长时间阻塞【多半原因】<ul>
<li>2.1 如果是，是由于并发事务导致的长时间阻塞【并发事务抢占锁，造成当前事务长时间无法获取锁资源】，看到大量由于<strong>锁阻塞</strong>导致执行超过阈值，那就执行查看mysql锁状态，如果值都比较大意味着当前这个mysql节点承担的并发压力过大，急需mysql架构优化</li>
<li>2.2 如果不是，通过①explain索引分析工具，先判断索引使用情况，找到那些执行计划中扫描行数过多、<code>type=index/all</code>的<code>SQL</code>语句，尝试优化掉即可；②人肉排查法解决</li>
</ul>
</li>
</ul>
<p>一般来说在开发环境中没有问题的<code>SQL</code>语句，放到线上环境出现执行缓慢的情况，多半原因是由于并发事务抢占锁，造成当前事务长时间无法获取锁资源，因此导致当前事务执行的<code>SQL</code>出现超时，这种情况下需要去定位操作相同行数据的大事务，一般长时间的阻塞是由于大事务持有锁导致的，找出对应的大事务并拆解或优化掉即可。【<strong>基本就是操作相同行数据的大事务持有锁</strong>】</p>
<h3 id="3-3-1-长时间锁阻塞的排查方法-查看lock-time时间"><a href="#3-3-1-长时间锁阻塞的排查方法-查看lock-time时间" class="headerlink" title="3.3.1 长时间锁阻塞的排查方法[查看lock_time时间]"></a>3.3.1 长时间锁阻塞的排查方法[查看lock_time时间]</h3><p>通过<code>show status like &#39;innodb_row_lock_%&#39;;</code>命令可以查询<code>MySQL</code>整体的锁状态，如下：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101710220.png" alt="image-20240710171033106"></p>
<ul>
<li><code>Innodb_row_lock_current_waits</code>：当前正在阻塞等待锁的事务数量。</li>
<li><code>Innodb_row_lock_time</code>：<code>MySQL</code>启动到现在，所有事务总共阻塞等待的总时长。</li>
<li><code>Innodb_row_lock_time_avg</code>：平均每次事务阻塞等待锁时，其平均阻塞时长。</li>
<li><code>Innodb_row_lock_time_max</code>：<code>MySQL</code>启动至今，最长的一次阻塞时间。</li>
<li><code>Innodb_row_lock_waits</code>：<code>MySQL</code>启动到现在，所有事务总共阻塞等待的总次数。</li>
</ul>
<h3 id="3-3-2-非锁阻塞的排查方法-explain-拆分语句"><a href="#3-3-2-非锁阻塞的排查方法-explain-拆分语句" class="headerlink" title="3.3.2 非锁阻塞的排查方法[explain/拆分语句]"></a>3.3.2 非锁阻塞的排查方法[explain/拆分语句]</h3><ul>
<li>方法一：explain解释方法：</li>
</ul>
<p>找到那些执行计划中扫描行数过多、<code>type=index/all</code>的<code>SQL</code>语句，尝试优化掉即可</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101717137.png" alt="image-20240710171706075"></p>
<ul>
<li>方法二：人肉排查法：</li>
</ul>
<p>【对于一些较为复杂或庞大的业务需求，可以采取<strong>拆分法</strong>去逐步实现，最后组装所有的子语句，最终推导出符合业务需求的<code>SQL</code>语句】</p>
<p>一条复杂的查询语句，拆解成一条条子语句，对每条子语句使用<code>explain</code>工具分析，精准定位到：复杂语句中导致耗时较长的具体子语句，最后将这条子语句优化后重新组装即可。</p>
<p>【拆解排除法有一个最大的好处是：有时组成复杂<code>SQL</code>的每条子语句都不存在问题，也就是每条子语句的执行效率都挺不错的，但是拼到一起之后就会出现执行缓慢的现象，这时拆解后就可以一步步的将每条子语句组装回去，每组装一条子语句都可以用<code>explain</code>工具分析一次，这样也能够精准定位到是由于那条子语句组合之后导致执行缓慢的，然后进行对应优化即可。】</p>
<h1 id="4-Mysql线上机器故障排查"><a href="#4-Mysql线上机器故障排查" class="headerlink" title="4.Mysql线上机器故障排查"></a>4.Mysql线上机器故障排查</h1><p> <code>MySQL</code>数据库线上的机器故障主要分为两方面，①是由于<strong>MySQL自身</strong>引起的问题，比如连接异常、死锁问题等，②是部署<strong>MySQL的服务器硬件文件，如磁盘、<code>CPU100%</code></strong>等现象，对于不同的故障问题排查手段也不同，下面将展开聊一聊常见的线上故障及解决方案。</p>
<h2 id="4-1-客户端连接异常"><a href="#4-1-客户端连接异常" class="headerlink" title="4.1 客户端连接异常"></a>4.1 客户端连接异常</h2><p>当数据库出现连接异常时，基本上就是因为四种原因导致：</p>
<p>【①②比较简单，设置两者参数就行】</p>
<ul>
<li>①数据库总体的现有连接数，超出了<code>MySQL</code>中的最大连接数，此时再出现新连接时会出异常。【遇到过，直接更新参数，加大核心线程数即可】</li>
<li>②客户端数据库连接池与<code>MySQL</code>版本不匹配，或超时时间过小，也可能导致出现连接中断。</li>
</ul>
<p>【③④比较特殊】</p>
<ul>
<li>③<code>MySQL、Java</code>程序所部署的机器不位于同一个网段，两台机器之间网络存在通信故障。</li>
<li>④部署<code>MySQL</code>的机器资源被耗尽，如<code>CPU</code>、硬盘过高，导致<code>MySQL</code>没有资源分配给新连接。</li>
</ul>
<hr>
<p>其中，介绍一下③④情况：</p>
<p><strong>③<code>MySQL、Java</code>程序所部署的机器不位于同一个网段，两台机器之间网络存在通信故障</strong></p>
<p>这种情况，问题一般都出在交换机上面，由于<code>Java</code>程序和数据库两者不在同一个网段，所以相互之间通信需要利用交换机来完成，但默认情况下，交换机和防火墙一般会认为时间超过<code>3~5</code>分钟的连接是不正常的，因此就会中断相应的连接，而有些低版本的数据库连接池，如<code>Druid</code>只会在获取连接时检测连接是否有效，此时就会出现一个问题：</p>
<p>交换机把两个网段之间的长连接嘎了，但是<code>Druid</code>因为<strong>只在最开始检测了一次</strong>，后续不会继续检测连接是否有效，所以会认为获取连接后是一直有效的，最终就导致了数据库连接出现异常（<strong>后续</strong>高版本的<code>Druid</code>修复了该问题，可以配置<strong>间隔一段时间检测一次连接</strong>）</p>
<p>一般如果是由于网络导致出现连接异常，通常排查方向如下：</p>
<ul>
<li>• 检测防火墙与安全组的端口是否开放，或与外网机器是否做了端口映射。</li>
<li>• 检查部署<code>MySQL</code>的服务器白名单，以及登录的用户<code>IP</code>限制，可能是<code>IP</code>不在白名单范围内。</li>
<li>• 如果整个系统各节点部署的网段不同，检查各网段之间交换机的连接超时时间是多少。</li>
<li>• 检查不同网段之间的网络带宽大小，以及具体的带宽使用情况，有时因带宽占满也会出现问题。</li>
<li>• 如果用了<code>MyCat、MySQL-Proxy</code>这类代理中间件，记得检查中间件的白名单、超时时间配置。</li>
</ul>
<p>一般来说上述各方面都不存在问题，基本上连接异常应该不是由于网络导致的问题，要做更为细致的排查，可以在请求链路的各节点上，<strong>使用网络抓包工具，抓取对应的网络包，看看网络包是否能够抵达每个节点</strong>，如果每个节点的出入站都正常，此时就可以排除掉网络方面的原因。</p>
<p><strong>④部署<code>MySQL</code>的机器资源被耗尽，如<code>CPU</code>、硬盘过高，导致<code>MySQL</code>没有资源分配给新连接。</strong></p>
<p>这种情况更为特殊，网络正常、连接数未满、连接未超时、数据库和客户端连接池配置正常….，在一切正常的情况下，有时候照样出现连接不上<code>MySQL</code>的情况咋整呢？在这种情况下基本上会陷入僵局，这时你可以去<strong>查一下部署<code>MySQL</code>服务的机器，</strong>其硬件的使用情况，如<code>CPU</code>、内存、磁盘等，如果其中一项达到了<code>100%</code>，这时就能够确定问题了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为数据库连接的本质，在MySQL内部是一条条的工作线程，要牢记的一点是：操作系统在创建一条线程时，都需要为其分配相关的资源，如果一个客户端尝试与数据库建立新的连接时，此刻正好有一个数据库连接在执行某个操作，导致CPU被打满，这时就会由于没有资源来创建新的线程，因此会向客户端直接返回连接异常的信息。</span><br></pre></td></tr></table></figure>

<p>先找到导致资源耗尽的连接/线程，然后找到它当时正在执行的<code>SQL</code>语句，最后需要优化相应的<code>SQL</code>语句后才能彻底根治问题。</p>
<h2 id="4-2-Mysql死锁频发-业务出发解决"><a href="#4-2-Mysql死锁频发-业务出发解决" class="headerlink" title="4.2 Mysql死锁频发[业务出发解决]"></a>4.2 Mysql死锁频发[业务出发解决]</h2><p><code>MySQL</code>内部其实会【默认】开启死锁检测算法，当运行期间出现死锁问题时，会主动介入并解除死锁，但要记住：<strong>虽然数据库能够主动介入解除死锁问题，但这种方法治标不治本</strong>因为死锁现象是由于业务不合理造成的，能出现一次死锁问题，自然后续也可能会多次出现，因此优化业务才是最好的选择，这样才能根治死锁问题。</p>
<p>从业务上解决死锁问题：①先定准定位到产生死锁的<code>SQL</code>语句，根据查看<strong>innodb存储引擎的运行状态日志</strong>【找到内部latest detected deadlock区域日志】</p>
<p>例如：<br><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101832765.png" alt="image-20240710183226640"></p>
<p>在上面的日志中，基本上已经写的很清楚了，在<code>2022-11-04 23:04:34</code>这个时间点上，检测到了一个死锁出现，该死锁主要由两个事务产生，<code>SQL</code>如下：</p>
<ul>
<li>• <code>(1)：UPDATE</code>zz_account<code>SET balance = balance + 888 WHERE user_name = &quot;熊猫&quot;;</code></li>
<li>• <code>(2)：UPDATE</code>zz_account<code>SET balance = balance + 666 WHERE user_name = &quot;竹子&quot;;</code></li>
</ul>
<p>在事务信息除开列出了导致死锁的<code>SQL</code>语句外，还给出了两个事务对应的线程<code>ID</code>、登录的用户和<code>IP</code>、事务的存活时间与系统线程<code>ID</code>、持有的锁信息与等待的锁信息….</p>
<p>除开两个发生死锁的事务信息外，倒数第二段落还给出了两个事务在哪个锁上产生了冲突，以上述日志为例，发生死锁冲突的地点位于<code>db_zhuzi</code>库中<code>zz_account</code>表的主键上，两个事务都在尝试获取对方持有的<code>X</code>排他锁，后面还给出了具体的页位置、内存地址….。</p>
<p>最后一条信息中，给出了<code>MySQL</code>介入解除死锁的方案，也就是回滚了事务<code>(2)</code>的操作，强制结束了事务<code>(2)</code>并释放了其持有的锁资源，从而能够让事务<code>(1)</code>继续运行。</p>
<p>经过查看上述日志后，其实<code>MySQL</code>已经为我们记录了产生死锁的事务、线程、<code>SQL</code>、时间、地点等各类信息，因此想要彻底解决死锁问题的方案也很简单了，<strong>根据日志中给出的信息，去找到执行相应<code>SQL</code>的业务和库表，优化<code>SQL</code>语句的执行顺序，或<code>SQL</code>的执行逻辑，从而避免死锁产生即可。</strong></p>
<p>最后要注意：如果是一些偶发类的死锁问题，也就是很少出现的死锁现象，其实不解决也行，毕竟只有在一些特殊场景下才有可能触发，重点是要关注死锁日志中那些频繁出现的死锁问题，也就是多次死锁时，每次死锁出现的库、表、字段都相同，这种情况时需要额外重视并着手解决。</p>
<h2 id="4-3-服务器CPU100"><a href="#4-3-服务器CPU100" class="headerlink" title="4.3 服务器CPU100%"></a>4.3 服务器CPU100%</h2><p>排查思路：</p>
<ul>
<li>①先找到<code>CPU</code>过高的<strong>服务器</strong>。</li>
<li>②然后在其中定位到具体的进程。【top指令】</li>
<li>③再定位到进程中具体的<strong>线程</strong>。【top -Hpxxxx】 xxxx就是②查出来的PID进程号</li>
<li>④再查看线程<strong>正在执行的代码逻辑</strong>。【mysql5.7以下查找innodb运行状态日志的某个部分/mysql5.7以上通过threads表信息查找】</li>
<li>⑤最后从<strong>代码层面着手优化</strong>掉即可。</li>
</ul>
<p>②先使用<strong>top指令</strong>查看系统后台的进程状态：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101839522.png" alt="image-20240710183927468"></p>
<p>从如上结果中不难发现，<code>PID</code>为<code>76661</code>的<code>MySQL</code>进程对<code>CPU</code>的占用率达到<code>99.9%</code>，此时就可以确定，机器的<code>CPU</code>利用率飙升是由于该进程引起的。</p>
<p>③根据<strong>top -Hp [PID]指令</strong>查看进程中cpu占用率最高的线程：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101841870.png" alt="image-20240710184121817"></p>
<p>从<code>top -Hp 76661</code>命令的执行结果中可以看出：其他线程均为休眠状态，并未持有<code>CPU</code>资源，而PID为<code>77935</code>的线程对CPU资源的占用率却高达<code>99.9%</code>！</p>
<p>到此时，导致<code>CPU</code>利用率飙升的“罪魁祸首”已经浮现水面，但此时问题来了！在如果这里是<code>Java</code>程序，此时可以先将该线程的<code>PID</code>转换为<code>16</code>进制的值，然后进一步排查日志信息来确定具体线程执行的业务方法。但此时这里是<code>MySQL</code>程序，咱们得到了操作系统层面的线程<code>ID</code>后，如何根据这个<code>ID</code>在<code>MySQL</code>中找到对应的线程呢？</p>
<p>④分为Mysql5.7以上和Mysql5.7以下两种情况：</p>
<ul>
<li>在<code>MySQL5.7</code>及以上的版本中，<code>MySQL</code>会自带一个名为<code>performance_schema</code>的库，在其中有一张名为<code>threads</code>的表，其中表中有一个<code>thread_os_id</code>字段，其中会保存每个连接/工作线程与操作系统线程之间的关系（在<code>5.7</code>以下的版本是隐式的，存在于<code>MySQL</code>内部无法查看）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101851349.png" alt="image-20240710185143259"></p>
<p>可以通过查询threads表，输出所有已经创建的线程：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101852819.png" alt="image-20240710185225772"></p>
<p>从上述中可以明显看出<code>MySQL</code>线程和<code>OS</code>线程之间的关系，当通过前面的<code>top</code>指令拿到<code>CPU</code>利用率最高的线程<code>ID</code>后，在再这里找到与之对应的<code>MySQL</code>线程，同时也能够看到此线程正在执行的<code>SQL</code>语句，最后优化对应<code>SQL</code>语句的逻辑即可。</p>
<ul>
<li>在<code>MySQL5.7</code>以下的版本中，我们只能通过Innodb存储引擎状态表的transactions板块查看，</li>
</ul>
<p>统计着所有存活事务的信息，此时也可以从中得到相应的<code>OS</code>线程、<code>MySQL</code>线程的映射关系</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101854479.png" alt="image-20240710185424434"></p>
<p>是这种方式仅能够获取到<code>OS</code>线程、<code>MySQL</code>线程之间的映射关系，无法获取到对应线程/连接正在执行的<code>SQL</code>语句，此时如果线程还在运行，则可以通过<code>show processlist;</code>查询，如下：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202407101854968.png" alt="image-20240710185448934"></p>
<p>但这种方式<strong>只能看到正在执行的<code>SQL</code>语句</strong>，无法查询到最近执行过的语句，所以这种方式仅适用于：==线上<code>SQL</code>还在继续跑的情况==。</p>
<h2 id="4-4-Mysql刷盘100"><a href="#4-4-Mysql刷盘100" class="headerlink" title="4.4 Mysql刷盘100%"></a>4.4 Mysql刷盘100%</h2><p>指磁盘<code>IO</code>达到<code>100%</code>利用率，这种情况下一般会导致其他读写操作都被阻塞，因为操作系统中的<code>IO</code>总线会被占满，无法让给其他线程来读写数据，先来总结一下出现磁盘<code>IO</code>占用过高的原因：</p>
<ul>
<li>• ①突然大批量变更库中数据，需要执行大量写入操作，如主从数据同步时就会出现这个问题。</li>
<li>• ②<code>MySQL</code>处理的整体并发过高，磁盘<code>I/O</code>频率跟不上，比如是机械硬盘材质，读写速率过慢。</li>
<li>• ③内存中的<code>BufferPool</code>缓冲池过小，大量读写操作需要落入磁盘处理，导致磁盘利用率过高。</li>
<li>• ④频繁创建和销毁临时表，导致内存无法存储临时表数据，因而转到磁盘存储，导致磁盘飙升。</li>
<li>• ⑤执行某些<code>SQL</code>时从磁盘加载海量数据，如超<code>12</code>张表的联查，并每张表数据较大，最终导致<code>IO</code>打满。</li>
<li>• ⑥日志刷盘频率过高，其实这条是①、②的附带情况，毕竟日志的刷盘频率，跟整体并发直接挂钩。</li>
</ul>
<p>一般情况下，磁盘<code>IO</code>利用率居高不下，甚至超过<code>100%</code>，基本上是由于上述几个原因造成的，当需要排查磁盘<code>IO</code>占用率过高的问题时，可以先通过<code>iotop</code>工具找到磁盘<code>IO</code>开销最大的线程，然后利用<code>pstack</code>工具查看其堆栈信息，从堆栈信息来判断具体是啥原因导致的，如果是并发过高，则需要优化整体架构。如果是执行<code>SQL</code>加载数据过大，需要优化<code>SQL</code>语句……</p>
<p>磁盘利用率过高的问题其实也比较好解决，方案如下：</p>
<ul>
<li>• ①如果磁盘不是<code>SSD</code>材质，请先将磁盘升级成固态硬盘，<code>MySQL</code>对<code>SSD</code>硬盘做了特殊优化。</li>
<li>• ②在项目中记得引入<code>Redis</code>降低读压力，引入<code>MQ</code>对写操作做流量削峰。</li>
<li>• ③调大内存中<code>BufferPool</code>缓冲池的大小，最好设置成机器内存的<code>70~75%</code>左右。</li>
<li>• ④撰写<code>SQL</code>语句时尽量减少多张大表联查，不要频繁的使用和销毁临时表。</li>
</ul>
<p>基本上把上述工作都做好后，线上也不会出现磁盘<code>IO</code>占用过高的问题，对于前面说到的：利用<code>iotop、pstack</code>工具排查的过程，就不再做实际演示了，其过程与前面排查<code>CPU</code>占用率过高的步骤类似，大家学习<code>iotop、pstack</code>两个工具的用法后，其实实操起来也十分简单。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-微服务-分布式链路追踪" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/06/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/" class="article-date">
      <time datetime="2024-06-25T06:30:57.000Z" itemprop="datePublished">2024-06-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/06/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/">微服务-分布式链路追踪</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1-引入原因"><a href="#1-引入原因" class="headerlink" title="1.引入原因"></a>1.引入原因</h1><p><a href="https://mp.weixin.qq.com/s/YsYIZ3bEEd4h67NgBr0VFQ" target="_blank" rel="noopener">微信公众平台 (qq.com)</a></p>
<h1 id="2-常见的链路追踪技术"><a href="#2-常见的链路追踪技术" class="headerlink" title="2.常见的链路追踪技术"></a>2.常见的链路追踪技术</h1><ul>
<li>cat</li>
<li>zipkin</li>
<li>Sleuth</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Elasticsearch-黑马商城为例" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/06/22/Elasticsearch-%E9%BB%91%E9%A9%AC%E5%95%86%E5%9F%8E%E4%B8%BA%E4%BE%8B/" class="article-date">
      <time datetime="2024-06-22T12:37:34.000Z" itemprop="datePublished">2024-06-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/06/22/Elasticsearch-%E9%BB%91%E9%A9%AC%E5%95%86%E5%9F%8E%E4%B8%BA%E4%BE%8B/">Elasticsearch-黑马商城为例</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1-启动ES"><a href="#1-启动ES" class="headerlink" title="1.启动ES"></a>1.启动ES</h1><h2 id="1-1-安装elasticsearch"><a href="#1-1-安装elasticsearch" class="headerlink" title="1.1 安装elasticsearch"></a>1.1 安装elasticsearch</h2><p>通过下面的Docker命令即可安装单机版本的elasticsearch：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#先在tar所在目录下打开cmd</span><br><span class="line">docker load -i es.tar</span><br><span class="line"></span><br><span class="line">#创建一个网络【不然kibana不能连接es，踩坑了！！】</span><br><span class="line">docker network create elastic</span><br><span class="line"></span><br><span class="line">#黑马安装：</span><br><span class="line">docker run -d \</span><br><span class="line">  --name es \</span><br><span class="line">  -e &quot;ES_JAVA_OPTS&#x3D;-Xms512m -Xmx512m&quot; \        #配置jvm的内存</span><br><span class="line">  -e &quot;discovery.type&#x3D;single-node&quot; \            #配置运行模式【单点模式&#x2F;集群模式】</span><br><span class="line">  -v es-data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data \   #挂载</span><br><span class="line">  -v es-plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins \</span><br><span class="line">  --privileged \</span><br><span class="line">  --network hm-net \   </span><br><span class="line">  -p 9200:9200 \  #访问http端口</span><br><span class="line">  -p 9300:9300 \  #集群使用</span><br><span class="line">  elasticsearch:7.12.1</span><br><span class="line">  </span><br><span class="line">#csdn安装:</span><br><span class="line">docker run -d --name es -e ES_JAVA_OPTS&#x3D;&quot;-Xms512m -Xmx512m&quot; -e &quot;discovery.type&#x3D;single-node&quot; --privileged --network elastic -p 9200:9200 -p 9300:9300 elasticsearch:7.12.1</span><br></pre></td></tr></table></figure>

<p>启动之后访问<a href="http://localhost:9200/就可以看到elasticsearch信息：" target="_blank" rel="noopener">http://localhost:9200/就可以看到elasticsearch信息：</a></p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405072044725.png" alt="image-20240507204417602" style="zoom:67%;">



<h2 id="1-2-安装Kibana"><a href="#1-2-安装Kibana" class="headerlink" title="1.2 安装Kibana"></a>1.2 安装Kibana</h2><p>通过下面的Docker命令，即可部署Kibana：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#先在tar所在目录下打开cmd</span><br><span class="line">docker load -i kibana.tar</span><br><span class="line"></span><br><span class="line">#黑马安装：</span><br><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS&#x3D;http:&#x2F;&#x2F;es:9200 \   #es的地址，这里的es要和es配置docker的时候--name一致</span><br><span class="line">--network&#x3D;hm-net \  #网络和es一个网络</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1  #要保证和es版本一致！！！</span><br><span class="line"></span><br><span class="line">#csdn安装：</span><br><span class="line">docker run -d --name kibana -e ELASTICSEARCH_HOSTS&#x3D;http:&#x2F;&#x2F;es:9200 --network elastic -p 5601:5601  kibana:7.12.1</span><br></pre></td></tr></table></figure>

<p>启动之后访问<a href="http://localhost:5601/就可以通过kibana数据化访问elasticsearch：" target="_blank" rel="noopener">http://localhost:5601/就可以通过kibana数据化访问elasticsearch：</a></p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405072046111.png" alt="image-20240507204635028" style="zoom:80%;">

<p>可以点击右上角Dev tools，进入开发工具页面：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405221602466.png" alt="image-20240507204914788"></p>
<p>点击之后：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405072051099.png" alt="image-20240507205135009"></p>
<h1 id="2-改造操作步骤"><a href="#2-改造操作步骤" class="headerlink" title="2.改造操作步骤"></a>2.改造操作步骤</h1><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为<code>RestHighLevelClient</code>的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p>
<h2 id="2-1-初始化RestClient"><a href="#2-1-初始化RestClient" class="headerlink" title="2.1 初始化RestClient"></a>2.1 初始化RestClient</h2><h3 id="2-1-1-引入RestHighLevelClient依赖"><a href="#2-1-1-引入RestHighLevelClient依赖" class="headerlink" title="2.1.1 引入RestHighLevelClient依赖"></a>2.1.1 引入RestHighLevelClient依赖</h3><p>在微服务模块中引入<code>es</code>的<code>RestHighLevelClient</code>依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-覆盖ES版本"><a href="#2-1-2-覆盖ES版本" class="headerlink" title="2.1.2 覆盖ES版本"></a>2.1.2 覆盖ES版本</h3><p>因为SpringBoot默认的ES版本是<code>7.17.10</code>，所以我们需要覆盖默认的ES版本【黑马商城是在pom.xml中修改】：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;11&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;11&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">    &lt;!--覆盖成7.12.1--&gt;</span><br><span class="line">    &lt;elasticsearch.version&gt;7.12.1&lt;&#x2F;elasticsearch.version&gt;  </span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-初始化RestHighLevelClient"><a href="#2-1-3-初始化RestHighLevelClient" class="headerlink" title="2.1.3 初始化RestHighLevelClient"></a>2.1.3 初始化RestHighLevelClient</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RestHighLevelClient client &#x3D; new RestHighLevelClient(</span><br><span class="line">    &#x2F;&#x2F;使用RestClient的builder方法创建</span><br><span class="line">    RestClient.builder(</span><br><span class="line">        HttpHost.create(&quot;http:&#x2F;&#x2F;192.168.xxx.xxx:9200&quot;)</span><br><span class="line">	)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="2-2-分析Mysql设计ES实现"><a href="#2-2-分析Mysql设计ES实现" class="headerlink" title="2.2 分析Mysql设计ES实现"></a>2.2 分析Mysql设计ES实现</h2><p>我们针对购物车数据库进行分析：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405201728989.png" alt="image-20240520172813812"></p>
<p>我们可以对购物车的所有字段进行分析，判断哪些字段必须添加到ElasticSearch中，判断哪些字段必须添加搜索功能。从而进行新建索引库和映射：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405201717606.png" alt="image-20240520171754450"></p>
<p>具体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;items</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;stock&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;image&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;category&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;brand&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;sold&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;commentCount&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;index&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;isAD&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;updateTime&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-索引库操作-client-indices-xxx"><a href="#2-3-索引库操作-client-indices-xxx" class="headerlink" title="2.3 索引库操作(client.indices.xxx)"></a>2.3 索引库操作(client.indices.xxx)</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是<code>client.indices()</code>方法来获取索引库的操作对象。</p>
<p>索引库操作的基本步骤：</p>
<ul>
<li>1.初始化RestHighLevelClient类对象client【创建客户端】</li>
<li>2.创建XxxIndexRequest对象request【XXX是<code>Create</code>、<code>Get</code>、<code>Delete</code>】</li>
<li>3.准备请求参数request.source()方法【只有新增<code>Create</code>需要参数，其他情况不需要】</li>
<li>4.发送请求client.indices().xxx()方法【xxx是<code>create</code>、<code>exists</code>、<code>delete</code>】</li>
</ul>
<h3 id="2-3-1-创建索引库"><a href="#2-3-1-创建索引库" class="headerlink" title="2.3.1 创建索引库"></a>2.3.1 创建索引库</h3><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405201733352.png" alt="image-20240520173351287"></p>
<h3 id="2-3-2-删除索引库"><a href="#2-3-2-删除索引库" class="headerlink" title="2.3.2 删除索引库"></a>2.3.2 删除索引库</h3><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405211351946.png" alt="image-20240521135115905" style="zoom:80%;">

<h3 id="2-3-2-查询索引库"><a href="#2-3-2-查询索引库" class="headerlink" title="2.3.2 查询索引库"></a>2.3.2 查询索引库</h3><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405211351275.png" style="zoom:80%;">



<h2 id="2-4-文档操作-client-xxx"><a href="#2-4-文档操作-client-xxx" class="headerlink" title="2.4 文档操作(client.xxx)"></a>2.4 文档操作(client.xxx)</h2><p>文档操作的基本步骤：</p>
<ul>
<li>1.初始化RestHighLevelClient类对象client【创建客户端】</li>
<li>2.创建XxxRequest对象request【Xxx是<code>Index</code>、<code>Update</code>、<code>Delete</code>、<code>Bulk</code>】</li>
<li>3.准备请求参数request.source()方法（<code>Index</code>、<code>Update</code>、<code>Bulk</code>时需要）</li>
<li>4.发送请求client.Xxx()方法【Xxx是<code>index</code>、<code>get</code>、<code>update</code>、<code>delete</code>、<code>bulk</code>】</li>
<li>5.解析结果（<code>Get</code>查询时需要，数据在_source内部）</li>
</ul>
<h3 id="2-4-1-新增文档"><a href="#2-4-1-新增文档" class="headerlink" title="2.4.1 新增文档"></a>2.4.1 新增文档</h3><ul>
<li>1.创建Request对象，这里是<code>IndexRequest</code>，因为添加文档就是创建倒排索引的过程</li>
<li>2.准备请求参数，本例中就是Json文档</li>
<li>3.发送请求【client.index()方法就好了】</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405211427513.png" alt="image-20240521142712455"></p>
<h3 id="2-4-2-查询文档"><a href="#2-4-2-查询文档" class="headerlink" title="2.4.2 查询文档"></a>2.4.2 查询文档</h3><p>与之前的流程类似，代码大概分2步：</p>
<ul>
<li>创建Request对象</li>
<li>准备请求参数，这里是无参，【直接省略】</li>
<li>发送请求</li>
<li>解析结果【因为结果在_source部分内】</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405211428059.png" alt="image-20240521142844007"></p>
<p>可以看到，响应结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，反序列化为Java对象即可</p>
<h3 id="2-4-3-删除文档"><a href="#2-4-3-删除文档" class="headerlink" title="2.4.3 删除文档"></a>2.4.3 删除文档</h3><p>与查询相比，仅仅是请求方式从<code>DELETE</code>变成<code>GET</code>，可以想象Java代码应该依然是2步走：</p>
<ul>
<li>1）准备Request对象，因为是删除，这次是<code>DeleteRequest</code>对象。要指定索引库名和id</li>
<li>2）准备参数，无参，直接省略</li>
<li>3）发送请求。因为是删除，所以是<code>client.delete()</code>方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405211430055.png" alt="image-20240521143043972"></p>
<h3 id="2-4-4-修改文档"><a href="#2-4-4-修改文档" class="headerlink" title="2.4.4 修改文档"></a>2.4.4 修改文档</h3><p>修改我们讲过两种方式：</p>
<ul>
<li>全量修改：本质是先根据id删除，再新增【与新增文档】</li>
<li>局部修改：修改文档中的指定字段值</li>
</ul>
<p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p>
<ul>
<li>如果新增时，ID已经存在，则修改</li>
<li>如果新增时，ID不存在，则新增</li>
</ul>
<p>这里不再赘述，我们主要关注局部修改的API即可</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405211431593.png" alt="image-20240521143147541"></p>
<h3 id="2-4-5-批量导入文档"><a href="#2-4-5-批量导入文档" class="headerlink" title="2.4.5 批量导入文档"></a>2.4.5 批量导入文档</h3><p>因此<code>BulkRequest</code>中提供了<code>add</code>方法，用以添加其它CRUD的请求：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405211441488.png" alt="image-20240521144140401"></p>
<p>具体代码：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405211439619.png" alt="image-20240521143955532"></p>
<h2 id="2-5-高级查询"><a href="#2-5-高级查询" class="headerlink" title="2.5 高级查询"></a>2.5 高级查询</h2><p>文档搜索的基本步骤是：</p>
<ol>
<li>创建<code>SearchRequest</code>对象实例request</li>
<li>准备<code>request.source()</code>，也就是DSL语句【这个位置可以创建查询，分页，排序，聚合，高亮等操作】<ol>
<li><code>QueryBuilders</code>来构建查询条件</li>
<li>传入<code>request.source()</code> 的<code>query()</code>方法</li>
</ol>
</li>
<li>发送请求，得到结果</li>
<li>解析结果（参考DSL查询得到的JSON结果，从外到内，逐层解析）</li>
</ol>
<h3 id="2-5-1-查询数据"><a href="#2-5-1-查询数据" class="headerlink" title="2.5.1 查询数据"></a>2.5.1 查询数据</h3><p>我们可以分三步拼凑DSL语句和发起请求获取相应结果：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405221720814.png" alt="image-20240522172046658"></p>
<p>其中2.组织DSL参数的步骤中source()方法下面对应的查询/高亮/分页/排序/聚合：<br><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405221728464.png" alt="image-20240522172832347"></p>
<p>在查询方面我们直接可以通过QueryBuilders类调用对应的叶子查询/复杂查询</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405221729417.png" alt="image-20240522172921305"></p>
<h3 id="2-5-2-解析数据"><a href="#2-5-2-解析数据" class="headerlink" title="2.5.2 解析数据"></a>2.5.2 解析数据</h3><p>我们可以通过响应结果和Elasticsearch页面返回结果获取具体细节: 【<strong>可以扩展很多，但其实就是对照DSL查询结果写</strong>】</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405221738726.png" alt="image-20240522173851593"></p>
<p>黑马的图：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405221739571.png" alt="image-20240522173920457"></p>
<h1 id="3-代码实现思路"><a href="#3-代码实现思路" class="headerlink" title="3.代码实现思路"></a>3.代码实现思路</h1><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="==基础操作=="></a>==基础操作==</h2><ul>
<li><p>1.引入RestHighLevelClient依赖</p>
</li>
<li><p>2.初始化RestHighLevelClient</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestHighLevelClient client &#x3D; new RestHighLevelClient(</span><br><span class="line">    RestClient.builder(</span><br><span class="line">        HttpHost.create(&quot;http:&#x2F;&#x2F;192.168.xxx.xxx:9200&quot;)  &#x2F;&#x2F;使用RestClient的builder方法创建</span><br><span class="line">	)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>3.针对索引库(数据库表)操作【创建，查询，修改，删除】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">索引库操作的基本步骤：</span><br><span class="line">- 1.初始化RestHighLevelClient类对象client【创建客户端】</span><br><span class="line">- 2.创建XxxIndexRequest对象request【XXX是&#96;Create&#96;、&#96;Get&#96;、&#96;Delete&#96;】</span><br><span class="line">- 3.准备请求参数request.source()方法【只有新增&#96;Create&#96;需要参数，其他情况不需要】</span><br><span class="line">- 4.发送请求client.indices().xxx()方法【xxx是&#96;create&#96;、&#96;exists&#96;、&#96;delete&#96;】</span><br></pre></td></tr></table></figure>

<ul>
<li>4.针对文档(每一行数据)操作【创建，查询，修改，删除】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文档操作的基本步骤：</span><br><span class="line">- 1.初始化RestHighLevelClient类对象client【创建客户端】</span><br><span class="line">- 2.创建XxxRequest对象request【Xxx是&#96;Index&#96;、&#96;Update&#96;、&#96;Delete&#96;、&#96;Bulk&#96;】</span><br><span class="line">- 3.准备请求参数request.source()方法（&#96;Index&#96;、&#96;Update&#96;、&#96;Bulk&#96;时需要）</span><br><span class="line">- 4.发送请求client.Xxx()方法【Xxx是&#96;index&#96;、&#96;get&#96;、&#96;update&#96;、&#96;delete&#96;、&#96;bulk&#96;】</span><br><span class="line">- 5.解析结果（&#96;Get&#96;查询时需要，数据在_source内部）</span><br></pre></td></tr></table></figure>

<h2 id="高级操作-复杂的DSL查询"><a href="#高级操作-复杂的DSL查询" class="headerlink" title="==高级操作(复杂的DSL查询)=="></a>==高级操作(复杂的DSL查询)==</h2><p>5.在具体位置就可以进行复杂的DSL查询【可以进行查询，分页，排序，高亮，聚合等操作】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文档搜索的基本步骤是：</span><br><span class="line">1. 创建&#96;SearchRequest&#96;对象实例request</span><br><span class="line">2. 准备&#96;request.source()&#96;，也就是DSL语句【这个位置可以创建查询，分页，排序，聚合，高亮等操作】</span><br><span class="line">   1. &#96;QueryBuilders&#96;来构建查询条件</span><br><span class="line">   2. 传入&#96;request.source()&#96; 的&#96; query() &#96;方法</span><br><span class="line">3. 发送请求，得到结果</span><br><span class="line">4. 解析结果（参考DSL查询得到的JSON结果，从外到内，逐层解析）</span><br></pre></td></tr></table></figure>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-RabbitMQ-黑马商城为例" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/06/22/RabbitMQ-%E9%BB%91%E9%A9%AC%E5%95%86%E5%9F%8E%E4%B8%BA%E4%BE%8B/" class="article-date">
      <time datetime="2024-06-22T12:37:17.704Z" itemprop="datePublished">2024-06-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/06/22/RabbitMQ-%E9%BB%91%E9%A9%AC%E5%95%86%E5%9F%8E%E4%B8%BA%E4%BE%8B/">RabbitMQ-黑马商城为例</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>title: RabbitMQ-黑马商城为例<br>date: 2024-06-22 20:37:17<br>tags: RabbitMQ</p>
<h1 id="1-启动RabbitMQ"><a href="#1-启动RabbitMQ" class="headerlink" title="1.启动RabbitMQ"></a>1.启动RabbitMQ</h1><p>基于Docker来安装RabbitMQ，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker run </span><br><span class="line">-e RABBITMQ_DEFAULT_USER&#x3D;itheima   #设置默认用户名</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS&#x3D;123456   #设置默认密码</span><br><span class="line">-v mq-plugins:&#x2F;plugins   #将本地主机上的mq-plugins目录挂载到容器内部的&#x2F;plugins目录，可以存放插件</span><br><span class="line">--name mq    #指定容器名</span><br><span class="line">--hostname mq  #指定容器的主机名</span><br><span class="line">-p 15672:15672 #RabbitMQ管理页面登录的端口号 [浏览器输入http:&#x2F;&#x2F;localhost:15672&#x2F;即可进入]</span><br><span class="line">-p 5672:5672  #RabbitMQ用于AMQP协议通信 [SpringAMQP配置时候用]</span><br><span class="line">--network heima #将容器连接到名字为heima的网络中  [如果没有就使用命令创建hmall网络 docker network create heima]</span><br><span class="line">-d  #在后台运行容器</span><br><span class="line">rabbitmq:3.8-management  #使用RabbitMQ 3.8版本带有管理界面的镜像来创建容器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">精简版 --直接在虚拟机上启动docker然后docker run</span><br><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER&#x3D;itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS&#x3D;123456 \</span><br><span class="line"> -v mq-plugins:&#x2F;plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network heima\</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>

<p>可以看到在安装命令中有两个映射的端口：</p>
<ul>
<li>15672：RabbitMQ提供的管理控制台的端口</li>
<li>5672：RabbitMQ的消息发送处理接口</li>
</ul>
<p>通过访问 <a href="http://localhost:15672或者http://192.168.92.129:15672即可看到本地/服务器上的管理控制台。首次访问登录，需要配置文件中设定的用户名和密码">http://localhost:15672或者http://192.168.92.129:15672即可看到本地/服务器上的管理控制台。首次访问登录，需要配置文件中设定的用户名和密码</a></p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202404071407126.png" alt="image-20240319192803935"></p>
<p>创建hmall用户，并且配置一个hmall2虚拟空间</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406230026606.png" alt="image-20240623002616496"></p>
<h1 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2.操作步骤"></a>2.操作步骤</h1><ul>
<li><p>1.pom.xml中<strong>引入AMQP依赖</strong>：消费者和生产者项目</p>
</li>
<li><p>2.<strong>yml文件中配置</strong>RabbitMQ信息：</p>
<ul>
<li>2.1消费者项目【基础配置，消费者重试机制，消费者确认机制】</li>
<li>2.2生产者项目【基础配置，生产者重试机制，生产者确认机制】</li>
</ul>
</li>
<li><p>3.<strong>发送消息</strong>：生产者利用RabbitTemplate.convertAndSend(exchange交换机, routingKey路由key，message消息【传递的字段】(.setDelay设置延迟时间)，confirm消息确认机制信息);</p>
<ul>
<li>3.1 message默认是JDK序列化有一堆问题 –&gt;<strong>引入Jackson序列化</strong>【①引入依赖，②生产者和消费者的启动类添加@Bean注入】</li>
</ul>
</li>
<li><p>4.<strong>接收消息</strong>：消费者在方法上添加@RabbitListener注解</p>
<p>具体就是@RabbitListener(bindings=@QueueBinding(</p>
<p>​         value=@Queue(name=队列名，durable=true持久化，惰性队列arguments = @Argument(name=”x-queue-mode”,value = “lazy”)),</p>
<p>​         exchange=@Exchange(name=交换机名,type = ExchangeTypes.TOPIC，delayed=”true”延迟属性),</p>
<p>​         key={“绑定条件1”,”绑定条件2”}</p>
<p>​                                               ))</p>
<p>方法(原来传递的字段){</p>
<p>​    //里面写的就是之前直接调用的那个方法(serviceimpl层代码)</p>
<p>}</p>
</li>
</ul>
<h1 id="3-更改余额支付需求"><a href="#3-更改余额支付需求" class="headerlink" title="3.更改余额支付需求"></a>3.更改余额支付需求</h1><p>改造余额支付功能，将支付成功后基于OpenFeign的交易服务的更新订单状态接口的同步调用—–&gt;基于RabbitMQ的异步通知</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406222228873.png" alt="image-20240622222844704"></p>
<p>说明：目前没有通知服务和积分服务，因此我们只关注交易服务，步骤如下：</p>
<ul>
<li>定义<code>direct</code>类型交换机，命名为<code>pay.direct</code></li>
<li>定义消息队列，命名为<code>trade.pay.success.queue</code></li>
<li>将<code>trade.pay.success.queue</code>与<code>pay.direct</code>绑定，<code>BindingKey</code>为<code>pay.success</code></li>
<li>支付成功时不再调用交易服务更新订单状态的接口，而是发送一条消息到<code>pay.direct</code>，发送消息的<code>RoutingKey</code>  为<code>pay.success</code>，消息内容是订单id</li>
<li>交易服务监听<code>trade.pay.success.queue</code>队列，接收到消息后更新订单状态为已支付</li>
</ul>
<p>分析：</p>
<ul>
<li><p>生产者：支付服务pay-service</p>
</li>
<li><p>消费者：交易服务trade-service</p>
</li>
</ul>
<h2 id="3-1-pom-xml导入依赖"><a href="#3-1-pom-xml导入依赖" class="headerlink" title="3.1 pom.xml导入依赖"></a>3.1 pom.xml导入依赖</h2><p>在生产者和消费者的pom.xml文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息发送--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-yml配置RabbitMQ信息"><a href="#3-2-yml配置RabbitMQ信息" class="headerlink" title="3.2 yml配置RabbitMQ信息"></a>3.2 yml配置RabbitMQ信息</h2><h3 id="3-2-1-简单配置"><a href="#3-2-1-简单配置" class="headerlink" title="3.2.1 简单配置"></a>3.2.1 简单配置</h3><p>在生产者和消费者的application.yml文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.92.129 # 你的虚拟机IP</span><br><span class="line">    port: 5672 # 端口</span><br><span class="line">    virtual-host: &#x2F;hmall2 # 虚拟主机</span><br><span class="line">    username: hmall # 用户名</span><br><span class="line">    password: 123456 # 密码</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;消费者和生产者会在对应位置添加配置 【例如：生产者消费者的确认机制，重试机制等】</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-nacos统一配置管理"><a href="#3-2-2-nacos统一配置管理" class="headerlink" title="3.2.2 nacos统一配置管理"></a>3.2.2 nacos统一配置管理</h3><ul>
<li>将rabbitmq配置放在nacos平台：【如果使用统一配置管理，记得导入对应nacos统一配置的config依赖和读取bootstrap.yml文件依赖】</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406230027202.png" alt="image-20240623002711143"></p>
<ul>
<li>bootstrap.yml添加读取nacos配置</li>
</ul>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406222242743.png" alt="image-20240622224211688" style="zoom:50%;">

<h2 id="3-3-支付服务–发送消息"><a href="#3-3-支付服务–发送消息" class="headerlink" title="3.3 支付服务–发送消息"></a>3.3 支付服务–发送消息</h2><h3 id="3-3-1-修改原来业务"><a href="#3-3-1-修改原来业务" class="headerlink" title="3.3.1 修改原来业务"></a>3.3.1 修改原来业务</h3><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406222302954.png" alt="image-20240622230216876"></p>
<h3 id="3-3-2-配置Jackson消息转换器"><a href="#3-3-2-配置Jackson消息转换器" class="headerlink" title="3.3.2 配置Jackson消息转换器"></a>3.3.2 配置Jackson消息转换器</h3><ul>
<li>导入依赖：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406222322731.png" alt="image-20240622232241693"></p>
<ul>
<li>直接配置到hm-common微服务下：</li>
</ul>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406222316090.png" alt="image-20240622231633000" style="zoom:67%;">

<ul>
<li>因为要考虑trade-service和pay-service调用时候springboot扫描问题：</li>
</ul>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406222320694.png" alt="image-20240622232005648" style="zoom: 67%;">

<ul>
<li>然后在生产者和消费者启动类添加bean注入：</li>
</ul>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406231250160.png" alt="image-20240623124959823" style="zoom:67%;">

<h2 id="3-4-交易服务–接受消息"><a href="#3-4-交易服务–接受消息" class="headerlink" title="3.4 交易服务–接受消息"></a>3.4 交易服务–接受消息</h2><p>在trade-service服务中定义一个消息监听类，方法外用注解标注队列，交换机和路由key，方法内写之前调用的方法：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406222334214.png" alt="image-20240622233402122"></p>
<h2 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h2><h3 id="3-5-1-重启两个服务"><a href="#3-5-1-重启两个服务" class="headerlink" title="3.5.1 重启两个服务"></a>3.5.1 重启两个服务</h3><p>可以通过hmall用户的hmall虚拟主机看到队列：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406230037080.png" alt="image-20240623003731861" style="zoom: 50%;">

<p>可以通过hmall用户的hmall虚拟主机看到交换机：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406230038295.png" alt="image-20240623003857226"></p>
<h3 id="3-5-2-前端下单"><a href="#3-5-2-前端下单" class="headerlink" title="3.5.2 前端下单"></a>3.5.2 前端下单</h3><p>前端下单然后支付成功之后，查看数据库信息变化了，并且有一条消息进入到mq之中。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406230042563.png" alt="image-20240623004203477"></p>
<h1 id="4-更改清除购物车需求"><a href="#4-更改清除购物车需求" class="headerlink" title="4.更改清除购物车需求"></a>4.更改清除购物车需求</h1><p>==这个需求参考3步骤做的，以下只介绍生产者和消费者部分代码修改==</p>
<h2 id="4-1-订单服务–发送消息"><a href="#4-1-订单服务–发送消息" class="headerlink" title="4.1 订单服务–发送消息"></a>4.1 订单服务–发送消息</h2><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406231355009.png" alt="image-20240623135513712"></p>
<h2 id="4-2-购物车服务–接收消息"><a href="#4-2-购物车服务–接收消息" class="headerlink" title="4.2 购物车服务–接收消息"></a>4.2 购物车服务–接收消息</h2><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406231355460.png" alt="image-20240623135542378"></p>
<h1 id="5-改造代码总结"><a href="#5-改造代码总结" class="headerlink" title="5.改造代码总结"></a>5.改造代码总结</h1><p>原来的设计：我在方法位置直接调用tradeClient的方法<br>现在的设计：①生产者只需要传递原来的参数和声明交换机名和key路由；②消费者需要声明交换机名，key路由和队列名，在方法里面直接调用底层方法(serviceimpl层方法)，就不用像openFeign方式。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406231257241.png" alt="image-20240623125707127"></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Jmeter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/06/20/Jmeter/" class="article-date">
      <time datetime="2024-06-20T05:36:09.000Z" itemprop="datePublished">2024-06-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/06/20/Jmeter/">Jmeter</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1-安装Jmeter"><a href="#1-安装Jmeter" class="headerlink" title="1.安装Jmeter"></a>1.安装Jmeter</h1><p>Jmeter依赖于JDK，所以必须确保当前计算机上已经安装了JDK，并且配置了环境变量。</p>
<h2 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1.下载"></a>1.1.下载</h2><p>可以Apache Jmeter官网下载，地址：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201337282.png" alt="image-20240620133703234" style="zoom:67%;">

<h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>因为下载的是zip包，解压缩即可使用，目录结构如下：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201337683.png" alt="image-20240620133725523" style="zoom:67%;">

<p>其中的bin目录就是执行的脚本，其中包含启动脚本：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201338495.png" alt="image-20240620133802462"></p>
<h3 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3.运行"></a>1.3.运行</h3><p>双击即可运行，但是有两点注意：</p>
<ul>
<li>启动速度比较慢，要耐心等待</li>
<li>启动后黑窗口不能关闭，否则Jmeter也跟着关闭了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201338318.png" alt="image-20240620133825276"></p>
<h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-设置中文语言"><a href="#2-1-设置中文语言" class="headerlink" title="2.1.设置中文语言"></a>2.1.设置中文语言</h2><p>默认Jmeter的语言是英文，需要设置：</p>
<ul>
<li>==设置本地运行中文==</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201338568.png" alt="image-20240620133838529"></p>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201338496.png" alt="image-20240620133844456"></p>
<blockquote>
<p><strong>注意</strong>：上面的配置只能保证本次运行是中文，如果要永久中文，需要修改Jmeter的配置文件</p>
</blockquote>
<ul>
<li>==设置永久中文==</li>
</ul>
<p>打开jmeter文件夹，在bin目录中找到 <strong>jmeter.properties</strong>，添加下面配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language</span>=<span class="string">zh_CN</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201338792.png" alt="image-20240620133857758"></p>
<blockquote>
<p>注意：前面不要出现#，#代表注释，另外这里是下划线，不是中划线</p>
</blockquote>
<h2 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2.基本用法"></a>2.2.基本用法</h2><p>在测试计划上点鼠标右键，选择添加 &gt; 线程（用户） &gt; 线程组：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201340160.png" alt="image-20240620134023118"></p>
<p>在新增的线程组中，填写线程信息：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201340827.png" alt="image-20240620134032791"></p>
<p>给线程组点鼠标右键，添加http取样器：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201340416.png" alt="image-20240620134051379"></p>
<p>编写取样器内容：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201340926.png" alt="image-20240620134057894"></p>
<p>添加监听报告：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201341755.png" alt="image-20240620134103715" style="zoom: 67%;">

<p>添加监听结果树：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201341007.png" alt="image-20240620134118963" style="zoom: 67%;">

<p>汇总报告结果：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201341069.png" alt="image-20240620134130039"></p>
<p>结果树：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406201341623.png" alt="image-20240620134154569" style="zoom:80%;">


      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jmeter/" rel="tag">Jmeter</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-微服务-黑马商城为例" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E9%BB%91%E9%A9%AC%E5%95%86%E5%9F%8E%E4%B8%BA%E4%BE%8B/" class="article-date">
      <time datetime="2024-05-28T06:23:36.000Z" itemprop="datePublished">2024-05-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/05/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E9%BB%91%E9%A9%AC%E5%95%86%E5%9F%8E%E4%B8%BA%E4%BE%8B/">微服务-黑马商城为例</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>前提：我们以单体架构的黑马商城为例</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281424756.png" alt="image-20240528142451641" style="zoom: 50%;">

<p>代码结构如下：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281426453.png" alt="image-20240528142611395" style="zoom:67%;">

<h1 id="服务拆分–各个模块各司其职"><a href="#服务拆分–各个模块各司其职" class="headerlink" title="==服务拆分–各个模块各司其职=="></a>==服务拆分–各个模块各司其职==</h1><h1 id="1-微服务拆分"><a href="#1-微服务拆分" class="headerlink" title="1.微服务拆分"></a>1.微服务拆分</h1><p>拆分工程结构有两种：</p>
<ul>
<li>1.独立project：总黑马商城设置一个空项目(各个模块都在这个目录下) –不怎么美观和使用</li>
<li>2.Maven聚合：总黑马商城设置一个空项目(各个模块成为一个module模块，根据maven管理) –只是代码放一起但是各自可以打包开发编译</li>
</ul>
<p><strong>我们以第二种Maven聚合方式进行拆分</strong></p>
<h2 id="1-1-新建项目"><a href="#1-1-新建项目" class="headerlink" title="1.1 新建项目"></a>1.1 新建项目</h2><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281656699.png" alt="image-20240528165608489"></p>
<h2 id="1-2-导入依赖"><a href="#1-2-导入依赖" class="headerlink" title="1.2 导入依赖"></a>1.2 导入依赖</h2><p>直接从hm-service中导入，然后删除一些不需要的依赖</p>
<h2 id="1-3-编写启动类"><a href="#1-3-编写启动类" class="headerlink" title="1.3 编写启动类"></a>1.3 编写启动类</h2><p><strong>一定记得和其他包是同一级，不然他妈的扫描不到报bean冲突！！！！！</strong></p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281657536.png" alt="image-20240528165703436"></p>
<h2 id="1-4-编写yml配置文件"><a href="#1-4-编写yml配置文件" class="headerlink" title="1.4 编写yml配置文件"></a>1.4 编写yml配置文件</h2><p>直接从hm-service中导入，然后删除和修改一些配置</p>
<h2 id="1-5-挪动代码"><a href="#1-5-挪动代码" class="headerlink" title="1.5 挪动代码"></a>1.5 挪动代码</h2><p>挪动步骤：</p>
<p>①domain实体，</p>
<p>②mapper数据库打交道的，</p>
<p>③service和serviceimpl，</p>
<p>④controller</p>
<p>==在这一步拆分多个子项目之后，我们可能会发现cart购物车服务会调用查询item商品服务，之前我们可以在一个模块中直接调用mapper，但是分开之后只能发送请求访问==</p>
<h1 id="2-远程调用-RestTemplate"><a href="#2-远程调用-RestTemplate" class="headerlink" title="2.远程调用-RestTemplate"></a>2.远程调用-RestTemplate</h1><p>之前通过调用item的mapper层方法即可，现在需要通过RestTemplate发送http请求给item服务获取数据。【但是有个致命问题是，exchange方法的url是写死的就很麻烦】</p>
<p>使用方法：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405291107820.png" alt="image-20240529110754747"></p>
<p>具体操作：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405291104162.png" alt="image-20240529110418958"></p>
<h1 id="服务治理–更高效管理调用者和被调用者"><a href="#服务治理–更高效管理调用者和被调用者" class="headerlink" title="==服务治理–更高效管理调用者和被调用者=="></a>==服务治理–更高效管理调用者和被调用者==</h1><h1 id="1-注册中心-增加调用中间商"><a href="#1-注册中心-增加调用中间商" class="headerlink" title="1.注册中心(增加调用中间商)"></a>1.注册中心(增加调用中间商)</h1><p>为了解决RestTemplate发送http请求时会写死url问题【如果被调用服务有多台负载均衡，就会报错更改也很麻烦】。==其实注册中心就相当于docker中的数据卷一样，我们可以当做中间商然后把调用者(服务调用者)和被调用者(服务注册者)联系起来。==</p>
<h2 id="1-1-注册中心原理"><a href="#1-1-注册中心原理" class="headerlink" title="1.1 注册中心原理"></a>1.1 注册中心原理</h2><p>流程如下：</p>
<ul>
<li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心   –<strong>让注册中心知道我可以被调用</strong></li>
<li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署） –<strong>让调用者知道有哪些可以调用</strong></li>
<li>调用者自己对实例列表负载均衡，挑选一个实例  –<strong>让调用者选一个被调用者</strong></li>
<li>调用者向该实例发起远程调用 –<strong>远程调用</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405291714600.png" alt="image-20240529171431457"></p>
<ul>
<li>服务治理中的三个角色分别是什么？</li>
</ul>
<p>​        服务提供者：暴露服务接口，供其它服务调用</p>
<p>​        服务消费者：调用其它服务提供的接口</p>
<p>​        注册中心：记录并监控微服务各实例状态，推送服务变更信息</p>
<ul>
<li>消费者如何知道提供者的地址？</li>
</ul>
<p>​        服务提供者会在启动时注册自己信息到注册中心，消费者可以从注册中心订阅和拉取服务信息</p>
<ul>
<li>消费者如何得知服务状态变更？</li>
</ul>
<p>​        服务提供者通过心跳机制向注册中心报告自己的健康状态，当心跳异常时注册中心会将异常服务剔除，并通知订阅了该服务的消费者</p>
<ul>
<li>当提供者有多个实例时，消费者该选择哪一个？</li>
</ul>
<p>​        消费者可以通过负载均衡算法，从多个实例中选择一个【==以前SpringMVC默认是Ribbon负载均衡，后来默认是loadbalancer负载均衡==】</p>
<h2 id="1-2注册中心方式"><a href="#1-2注册中心方式" class="headerlink" title="1.2注册中心方式"></a>1.2注册中心方式</h2><h3 id="1-1-1-Eureka-之前使用"><a href="#1-1-1-Eureka-之前使用" class="headerlink" title="1.1.1 Eureka(之前使用)"></a>1.1.1 Eureka(之前使用)</h3><p>具体使用可以去SpringCloud篇笔记查找。</p>
<h3 id="1-1-2-Nacos-目前使用"><a href="#1-1-2-Nacos-目前使用" class="headerlink" title="1.1.2 Nacos(目前使用)"></a>1.1.2 Nacos(目前使用)</h3><h4 id="1-角色1-注册中心"><a href="#1-角色1-注册中心" class="headerlink" title="1.角色1-注册中心"></a>1.角色1-注册中心</h4><ul>
<li><p>1.准备配置文件和tar包</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405311725981.png" alt="image-20240531172545922" style="zoom: 80%;">
</li>
<li><p>2.linux服务器docker容器启动</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405300953686.png" alt="image-20240530095352569"></p>
</li>
<li><p>3.可以在windows系统下访问</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405300955865.png" alt="image-20240530095505769"></p>
<h4 id="2-角色2-服务注册"><a href="#2-角色2-服务注册" class="headerlink" title="2.角色2-服务注册"></a>2.角色2-服务注册</h4><p>主要用于对服务提供者进行信息注册，注册到nacos中。</p>
<ul>
<li>1.在pom.xml中导入依赖和在application.yml文件中配置nacos地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405300951547.png" alt="image-20240530095103394"></p>
<ul>
<li>2.我们添加完成之后可以刷新nacos地址，就可以在网页中看到</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405300956689.png" alt="image-20240530095604593"></p>
<h4 id="3-角色3-服务发现"><a href="#3-角色3-服务发现" class="headerlink" title="3.角色3-服务发现"></a>3.角色3-服务发现</h4><ul>
<li><p>1.在pom.xml中导入依赖和在application.yml文件中配置nacos地址</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406011612724.png" alt="image-20240601161204592"></p>
<p>【<strong>Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</strong>】</p>
</li>
</ul>
<ul>
<li>2.我们添加完成之后可以刷新nacos地址，就可以在网页中看到</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405311731643.png" alt="image-20240531173131580"></p>
<ul>
<li>3.进行远程调用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405311731800.png" alt></p>
<h1 id="服务调用–更高效发送http请求"><a href="#服务调用–更高效发送http请求" class="headerlink" title="==服务调用–更高效发送http请求=="></a>==服务调用–更高效发送http请求==</h1><h1 id="1-OpenFeign-优化发送http请求"><a href="#1-OpenFeign-优化发送http请求" class="headerlink" title="1.OpenFeign(优化发送http请求)"></a>1.OpenFeign(优化发送http请求)</h1><p>之前使用的RestTemplate发起远程调用的代码：</p>
  <img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202404232026757.png" alt="image-20240423202621703" style="zoom:150%;">

<p>存在下面的问题：</p>
<p>•代码可读性差，编程体验不统一</p>
<p>•参数复杂URL难以维护</p>
<p>==Feign==是一个声明式的http客户端。其作用是帮助我们优雅地实现http请求发送，解决了上述的问题</p>
<h2 id="1-1-使用步骤"><a href="#1-1-使用步骤" class="headerlink" title="1.1 使用步骤"></a>1.1 使用步骤</h2><ul>
<li>1.导入依赖</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406011646223.png" alt="image-20240601164647179"></p>
<ul>
<li>2.服务发现方启动类添加注解</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406011646990.png" alt="image-20240601164613950"></p>
<ul>
<li>3.服务发现方编写接口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406011655989.png" alt="image-20240601165533941"></p>
<p>这里只需要声明接口，无需实现方法[<strong>OpenFeign动态代理实现</strong>]。接口中的几个关键信息：</p>
<ul>
<li><code>@FeignClient(&quot;item-service&quot;)</code> ：声明服务名称</li>
<li><code>@GetMapping</code> ：声明请求方式</li>
<li><code>@GetMapping(&quot;/items&quot;)</code> ：声明请求路径</li>
<li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li>
<li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li>
</ul>
<p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code>。我们只需要直接调用这个方法，即可实现远程调用了。</p>
<ul>
<li>4.服务发现方直接远程调用<br><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406011651403.png" alt="image-20240601165127358"></li>
</ul>
<p>总而言之，OpenFeign替我们完成了服务拉取、负载均衡、发送http请求的所有工作</p>
<h2 id="1-2-连接池"><a href="#1-2-连接池" class="headerlink" title="1.2 连接池"></a>1.2 连接池</h2><p>==Feign底层发起http请求，依赖于其它的框架==。其底层客户端实现包括：</p>
<ul>
<li><p>URLConnection：[默认]不支持连接池</p>
</li>
<li><p>Apache HttpClient ：支持连接池</p>
</li>
<li><p>OKHttp：支持连接池</p>
</li>
</ul>
<p>以HttpClient为例:</p>
<p>①pom.xml文件引入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--httpClient的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>②yml配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  httpclient:</span><br><span class="line">    enabled: true # 开启feign对HttpClient的支持</span><br><span class="line">    #线程池的核心值需要压测和实际情况调整！！！！！！！！！！！1</span><br><span class="line">    max-connections: 200 # 最大的连接数</span><br><span class="line">    max-connections-per-route: 50 # 每个路径的最大连接数</span><br></pre></td></tr></table></figure>



<h2 id="1-3-最佳实践方案"><a href="#1-3-最佳实践方案" class="headerlink" title="1.3 最佳实践方案"></a>1.3 最佳实践方案</h2><p>我们在2.1的使用步骤其实只是模拟了一种调用，但可能多个模块之间互相调用这种方式就有很大弊端。</p>
<p>因此可以提出继承方式和抽取方式：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406012050559.png" alt="image-20240601205026514"></p>
<p>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p>
<p>方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p>
<h3 id="1-3-1-两种抽取方式"><a href="#1-3-1-两种抽取方式" class="headerlink" title="1.3.1 两种抽取方式"></a>1.3.1 两种抽取方式</h3><h4 id="1-继承方式"><a href="#1-继承方式" class="headerlink" title="1.继承方式"></a>1.继承方式</h4><p>就是将所有用得到的dto，po，vo啥的都放到一个微服务里面。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406012048451.png" alt="image-20240601204832364"></p>
<h4 id="2-抽取方式"><a href="#2-抽取方式" class="headerlink" title="2.抽取方式"></a>2.抽取方式</h4><p>每个微服务存放自己需要的dto，po，vo啥的。只有需要的放到对应微服务。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406012048695.png" alt="image-20240601204850644"></p>
<h3 id="1-3-2-抽取Feign客户端"><a href="#1-3-2-抽取Feign客户端" class="headerlink" title="1.3.2 抽取Feign客户端"></a>1.3.2 抽取Feign客户端</h3><p>就是将cart-service关于调用的代码和vo，dto等挪到hm-api公共模块内。</p>
<h3 id="1-3-3-扫描包"><a href="#1-3-3-扫描包" class="headerlink" title="1.3.3 扫描包"></a>1.3.3 扫描包</h3><p>一般情况下，如果调用feign和注册feign不在一个微服务内，那就可能出现扫描包扫描不到报错。就需要进行设置扫描包：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406012043897.png" alt="image-20240601204312798"></p>
<h2 id="1-4-日志管理"><a href="#1-4-日志管理" class="headerlink" title="1.4 日志管理"></a>1.4 日志管理</h2><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时，才会输出日志。而且其日志级别有4级：</p>
<ul>
<li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li>
<li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<p>Feign默认的日志级别就是NONE，所以默认我们看不到请求日志。</p>
<h3 id="1-4-1-配置文件yml方式"><a href="#1-4-1-配置文件yml方式" class="headerlink" title="1.4.1 配置文件yml方式"></a>1.4.1 配置文件yml方式</h3><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202404232253759.png" alt="image-20240423213829442"></p>
<h3 id="1-4-2-Java代码方式"><a href="#1-4-2-Java代码方式" class="headerlink" title="1.4.2 Java代码方式"></a>1.4.2 Java代码方式</h3><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202404232147785.png" alt="image-20240423214701673"></p>
<p>提出一些问题：</p>
<p>我们将黑马商城拆分为5个微服务：</p>
<ul>
<li>用户服务</li>
<li>商品服务</li>
<li>购物车服务</li>
<li>交易服务</li>
<li>支付服务 </li>
</ul>
<p>由于每个微服务都有不同的地址或端口，入口不同，在与前端联调的时候发现了一些问题：</p>
<ul>
<li>请求不同数据时要访问不同的入口，需要维护多个入口地址，麻烦</li>
<li>前端无法调用nacos，无法实时更新服务列表</li>
</ul>
<p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题：</p>
<ul>
<li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li>
<li>当微服务之间调用时，该如何传递用户信息？</li>
</ul>
<p>通过==网关==技术解决上述问题。笔记分为3章：</p>
<ul>
<li>第一章：网关路由，解决前端请求入口的问题。</li>
<li>第二章：网关鉴权，解决统一登录校验和用户信息获取的问题。</li>
<li>第三章：统一配置管理，解决微服务的配置文件重复和配置热更新问题。</li>
</ul>
<h1 id="服务管理–帮助前端和后端联调，全局门卫"><a href="#服务管理–帮助前端和后端联调，全局门卫" class="headerlink" title="==服务管理–帮助前端和后端联调，全局门卫=="></a>==服务管理–帮助前端和后端联调，全局门卫==</h1><h1 id="1-网关路由"><a href="#1-网关路由" class="headerlink" title="1.网关路由"></a>1.网关路由</h1><h2 id="1-1-网关概述-门卫"><a href="#1-1-网关概述-门卫" class="headerlink" title="1.1 网关概述(门卫)"></a>1.1 网关概述(门卫)</h2><p>顾明思议，网关就是网络的==关口==。数据在网络间传输，当一个网络  –传输–&gt; 另一网络时,就需要经过网关来做数据的<strong>路由</strong>，<strong>转发</strong>，<strong>数据安全的校验</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406061723224.png" alt="image-20240606172320142"></p>
<p>现在，微服务网关就起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p>
<ul>
<li>网关可以做安全控制，也就是<strong>登录身份校验</strong>，校验通过才放行</li>
<li>通过认证后，网关再根据<strong>请求转发</strong>到想要访问的微服务</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406061726330.png" alt="image-20240606172632286"></p>
<p>在SpringCloud当中，提供了两种网关实现方案：</p>
<ul>
<li>Netflix Zuul：早期实现，目前已经淘汰</li>
<li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li>
</ul>
<h2 id="1-2-在项目中的地位"><a href="#1-2-在项目中的地位" class="headerlink" title="1.2 在项目中的地位"></a>1.2 在项目中的地位</h2><p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406041729806.png" alt="image-20240604172940613"></p>
<h2 id="1-3-快速入门"><a href="#1-3-快速入门" class="headerlink" title="1.3 快速入门"></a>1.3 快速入门</h2><h3 id="1-3-1-创建项目"><a href="#1-3-1-创建项目" class="headerlink" title="1.3.1 创建项目"></a>1.3.1 创建项目</h3><p>创建一个微服务hm-gateway项目：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406061734174.png" alt="image-20240606173445134" style="zoom:80%;">

<h3 id="1-3-2-引入依赖"><a href="#1-3-2-引入依赖" class="headerlink" title="1.3.2 引入依赖"></a>1.3.2 引入依赖</h3><p>pom.xml文件引入依赖：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406061734057.png" alt="image-20240606173435981"></p>
<h3 id="1-3-3-启动类"><a href="#1-3-3-启动类" class="headerlink" title="1.3.3 启动类"></a>1.3.3 启动类</h3><p>创建启动类【一定要注意启动类位置和其他包在同一级，不然启动类扫描注解就报错】：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181104984.png" alt="image-20240618110428918"></p>
<h3 id="1-3-4-配置路由"><a href="#1-3-4-配置路由" class="headerlink" title="1.3.4 配置路由"></a>1.3.4 配置路由</h3><p>==(目前最全，直接挪进去改改)==</p>
<p>接下来，在hm-gateway模块的resources目录新建一个application.yaml文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#端口信息</span><br><span class="line">server:</span><br><span class="line">  port: 8087</span><br><span class="line">#spring配置</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway #微服务名称(用于nacos微服务注册)</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: 192.168.92.129:8848  #微服务nacos地址</span><br><span class="line">    #路由过滤</span><br><span class="line">    gateway:</span><br><span class="line">      #1.路由过滤</span><br><span class="line">      routes:</span><br><span class="line">      	#第一个微服务</span><br><span class="line">        - id: item # 路由规则id，自定义，唯一</span><br><span class="line">          uri: lb:&#x2F;&#x2F;item-service # 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span><br><span class="line">          predicates: # 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span><br><span class="line">            - Path&#x3D;&#x2F;items&#x2F;**,&#x2F;search&#x2F;** # 这里是以请求路径作为判断规则</span><br><span class="line">        #第二个微服务    </span><br><span class="line">        - id: cart</span><br><span class="line">          uri: lb:&#x2F;&#x2F;cart-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;carts&#x2F;**</span><br><span class="line">        #第三个微服务</span><br><span class="line">        - id: user</span><br><span class="line">          uri: lb:&#x2F;&#x2F;user-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;users&#x2F;**,&#x2F;addresses&#x2F;**</span><br><span class="line">        #第四个微服务</span><br><span class="line">        - id: trade</span><br><span class="line">          uri: lb:&#x2F;&#x2F;trade-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;orders&#x2F;**</span><br><span class="line">        #第五个微服务</span><br><span class="line">        - id: pay</span><br><span class="line">          uri: lb:&#x2F;&#x2F;pay-service</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;pay-orders&#x2F;**</span><br><span class="line"></span><br><span class="line">      #2.默认过滤器</span><br><span class="line">      default-filters: # 默认过滤项</span><br><span class="line">        - AddRequestHeader&#x3D;Truth,Itcast is freaking awesome!</span><br><span class="line"></span><br><span class="line">      #3.跨域问题</span><br><span class="line">      globalcors:</span><br><span class="line">        add-to-simple-url-handler-mapping: true #解决options请求被拦截问题</span><br><span class="line">        cors-configurations:</span><br><span class="line">          &#39;[&#x2F;**]&#39;: #拦截一切请求</span><br><span class="line">            allowedOrigins: # 允许哪些网站的跨域请求</span><br><span class="line">              - &quot;http:&#x2F;&#x2F;localhost:8090&quot;</span><br><span class="line">            allowedMethods: # 允许的跨域ajax的请求方式</span><br><span class="line">              - &quot;GET&quot;</span><br><span class="line">              - &quot;POST&quot;</span><br><span class="line">              - &quot;DELETE&quot;</span><br><span class="line">              - &quot;PUT&quot;</span><br><span class="line">              - &quot;OPTIONS&quot;</span><br><span class="line">            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息</span><br><span class="line">            allowCredentials: true # 是否允许携带cookie</span><br><span class="line">            maxAge: 360000 # 这次跨域检测的有效期</span><br></pre></td></tr></table></figure>

<p>==配置文件概述：==</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406071113462.png" alt></p>
<p>其中，路由规则的定义语法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure>

<p>四个属性含义如下：</p>
<ul>
<li><code>id</code>：路由的唯一标示</li>
<li><code>predicates</code>：路由断言【判断是否符合条件】 –&gt;十一种，但是只用Path这一类</li>
<li><code>filters</code>：路由过滤条件【请求时添加信息】 –&gt;三大类过滤器(执行顺序：默认过滤器，路由过滤器，全局过滤器)</li>
<li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li>
</ul>
<p>其中yml配置中的routes可以查看源码(底层其实就是我们配置的6个属性，其中我们常用其中4个)：<br><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406071456129.png" alt="image-20240607145613009"></p>
<h3 id="1-3-5-测试"><a href="#1-3-5-测试" class="headerlink" title="1.3.5 测试"></a>1.3.5 测试</h3><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406071115423.png" alt="image-20240607111543349" style="zoom:67%;">



<h1 id="2-网关鉴权-登录校验"><a href="#2-网关鉴权-登录校验" class="headerlink" title="2.网关鉴权(+登录校验)"></a>2.网关鉴权(+登录校验)</h1><ul>
<li>单体架构，我们只需要完成一次用户登录，身份校验就可以在所有业务中获取到用户信息。</li>
<li>微服务架构，每个微服务都需要做用户登录校验就不太合理了</li>
</ul>
<h2 id="2-1-鉴权思路分析"><a href="#2-1-鉴权思路分析" class="headerlink" title="2.1 鉴权思路分析"></a>2.1 鉴权思路分析</h2><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p>
<ul>
<li>每个微服务都需要知道JWT的秘钥，×不安全</li>
<li>每个微服务重复编写登录校验代码、权限校验代码，×麻烦</li>
</ul>
<p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p>
<ul>
<li>只需要在网关和用户服务保存秘钥</li>
<li>只需要在网关开发登录校验功能</li>
</ul>
<p>【顺序：登录校验 –&gt; 请求转发到微服务】</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181119594.png" alt="image-20240618111909518"></p>
<p>因此，①JWT登录校验 —-&gt;② 网关请求转发(gateway内部代码实现)</p>
<h2 id="2-2-Gateway内部工作基本原理"><a href="#2-2-Gateway内部工作基本原理" class="headerlink" title="2.2 Gateway内部工作基本原理"></a>2.2 Gateway内部工作基本原理</h2><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406071512162.png" alt="image-20240607151254092"></p>
<p>如图所示：</p>
<ol>
<li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（<strong><code>Route</code></strong>），然后将请求交给<code>WebHandler</code>去处理。</li>
<li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（<strong><code>Filter chain</code></strong>），然后按照顺序逐一执行过滤器（后面称为<strong><code>Filter</code></strong>）。</li>
<li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li>
<li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li>
<li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li>
<li>最终把响应结果返回。</li>
</ol>
<p>==总结：==</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181340271.png" alt="image-20240618134038219"></p>
<p>如图所示，最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。</p>
<p><strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前</strong>，这就符合我们的需求。</p>
<h2 id="2-3-网关过滤链-三种过滤器"><a href="#2-3-网关过滤链-三种过滤器" class="headerlink" title="2.3 网关过滤链-三种过滤器"></a>2.3 网关过滤链-三种过滤器</h2><p>网关过滤器链中的过滤器有两种：</p>
<ul>
<li><strong><code>GatewayFilter</code></strong>：<strong>路由过滤器</strong>(gateway自带)，作用范围比较灵活，可以：【指定的路由<code>Route</code>】   –一般自定义的话比较麻烦【直接yml配置】</li>
<li><strong><code>GlobalFilter</code></strong>：<strong>全局过滤器</strong>，作用范围：【所有路由】，不可配置。 –一般使用这个好弄</li>
<li><strong><code>HttpHeadersFilter</code></strong>：<strong>处理传递到下游微服务的请求头</strong></li>
</ul>
<p>其实<code>GatewayFilter</code>和<code>GlobalFilter</code>这两种过滤器的方法签名完全一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理请求并将其传递给下一个过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exchange 当前请求的上下文，其中包含request、response等各种数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chain 过滤器链，基于它向下传递请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>;</span><br></pre></td></tr></table></figure>

<p>工作基本原理的第二步WebHandler：<code>FilteringWebHandler</code>请求处理器在处理请求时，会将<code>②GlobalFilter</code>装饰为<code>①GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行。</p>
<h2 id="2-4-自定义过滤器"><a href="#2-4-自定义过滤器" class="headerlink" title="2.4 自定义过滤器"></a>2.4 自定义过滤器</h2><h3 id="2-4-1-GatewayFilter"><a href="#2-4-1-GatewayFilter" class="headerlink" title="2.4.1 GatewayFilter"></a>2.4.1 GatewayFilter</h3><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code></p>
<h4 id="方式一-yml文件配置"><a href="#方式一-yml文件配置" class="headerlink" title="方式一-yml文件配置"></a>方式一-yml文件配置</h4><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。</p>
<p>使用只需要在application.yaml中这样配置：【配置到gateway-routes下面就表明属于一个route】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: test_route</span><br><span class="line">        uri: lb:&#x2F;&#x2F;test-service</span><br><span class="line">        predicates:</span><br><span class="line">          -Path&#x3D;&#x2F;test&#x2F;**</span><br><span class="line">        #过滤器  </span><br><span class="line">        filters:</span><br><span class="line">          - AddRequestHeader&#x3D;key, value # 逗号之前是请求头的key，逗号之后是value</span><br></pre></td></tr></table></figure>

<p>如果想作用于全部路由，则可以配置：【配置到gateway下面就表明不属于任何一个route，属于全部路由】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      #在这里配置只在部分route下有效</span><br><span class="line">      - id: test_route</span><br><span class="line">        uri: lb:&#x2F;&#x2F;test-service</span><br><span class="line">        predicates:</span><br><span class="line">          -Path&#x3D;&#x2F;test&#x2F;**</span><br><span class="line">          </span><br><span class="line">     #默认过滤器【全部路由】     </span><br><span class="line">     default-filters: # default-filters下的过滤器可以作用于所有路由</span><br><span class="line">        - AddRequestHeader&#x3D;key, value</span><br></pre></td></tr></table></figure>

<h4 id="方式二-自定义类"><a href="#方式二-自定义类" class="headerlink" title="方式二-自定义类"></a>方式二-自定义类</h4><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>。</p>
<ul>
<li><strong>第一种</strong>：参数yml配置+自定义过滤器</li>
</ul>
<p>【注意:该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！】</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181351674.png" alt="image-20240618135158605"></p>
<p>然后在yml配置中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      default-filters:</span><br><span class="line">            - PrintAny #直接写自定义GatewayFilterFactory类名称中前缀类声明过滤器</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第二种</strong>：自定义过滤器+动态配置参数【比较复杂不建议】</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406071535309.png" alt="image-20240607153516182"></p>
<p>然后在yml配置中使用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以","隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure>

<p>上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。</p>
<p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrintAny</span></span><br><span class="line">              <span class="attr">args:</span> <span class="comment"># 手动指定参数名，无需按照参数顺序</span></span><br><span class="line">                <span class="attr">a:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">b:</span> <span class="number">2</span></span><br><span class="line">                <span class="attr">c:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>第二种方法的总体图对比：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406071543417.png" alt="image-20240607154320369"></p>
<h3 id="2-4-2-GlobalFilter"><a href="#2-4-2-GlobalFilter" class="headerlink" title="2.4.2 GlobalFilter"></a>2.4.2 GlobalFilter</h3><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数[因为默认是全局路由]:</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406071538497.png" alt="image-20240607153823420"></p>
<h2 id="2-5-问题一-怎么进行登录校验"><a href="#2-5-问题一-怎么进行登录校验" class="headerlink" title="2.5 问题一-怎么进行登录校验"></a>2.5 问题一-怎么进行登录校验</h2><p>现在我们知道可以通过定义两种过滤器，定义到<code>NettyRoutingFilter</code>之前就行。</p>
<p>我们以自定义GlobalFilter来完成登录校验：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406102133789.png" alt="image-20240610213352568"></p>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.hmall.gateway.filter;</span><br><span class="line">import com.hmall.common.exception.UnauthorizedException;</span><br><span class="line">import com.hmall.gateway.config.AuthProperties;</span><br><span class="line">import com.hmall.gateway.util.JwtTool;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line">import org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line">import org.springframework.http.server.reactive.ServerHttpResponse;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.util.AntPathMatcher;</span><br><span class="line">import org.springframework.web.server.ServerWebExchange;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line">import java.util.List;</span><br><span class="line">@Component</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">@EnableConfigurationProperties(AuthProperties.class)</span><br><span class="line">public class AuthGlobalFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private final JwtTool jwtTool;</span><br><span class="line"></span><br><span class="line">    private final AuthProperties authProperties;</span><br><span class="line">	&#x2F;&#x2F;因为不需要拦截的路径有&#x2F;** 所以我们使用这种特殊matcher类进行匹配</span><br><span class="line">    private final AntPathMatcher antPathMatcher &#x3D; new AntPathMatcher();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1.获取Request</span><br><span class="line">        ServerHttpRequest request &#x3D; exchange.getRequest();</span><br><span class="line">        &#x2F;&#x2F; 2.判断是否不需要拦截</span><br><span class="line">        if(isExclude(request.getPath().toString()))&#123;  &#x2F;&#x2F;yml配置的不需要拦截的路径和request的路径进行判断</span><br><span class="line">            &#x2F;&#x2F; 无需拦截，直接放行</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 3.获取请求头中的token</span><br><span class="line">        String token &#x3D; null;</span><br><span class="line">        List&lt;String&gt; headers &#x3D; request.getHeaders().get(&quot;authorization&quot;);</span><br><span class="line">        if (headers!&#x3D;null &amp;&amp; !headers.isEmpty()) &#123;</span><br><span class="line">            token &#x3D; headers.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 4.校验并解析token</span><br><span class="line">        Long userId &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            userId &#x3D; jwtTool.parseToken(token);</span><br><span class="line">        &#125; catch (UnauthorizedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果无效，拦截</span><br><span class="line">            ServerHttpResponse response &#x3D; exchange.getResponse();</span><br><span class="line">            response.setRawStatusCode(401);</span><br><span class="line">            return response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; TODO 5.如果有效，传递用户信息</span><br><span class="line">        System.out.println(&quot;userId &#x3D; &quot; + userId);</span><br><span class="line">        &#x2F;&#x2F; 6.放行</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isExclude(String antPath) &#123;</span><br><span class="line">        for (String pathPattern : authProperties.getExcludePaths()) &#123;</span><br><span class="line">            if(antPathMatcher.match(pathPattern, antPath))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-6-问题二-网关怎么传递用户信息"><a href="#2-6-问题二-网关怎么传递用户信息" class="headerlink" title="2.6 问题二-网关怎么传递用户信息"></a>2.6 问题二-网关怎么传递用户信息</h2><p>截止到2.5，网关已经可以完成登录校验并获取登录用户身份信息。</p>
<p>但是当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此我们可以将用户信息以<strong>请求头</strong>的方式传递到下游微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用<strong>SpringMVC的拦截器</strong>来获取登录用户信息，并<strong>存入ThreadLocal</strong>，方便后续使用。</p>
<p>据图流程图如下：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406102139229.png" alt="image-20240610213950132"></p>
<h3 id="2-6-1-网关如何转发用户信息"><a href="#2-6-1-网关如何转发用户信息" class="headerlink" title="2.6.1 网关如何转发用户信息"></a>2.6.1 网关如何转发用户信息</h3><p>网关发送请求到微服务依然采用的是<code>Http</code>请求，因此我们可以将用户信息以<strong>请求头</strong>的方式传递到下游微服务。</p>
<p>具体操作：【在2.5校验器实现的登录校验里面将jwt解析出来的UserId以请求头方式传递】</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181521260.png" alt="image-20240618152159108" style="zoom:67%;">



<h3 id="2-6-2-下游微服务怎么获取用户信息"><a href="#2-6-2-下游微服务怎么获取用户信息" class="headerlink" title="2.6.2 下游微服务怎么获取用户信息"></a>2.6.2 下游微服务怎么获取用户信息</h3><p>微服务可以从请求头中获取登录用户信息。利用<strong>SpringMVC的拦截器</strong>来获取登录用户信息，并<strong>存入ThreadLocal</strong>，方便后续使用。</p>
<p>据图流程图如下：【==编写微服务拦截器，拦截请求获取用户信息，保存到ThreadLocal后放行==】</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181618019.png" alt="image-20240618161828959"></p>
<p>整体代码结构：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181629309.png" alt="image-20240618162921217" style="zoom:67%;">



<p><strong>具体操作：</strong></p>
<p>因为当前用户ID会在多个微服务中使用，所以我们可以在<strong>hm-common</strong>微服务中编写：</p>
<ul>
<li>1.根据SpringMvc拦截器创建规则创建自定义拦截器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181609940.png" alt="image-20240618160956852"></p>
<ul>
<li>2.创建MvcConfig添加自定义的拦截器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181611139.png" alt="image-20240618161119070"></p>
<ul>
<li>3.可以修改之前写死的位置业务逻辑，这样可以在通过Threadlocal获取信息</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181614885.png" alt></p>
<ul>
<li>4.需要注意的是：因为是写在hm-common微服务，这个配置类默认不会生效(和其他微服务的扫描包不一致，无法扫描到，因此无法生效)。基于<strong>SpringBoot自动装配原理</strong>，我们可以将其添加到resources目录下的META-INF/Spring.factories文件中：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181625369.png" alt></p>
<ul>
<li>5.如果我们需要保证其他微服务获取这个拦截器，而网关不获取(登录校验了，所以没必要获取啊)，就可以添加注解</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181627597.png" alt="image-20240618162712521"></p>
<h2 id="2-7-问题三-微服务之间怎么传递用户信息"><a href="#2-7-问题三-微服务之间怎么传递用户信息" class="headerlink" title="2.7 问题三-微服务之间怎么传递用户信息"></a>2.7 问题三-微服务之间怎么传递用户信息</h2><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p>
<p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。</p>
<p>比如<strong>下单业务</strong>，流程如下：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406181638193.png" alt="image-20240618163838037"></p>
<p>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁！</p>
<p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p>
<p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？–借助Feign中提供的一个拦截器接口：<strong>RequestInterceptor</strong></p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191425670.png" alt="image-20240619142520506"></p>
<p>我们只需要==实现这个接口，然后实现apply方法，利用RequestTemplate类来添加请求头，将用户信息保存到请求头中==。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p>
<p>具体实现：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191428852.png" alt="image-20240619142843772"></p>
<p>这样注入bean之后如果要使用，就要在Openfeign远程调用的启动类添加：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191430814.png" alt="image-20240619143047728"></p>
<h2 id="总结：网关解决传递信息的三大问题"><a href="#总结：网关解决传递信息的三大问题" class="headerlink" title="==总结：网关解决传递信息的三大问题=="></a>==总结：网关解决传递信息的三大问题==</h2><ul>
<li>1.<strong>怎么做到先校验?后转发(网关路由是配置的，请求转发是Gateway内部代码)</strong>  —在gateway内部工作基本原理的NettyRoutingFilter过滤器前面定义一个过滤器(①路由过滤器②全局过滤器)，过滤器中进行校验JWT信息，然后通过mutate方法转发用户信息。</li>
<li>2.<strong>怎么做到网关给用户传递用户信息</strong>  —网关到微服务通过API添加用户信息到http请求头，微服务通过SpringMVC拦截器获取用户信息，将用户信息存储到ThreadLocal中</li>
<li>3.<strong>怎么做到用户之间调用传递用户信息</strong>  —就是利用发送http请求(Openfeign)时通过提供的拦截器添加</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191439587.png" alt="image-20240619143917520"></p>
<p>[JWT里面传递UserId信息，网关添加过滤器进行校验token同时将UserId添加到请求头，通过mutate方法传递给微服务，微服务通过SpringMVC拦截器获取UserId信息，然后存储到ThreadLocal，业务就可以使用。如果微服务之间调用就通过OpenFeign发送http请求的时候添加拦截器保存UserId]</p>
<h1 id="配置管理–高效维护配置和动态变更属性"><a href="#配置管理–高效维护配置和动态变更属性" class="headerlink" title="==配置管理–高效维护配置和动态变更属性=="></a>==配置管理–高效维护配置和动态变更属性==</h1><p>1.微服务重复配置过多，维护成本高  —-&gt; 共享配置</p>
<p>2.业务配置经常变动，每次修改都要重启服务  —-&gt; 热更新</p>
<p>3.网关路由配置写死，如果变更就要重启网关 —-&gt; 热更新</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191455894.png" alt="image-20240619145505779"></p>
<p>这些问题都可以通过统一的<strong>配置管理器服务[Nacos第二大特性]</strong>解决 —–Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p>
<p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p>
<p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p>
<h1 id="1-配置共享"><a href="#1-配置共享" class="headerlink" title="1.配置共享"></a>1.配置共享</h1><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p>
<ul>
<li>①在Nacos中添加共享配置</li>
<li>②微服务拉取配置</li>
</ul>
<h2 id="1-1-添加共享配置"><a href="#1-1-添加共享配置" class="headerlink" title="1.1 添加共享配置"></a>1.1 添加共享配置</h2><p>在nacos控制台分别添加微服务共同配置：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191533467.png" alt="image-20240619153300369"></p>
<p>最终形成多个yaml文档：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191533456.png" alt="image-20240619153352401"></p>
<h2 id="1-2-拉取共享配置"><a href="#1-2-拉取共享配置" class="headerlink" title="1.2 拉取共享配置"></a>1.2 拉取共享配置</h2><p>将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。</p>
<p>不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取<code>application.yaml</code>。</p>
<p>也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos 地址，该如何去加载nacos中的配置文件呢？</p>
<p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了。</p>
<h3 id="1-2-1-文件读取顺序"><a href="#1-2-1-文件读取顺序" class="headerlink" title="1.2.1 文件读取顺序"></a>1.2.1 文件读取顺序</h3><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191540790.png" alt="image-20240619154015718" style="zoom:67%;">

<h3 id="1-2-2-拉取步骤"><a href="#1-2-2-拉取步骤" class="headerlink" title="1.2.2 拉取步骤"></a>1.2.2 拉取步骤</h3><ul>
<li>1.导入依赖：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--nacos配置管理--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--读取bootstrap文件--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191541489.png" alt="image-20240619154146436"></p>
<ul>
<li>2.编写bootstrap文件：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191543053.png" alt="image-20240619154311986"></p>
<h2 id="1-3-多配置文件读取顺序"><a href="#1-3-多配置文件读取顺序" class="headerlink" title="1.3 多配置文件读取顺序"></a>1.3 多配置文件读取顺序</h2><p>可能不同环境下有不同的yaml文件[像单体架构的时候properties，yml，yaml等情况]，因此当出现相同属性时就有优先级：==名字越长越牛逼==</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202404231735276.png" alt="image-20240423173524235"></p>
<h2 id="1-4-配置共享整理总结"><a href="#1-4-配置共享整理总结" class="headerlink" title="1.4 配置共享整理总结"></a>1.4 配置共享整理总结</h2><p>其实就是把原来的application.yml文件拆分成三个部分：①application公共配置；②Nacos地址和读取①文件配置；③application个性化配置</p>
<p>①nacos空间多个共享文件：原来application.yml中多个微服务可共享的信息</p>
<p>②新建bootstrap.yml文件：原来application.yml里面关于nacos的配置+添加config信息(读取nacos配置的多个共同部分yml文件)；</p>
<p>③application.yml：保留一部分自己特有的属性和①nacos里面${}需要的属性</p>
<h1 id="2-配置热更新-无需重启"><a href="#2-配置热更新-无需重启" class="headerlink" title="2.配置热更新(无需重启)"></a>2.配置热更新(无需重启)</h1><p>这就要用到Nacos的配置热更新能力了，分为两步：</p>
<ul>
<li>在Nacos中添加配置[配置属性]</li>
<li>在微服务读取配置[bootstrap.yml文件拉取配置，具体业务位置使用]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191607049.png" alt="image-20240619160718950"></p>
<h2 id="2-1-Nacos配置文件"><a href="#2-1-Nacos配置文件" class="headerlink" title="2.1 Nacos配置文件"></a>2.1 Nacos配置文件</h2><p>首先，我们在nacos中添加一个配置文件，将购物车的上限数量添加到配置中：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191609209.png" alt="image-20240619160940082"></p>
<p>注意文件的dataId格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[服务名]-[spring.active.profile].[后缀名]</span><br></pre></td></tr></table></figure>

<p>文件名称由三部分组成：</p>
<ul>
<li><strong><code>服务名</code></strong>：我们是购物车服务，所以是<code>cart-service</code></li>
<li><strong><code>spring.active.profile</code></strong>：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li>
<li><strong><code>后缀名</code></strong>：例如yaml</li>
</ul>
<h2 id="2-2-配置热更新"><a href="#2-2-配置热更新" class="headerlink" title="2.2 配置热更新"></a>2.2 配置热更新</h2><p>我们在微服务中读取配置，实现配置热更新。【一般我们使用第一种方式，第二种要用两个注解】</p>
<p>现在我们需要读取Nacos配置文件中的信息hm.cart.maxAmount属性:</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191619117.png" alt="image-20240619161955080"></p>
<h3 id="2-2-1-方式一"><a href="#2-2-1-方式一" class="headerlink" title="2.2.1 方式一"></a>2.2.1 方式一</h3><p>在<code>cart-service</code>中新建一个属性读取类：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191611194.png" alt="image-20240619161154107"></p>
<p>接着，在业务中使用该属性加载类：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191612768.png" alt="image-20240619161245631"></p>
<h3 id="2-2-2-方式二"><a href="#2-2-2-方式二" class="headerlink" title="2.2.2 方式二"></a>2.2.2 方式二</h3><p>直接搭配@RefreshScope注解和@Value注解获取</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202406191619789.png" alt="image-20240619161914727"></p>
<h1 id="3-动态路由"><a href="#3-动态路由" class="headerlink" title="3.动态路由"></a>3.动态路由</h1><p>用到了在学</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Hexo博客报错github传输大文件GH001异常" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2024/05/28/Hexo%E5%8D%9A%E5%AE%A2%E6%8A%A5%E9%94%99github%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6GH001%E5%BC%82%E5%B8%B8/" class="article-date">
      <time datetime="2024-05-28T02:51:54.000Z" itemprop="datePublished">2024-05-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2024/05/28/Hexo%E5%8D%9A%E5%AE%A2%E6%8A%A5%E9%94%99github%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6GH001%E5%BC%82%E5%B8%B8/">Hexo博客报错github传输大文件GH001异常</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="1-报错原因"><a href="#1-报错原因" class="headerlink" title="1.报错原因"></a>1.报错原因</h1><p>我在Docker文件夹下上传了一个iso文件，这个文件大于了github的100M大小报错。</p>
<p>在我hexo g的时候没问题，但是hexo d的时候会出错。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281055923.png" alt="image-20240528105520819"></p>
<p>但是本地删除了iso文件还是不行，最后查询意思是之前的记录仍然存在，只能从本地仓库删除并且把以前的提交记录全部修改</p>
<h1 id="2-修改办法"><a href="#2-修改办法" class="headerlink" title="2.修改办法"></a>2.修改办法</h1><p>2.1 在此目录下打开git bash</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281057150.png" alt="image-20240528105706115"></p>
<p>2.2 输入指令 git log通过此处找到报错前最新的版本</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281059890.png" alt="image-20240528105915849"></p>
<p>2.2 还有一种办法就是通过github查看版本</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281101521.png" alt="image-20240528110139383"></p>
<p>2.3 至此直接git reset id 就可以恢复到对应版本</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202405281102890.png" alt="image-20240528110223842"></p>
<h1 id="3-参考办法"><a href="#3-参考办法" class="headerlink" title="3.参考办法"></a>3.参考办法</h1><p><a href="https://rimbaud-lee.github.io/2021/08/25/blog_deploy_2/" target="_blank" rel="noopener">记一次异常艰难的博客部署（二）—— hexo d 指令向GitHub传输大文件导致的 GH001 报错解决 | 邓小闲的小楼 (rimbaud-lee.github.io)</a></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo%E5%8D%9A%E5%AE%A2/" rel="tag">Hexo博客</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2024 Larkkkkkkk
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="http://bestwing.me" target="_blank">Sw'blog</a> by Swing
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


    <script type="text/javascript">
      window.onload = function(){
        document.getElementById("search").onclick = function(){
            console.log("search")
            search();
        }
      }
      function search(){
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','A1Pz-LKMXbrzcFg2FWi6','2.0.0');
      }
    </script>

  </div>
</body>
</html>