<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Larkkkkkkk</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Larkkkkkkk">
<meta property="og:url" content="https://larkkkkkkk.github.io/page/23/index.html">
<meta property="og:site_name" content="Larkkkkkkk">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Larkkkkkkk">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Larkkkkkkk" type="application/atom+xml">
  
  
    <link rel="icon" href="/http://oayoilchh.bkt.clouddn.com/2016/07/27/18:05:26%20">
  
  
      
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="img/head.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Larkkkkkkk</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="https://github.com/Larkkkkkkk" target="_blank" rel="noopener">博客首页</a></li>
                        
                            <li><a  href="/archives">文章归档</a></li>
                        
                            <li><a  href="/CTFStudy">学习导航</a></li>
                        
                            <li><a  href="/PWNABLE">PWNABLE</a></li>
                        
                            <li><a  href="/resume">个人简历</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail"  target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=U2JgZ2ZlY2VmamATIiJ9MDw_" title="mail">mail</a>
                            
                                <a class="fl github"  target="_blank" href="https://github.com/Larkkkkkkk" title="github">github</a>
                            
                                <a class="fl zhihu"  target="_blank" href="https://www.zhihu.com/people/plain-3-78/activities" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo"  target="_blank" href="https://weibo.com/5304208276/profile?topnav=1&wvr=6" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Ajax/" style="font-size: 12.22px;">Ajax</a> <a href="/tags/Cookie%E5%92%8CSession/" style="font-size: 14.44px;">Cookie和Session</a> <a href="/tags/DBUtils/" style="font-size: 11.11px;">DBUtils</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">EL表达式</a> <a href="/tags/Filter/" style="font-size: 11.11px;">Filter</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPServletReauest%E5%92%8CHTTPServletResponse/" style="font-size: 10px;">HTTPServletReauest和HTTPServletResponse</a> <a href="/tags/IDEA%E5%AE%89%E8%A3%85%E5%92%8C%E7%A0%B4%E8%A7%A3/" style="font-size: 10px;">IDEA安装和破解</a> <a href="/tags/JAVA/" style="font-size: 17.78px;">JAVA</a> <a href="/tags/JAVA-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">JAVA-Lambda表达式</a> <a href="/tags/JAVA-Set%E9%9B%86%E5%90%88/" style="font-size: 10px;">JAVA-Set集合</a> <a href="/tags/JAVA-%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">JAVA-反射</a> <a href="/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 12.22px;">JAVA-多线程</a> <a href="/tags/JAVA-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">JAVA-正则表达式</a> <a href="/tags/JAVA-%E6%B3%9B%E5%9E%8B/" style="font-size: 10px;">JAVA-泛型</a> <a href="/tags/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 12.22px;">JAVA-网络编程</a> <a href="/tags/JAVA-%E9%9B%86%E5%90%88/" style="font-size: 12.22px;">JAVA-集合</a> <a href="/tags/JAVA%E7%BB%83%E4%B9%A0/" style="font-size: 11.11px;">JAVA练习</a> <a href="/tags/JAVA%E7%BB%83%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">JAVA练习-动态规划</a> <a href="/tags/JQuery/" style="font-size: 13.33px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/LeetCode/" style="font-size: 17.78px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 15.56px;">Linux</a> <a href="/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/tags/Mybatis/" style="font-size: 18.89px;">Mybatis</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CJDBC/" style="font-size: 15.56px;">Mysql数据库和JDBC</a> <a href="/tags/Redis/" style="font-size: 11.11px;">Redis</a> <a href="/tags/Servlet/" style="font-size: 11.11px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 16.67px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/SpringMVC/" style="font-size: 15.56px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 20px;">Web前端知识点</a> <a href="/tags/XML/" style="font-size: 11.11px;">XML</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/flask%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">flask框架</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/jsp%E6%A0%87%E5%87%86%E6%A0%87%E7%AD%BE%E5%BA%93/" style="font-size: 10px;">jsp标准标签库</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/picture/" style="font-size: 10px;">picture</a> <a href="/tags/python/" style="font-size: 12.22px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/ssm%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BF/" style="font-size: 10px;">ssm框架模板</a> <a href="/tags/webserver%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">webserver编程</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BA%AC%E4%B8%9C/" style="font-size: 11.11px;">京东</a> <a href="/tags/%E5%90%8E%E7%BC%80%E6%A0%91/" style="font-size: 10px;">后缀树</a> <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 10px;">哈希表</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/" style="font-size: 10px;">复杂度分析</a> <a href="/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">学生管理系统</a> <a href="/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F2-0/" style="font-size: 12.22px;">学生管理系统2.0</a> <a href="/tags/%E6%8B%BC%E5%A4%9A%E5%A4%9A/" style="font-size: 10px;">拼多多</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 10px;">数据分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" style="font-size: 10px;">数据库连接池</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数据结构-稀疏数组</a> <a href="/tags/%E6%96%87%E5%AD%97%E7%AF%87-%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">文字篇-记录</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 12.22px;">机器学习</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 12.22px;">树</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">注解</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 14.44px;">深度学习</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 11.11px;">爬虫</a> <a href="/tags/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/" style="font-size: 10px;">生物信息学</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 12.22px;">知识图谱</a> <a href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%88%9D%E8%AF%95/" style="font-size: 12.22px;">研究生初试</a> <a href="/tags/%E7%A7%8B%E6%8B%9B/" style="font-size: 10px;">秋招</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法-动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/" style="font-size: 10px;">算法-回溯法</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法-贪心算法</a> <a href="/tags/%E8%80%83%E7%A0%94/" style="font-size: 10px;">考研</a> <a href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 13.33px;">蓝桥杯</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE-%E8%BD%AF%E4%BB%B6%E4%B8%93%E4%B8%9A%E9%A2%98%E7%9B%AE/" style="font-size: 10px;">计算机网络课设(软件专业题目)</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.22px;">设计模式</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" style="font-size: 10px;">软件体系结构</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 10px;">递归</a> <a href="/tags/%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">重新部署</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/tags/%E9%A1%B5%E9%9D%A2%EF%BC%88H5-CSS%EF%BC%89/" style="font-size: 10px;">页面（H5+CSS）</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0/" style="font-size: 10px;">项目上传</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://ring3.xyz/">Yllen</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://mxny.org/">麦香浓郁</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://whereisk0shl.top/">K0sh1</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.ycjcl.cc/">信鑫</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://bystudent.com/">ByStundet表哥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.jarviswang.me/">汪神_Jarvis</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sh3ll.me/">Chu</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.hackfun.org/">4ido10n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/iamstudy">L3m0n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://o0xmuhe.me/">muhe</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.nuptzj.cn/">_画船听雨</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.virzz.com/index.html">Virink</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.sqlsec.com/">国光</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bodkin.ren/">老锥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cizel.cn/">C1zel</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://1phan.cc">1phan</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.liuil.top/">liuil</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/Ox9A82/">Ox9A82</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://burnegg.com/">burnegg</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://jwrsec.cn/">jwr-sec</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sudalover.cn/">苏打</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.binklac.com">VeroFess</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bendawang.site/">bendawang</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://weeklyalgo.codes/">hook</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.flier.net.cn/">Flier&#39;blog</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mutepig.club">mutepig</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.iret.xyz/list.aspx">Silver</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://simp1e.leanote.com/">Simple</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://processor.pub/">Processor</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一只淹死在二进制海洋里的二进制狗!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Larkkkkkkk</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Larkkkkkkk</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="https://github.com/Larkkkkkkk" target="_blank" rel="noopener">博客首页</a></li>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="/CTFStudy">学习导航</a></li>
                
                    <li><a href="/PWNABLE">PWNABLE</a></li>
                
                    <li><a href="/resume">个人简历</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=U2JgZ2ZlY2VmamATIiJ9MDw_" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/Larkkkkkkk" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/plain-3-78/activities" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="https://weibo.com/5304208276/profile?topnav=1&wvr=6" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-蓝桥杯校赛" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/" class="article-date">
      <time datetime="2019-11-07T07:41:19.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/">蓝桥杯校赛</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、分核桃</strong></p>
<ul>
<li><strong>问题描述</strong><br>小张是软件项目经理，他带领3个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是：</li>
</ul>
<ol>
<li>各组的核桃数量必须相同</li>
<li>各组内必须能平分核桃（当然是不能打碎的）</li>
<li>尽量提供满足1,2条件的最小数量（节约闹革命嘛）</li>
</ol>
<p>输入格式<br>输入包含三个正整数a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c&lt;30）<br>输出格式<br>输出一个正整数，表示每袋核桃的数量。</p>
<p>样例输入1<br>2 4 5<br>样例输出1<br>20</p>
<p>样例输入2<br>3 1 1<br>样例输出2<br>3</p>
<ul>
<li><strong>问题分析：</strong><br>　　很明显是两个两个人求<strong>最小公倍数</strong>的问题。</li>
<li><strong>1.暴力法：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	int a&#x3D;input.nextInt();</span><br><span class="line">	int b&#x3D;input.nextInt();</span><br><span class="line">	int c&#x3D;input.nextInt();</span><br><span class="line">	</span><br><span class="line">	for(int i&#x3D;1;i&lt;1000;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(i%a&#x3D;&#x3D;0&amp;&amp;i%b&#x3D;&#x3D;0&amp;&amp;i%c&#x3D;&#x3D;0)  &#x2F;&#x2F;最小的值应该满足同时可以整除三个数字</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>2.最小公倍数法：</strong></li>
</ul>
<ol>
<li>求两个数的<strong>最大值</strong>。</li>
<li>从最大值开始循环找到<strong>第一个</strong>能够<strong>同时整除</strong>的数字。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	int a&#x3D;input.nextInt();</span><br><span class="line">	int b&#x3D;input.nextInt();</span><br><span class="line">	int c&#x3D;input.nextInt();&#x2F;&#x2F;输入三个数字</span><br><span class="line">	int flag&#x3D;0;&#x2F;&#x2F;定义变量存储合适的那个值</span><br><span class="line">	</span><br><span class="line">	int d&#x3D;zuida(a,b);&#x2F;&#x2F;求前两数的最大值</span><br><span class="line">	for(int i&#x3D;d;;i++)&#x2F;&#x2F;从前两数的最大值开始</span><br><span class="line">	&#123;</span><br><span class="line">		if(i%a&#x3D;&#x3D;0&amp;&amp;i%b&#x3D;&#x3D;0) &#x2F;&#x2F;只要能够整除</span><br><span class="line">		&#123;</span><br><span class="line">			flag&#x3D;i;&#x2F;&#x2F;flag存储当前符合的最小公倍数</span><br><span class="line">			break;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int e&#x3D;zuida(flag,c); &#x2F;&#x2F;求第二次的最大值</span><br><span class="line">	for(int i&#x3D;e;;i++) &#x2F;&#x2F;从最大值开始</span><br><span class="line">	&#123;</span><br><span class="line">		if(i%flag&#x3D;&#x3D;0&amp;&amp;i%c&#x3D;&#x3D;0)&#x2F;&#x2F;只要能够整除</span><br><span class="line">		&#123;</span><br><span class="line">			flag&#x3D;i;&#x2F;&#x2F;存储最终满足的值</span><br><span class="line">			break;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	System.out.println(flag); &#x2F;&#x2F;输出答案</span><br><span class="line">	</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	public static int zuida(int i,int j) &#123;  &#x2F;&#x2F;求两个数的最大值</span><br><span class="line">		return i&gt;j?i:j;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果：</strong></li>
</ul>
<p><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/fenhetao.png" alt></p>
<hr>
<p><strong>二、字符删除</strong></p>
<ul>
<li><strong>问题描述</strong><br>编写一个程序，先输入一个字符串str（长度不超过20），再输入单独的一个字符ch，然后程序会把字符串str当中出现的所有的ch字符都删掉，从而得到一个新的字符串str2，然后把这个字符串打印出来。　　</li>
</ul>
<p>输入格式：输入有两行，第一行是一个字符串（内部没有空格），第二行是一个字符。　　<br>输出格式：经过处理以后的字符串。</p>
<p>样例输入<br>123-45-678-<br>样例输出<br>12345678</p>
<ul>
<li><strong>问题分析：</strong><br>将字符串转为数组(<code>toCharArray()</code>)，然后依次循环和ch字符对比，不相等就输出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	String str&#x3D;input.nextLine();  &#x2F;&#x2F;输入一个字符串</span><br><span class="line">	char ch&#x3D;input.next().charAt(0);  &#x2F;&#x2F;输入一个字符</span><br><span class="line">	char[] a&#x3D;str.toCharArray(); &#x2F;&#x2F;字符串转数组</span><br><span class="line">	</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(a[i]!&#x3D;ch)</span><br><span class="line">			System.out.print(a[i]);  &#x2F;&#x2F;不相等就输出</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果：</strong></li>
</ul>
<p><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/zifushanchu.png" alt></p>
<hr>
<p><strong>三、区间K大数查询</strong></p>
<ul>
<li><strong>问题描述</strong><br>给定一个序列，每次询问序列中第l个数到第r个数中第K大的数是哪个。</li>
</ul>
<p>输入格式<br>　　第一行包含一个数n，表示序列长度。<br>　　第二行包含n个正整数，表示给定的序列。<br>　　第三个包含一个正整数m，表示询问个数。</p>
<p>　　接下来m行，每行三个数l,r,K，表示询问序列从左往右第l个数到第r个数中，从大往小第K大的数是哪个。序列元素从1开始标号。</p>
<p>输出格式<br>　　总共输出m行，每行一个数，表示询问的答案。<br>样例输入<br>5<br>1 2 3 4 5<br>2<br>1 5 2<br>2 3 2<br>样例输出<br>4<br>2<br>数据规模与约定<br>　　对于30%的数据，n,m&lt;=100；<br>　　对于100%的数据，n,m&lt;=1000；</p>
<ul>
<li><strong>问题分析：</strong><br>　　定义一个数组a先往里面放值，然后定义一个r-l+1长的数组b存放要截取的数组，然后定义一个<strong>ans数组</strong>存放每一次循环判断的最k大值(很关键)，然后输入l，r，k之后按顺序存放进数组b，一定要记得<strong>sort</strong>一下(不一定存放的数组就是顺序的！！！)，最后将最k大值放入ans数组！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">		int n &#x3D; in.nextInt();&#x2F;&#x2F;输入数组的长度</span><br><span class="line">		int[] a &#x3D; new int[n];&#x2F;&#x2F;定义一个n长度的数组a</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] &#x3D; in.nextInt(); &#x2F;&#x2F;一位一位输入内容</span><br><span class="line">		&#125;		</span><br><span class="line">		int m &#x3D; in.nextInt();&#x2F;&#x2F;定义找几次</span><br><span class="line">		int[] ans &#x3D; new int[m];&#x2F;&#x2F;按照m定义长度数组ans</span><br><span class="line">	 for(int i&#x3D;0;i&lt;m;i++)&#x2F;&#x2F;找几次就循环几次</span><br><span class="line">		&#123;</span><br><span class="line">			int l &#x3D; in.nextInt();&#x2F;&#x2F;输入要选的左边值</span><br><span class="line">			int r &#x3D; in.nextInt();&#x2F;&#x2F;输入要选的右边值</span><br><span class="line">			int k &#x3D; in.nextInt();&#x2F;&#x2F;输入要选的第k大值</span><br><span class="line">			int[] b &#x3D; new int[r-l+1];&#x2F;&#x2F;定义一个截取范围的数组b</span><br><span class="line">			for(int j&#x3D;0;j&lt;r-l+1;j++)&#x2F;&#x2F;从0到最大值赋值</span><br><span class="line">			&#123;</span><br><span class="line">				b[j]&#x3D;a[j+l-1];&#x2F;&#x2F;依次将对应的值放入b数组中</span><br><span class="line">			&#125;</span><br><span class="line">			Arrays.sort(b);&#x2F;&#x2F;一定要记得排序(输入的数字不一定按顺序排列)</span><br><span class="line">			ans[i]&#x3D;b[r-l+1-k];&#x2F;&#x2F;把那个最k大值放入ans数组值中</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(ans[i]);&#x2F;&#x2F;依次输出的就是找几次的对应的答案</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果：</strong></li>
</ul>
<p><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/chaoshi.png" alt></p>
<hr>
<p><strong>四、阶乘(第一个非0数)</strong></p>
<ul>
<li><strong>问题描述</strong><br>　　一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13!就已经比较大了，已经无法存放在一个整型变量中；而35!就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5! = 1<em>2</em>3<em>4</em>5 = 120，因此5!最右边的那个非0的数字是2。再如：7! = 5040，因此7!最右边的那个非0的数字是4。请编写一个程序，输入一个整数n(n&lt;=100)，然后输出n!<br>最右边的那个非0的数字是多少。<br>　　<br>　　输入格式：输入只有一个整数n。<br>　　输出格式：输出只有一个整数，即n! 最右边的那个非0的数字。输入输出样例</li>
</ul>
<p>样例输入<br>6<br>样例输出<br>2</p>
<p>由于只需要阶乘后的最后一个非０数，所以每次阶乘后，如果尾数是０的直接／１０。</p>
<ul>
<li><strong>问题分析：</strong></li>
</ul>
<ol>
<li>先编写一个递归方法求每一个数对应的阶乘。</li>
<li>将结果暂存在数组内，然后设置变量m来遍历直至第一个非0数就跳出判断。</li>
</ol>
<p><strong>解法一(30%)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	int n&#x3D;input.nextInt();</span><br><span class="line">	int[] a&#x3D;new int[1000];</span><br><span class="line">	a[0]&#x3D;jiecheng(n);</span><br><span class="line">	int m&#x3D;1;</span><br><span class="line">	for(int i&#x3D;0;;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m&#x3D;a[0]%10;</span><br><span class="line">		if(m!&#x3D;0)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(m);	</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		a[0]&#x3D;a[0]&#x2F;10;		</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	public static int jiecheng(int n) &#123;</span><br><span class="line">		if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;1)</span><br><span class="line">			return 1;</span><br><span class="line">		else </span><br><span class="line">			return n*jiecheng(n-1);		</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>问题分析：</strong></li>
</ul>
<ol>
<li>和解法一相似使用<strong>数组</strong>一个数字存放数组一个元素之中得到结果。</li>
<li>循环每次判断结果和考虑进位问题以此类推得到结果，最终还是循环判断非0数。</li>
</ol>
<p><strong>解法二(100%)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">		int n&#x3D;sc.nextInt();</span><br><span class="line">		int a[]&#x3D; new int[4000];</span><br><span class="line">		a[0]&#x3D;1;</span><br><span class="line">		int r1&#x3D;0;&#x2F;&#x2F;考虑进位情况</span><br><span class="line">		for(int i&#x3D;2;i&lt;&#x3D;n;i++) &#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;4000;j++) &#123;</span><br><span class="line">				r1&#x3D;a[j]*i+r1;</span><br><span class="line">				a[j]&#x3D;r1%10;  &#x2F;&#x2F;如果发生进位将个位赋给当前位置，十位或者和百位一起加到下一次数组乘法</span><br><span class="line">				r1&#x3D;r1&#x2F;10;   &#x2F;&#x2F;依次类推</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int s&#x3D;0;</span><br><span class="line">		for(int i&#x3D;3999;i&gt;&#x3D;0;i--) &#123;</span><br><span class="line">			if(a[i]!&#x3D;0) &#123;</span><br><span class="line">				System.out.print(a[i]);  &#x2F;&#x2F;从后往前倒排，然后判断首位不为空则输出</span><br><span class="line">				s&#x3D;i;   &#x2F;&#x2F;同时记录下标</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>问题分析：</strong></li>
</ul>
<ol>
<li>像解法一一样，如果用int型和递归方法会导致超时等问题，所以考虑使用<strong>BigDecimal类型</strong>存放结果。</li>
<li>考虑将结果用<strong>tosrtring方法</strong>转化为字符串，通过</li>
</ol>
<p><strong>charAt方法</strong>来循环判断是否为0找到最终结果。</p>
<p><strong>解法三(100%)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.math.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">		int n &#x3D; input.nextInt();</span><br><span class="line">		BigDecimal sum &#x3D; BigDecimal.ONE;&#x2F;&#x2F;使用BigDecimal类型存放答案</span><br><span class="line">		for(int i &#x3D; 1; i &lt;&#x3D; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			sum &#x3D; sum.multiply(BigDecimal.valueOf(i));&#x2F;&#x2F;使用乘法(不使用递归方法！)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	String S &#x3D; sum.toString(); &#x2F;&#x2F;将结果转化为字符串</span><br><span class="line">		for(int i &#x3D; S.length()-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			if(S.charAt(i) !&#x3D; &#39;0&#39;)&#x2F;&#x2F;遇到第一个非0的数字输出 </span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(S.charAt(i));</span><br><span class="line">  			      break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下:</strong></p>
<p><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/jiecheng.png" alt></p>
<hr>
<p><strong>五、最长子序列</strong></p>
<ul>
<li><p><strong>问题描述</strong><br>给定一个长为n的序列，求它的最长上升子序列的长度。<br>输入格式<br>　　输入第一行包含一个整数n。<br>　　第二行包含n个整数，为给定的序列。<br>输出格式<br>　　输出一个非负整数，表示最长上升子序列的长度。<br>样例输入<br>5<br>1 3 2 5 4<br>样例输出<br>3<br>数据规模和约定<br>　　0&lt;n&lt;=1000，每个数不超过10^6。</p>
</li>
<li><p><strong>问题分析：</strong><br>例如：数列(1, 7, 3, 5, 9, 4, 8)的有序上升子序列，像(1, 7)， (3, 4, 8)和许多其他的子序列。在所有的子序列中，最长的上升子序列的长度是4，如(1, 3, 5, 8)</p>
</li>
<li><p><strong>动态规划</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in); </span><br><span class="line">		int n &#x3D; input.nextInt();</span><br><span class="line">		int[] arr &#x3D; new int[10002];&#x2F;&#x2F;arr数组表示输入的序列</span><br><span class="line">		int[] dp &#x3D; new int[10002];&#x2F;&#x2F;dp数组中存放上升序列的长度，dp[i]表示以arr[i]结尾的子序列的最大长度</span><br><span class="line">		for(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#123;&#x2F;&#x2F;输入序列</span><br><span class="line">			arr[i]&#x3D; input.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		int result &#x3D; -1;&#x2F;&#x2F;记录dp中最大的值				</span><br><span class="line">		for(int i &#x3D; 1;i &lt;&#x3D; n;i++)</span><br><span class="line">		&#123;&#x2F;&#x2F;按顺序计算dp[i]的值			</span><br><span class="line">			dp[i] &#x3D; 1;&#x2F;&#x2F;假设该子序列中只有arr[i]，故长度为1，即其自身成为一个子序列			</span><br><span class="line">			for(int j &#x3D; 1;j &lt; i;j++) </span><br><span class="line">			&#123;&#x2F;&#x2F;如果在i之前有比arr[i]小的数(arr[j])，并且把该数(arr[i])放到以arr[j]结尾的子序列末尾后，&#x2F;&#x2F;其长度比当前以arr[i]结尾的子序列长度要长				</span><br><span class="line">				if(arr[i] &gt; arr[j] &amp;&amp; dp[j] + 1 &gt; dp[i]) </span><br><span class="line">				&#123;					</span><br><span class="line">					dp[i] &#x3D; dp[j] + 1;&#x2F;&#x2F;把arr[i]放到以arr[j]结尾的子序列之后，原来的长度＋1				</span><br><span class="line">				&#125;			</span><br><span class="line">			&#125;</span><br><span class="line">			result &#x3D; Math.max(result, dp[i]);&#x2F;&#x2F;找出在dp数组中最大的一个，即子序列长度最长的一个		</span><br><span class="line">		&#125;</span><br><span class="line">		 System.out.println(result);	</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/zuichangzixulie.png" alt></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" rel="tag">蓝桥杯</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-线程状态" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/" class="article-date">
      <time datetime="2019-11-07T07:11:21.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/">线程状态</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、线程状态</strong><br>在API中<code>java.lang.Thread.state</code>介绍了六种线程状态！</p>
<p><img src="/2019/11/07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/xianchengzhuangtaitu.png" alt></p>
<p>参考视频：<br><a href="https://www.bilibili.com/video/av62541169/?p=312" target="_blank" rel="noopener" title="多线程的网址">https://www.bilibili.com/video/av62541169/?p=312</a></p>
<ol>
<li>先<code>new Thread/Thread子类()；</code>—&gt;<strong>新建状态</strong></li>
<li>执行<code>start()方法</code><ul>
<li>抢到cpu—&gt;<strong>运行状态(Runnable)</strong>–<code>run()方法结束</code>/<code>stop()过时</code>就会到<strong>死亡状态(Terminated)</strong></li>
<li>没抢到cpu—&gt;<strong>阻塞状态(Blockerd)</strong></li>
</ul>
</li>
<li>执行<code>sleep(long)方法</code> / <code>wait(long)方法</code>—&gt;<strong>睡眠/休眠状态(Timed_waiting)</strong><ul>
<li>睡眠结束，cpu不空闲—&gt;<strong>阻塞状态</strong></li>
<li>睡眠结束，cpu空闲—&gt;<strong>运行状态</strong></li>
</ul>
</li>
<li>执行<code>Object.wait(无参数)</code>—&gt;<strong>无限/永久等待状态</strong></li>
<li>执行<code>Object.notify()</code>—&gt;只有这个方法才能唤醒。</li>
</ol>
<hr>
<p><strong>二、等待唤醒案例</strong></p>
<ul>
<li>等待唤醒案例：线程之间的通信<br>　　创建一个<strong>顾客线程(消费者)</strong>：告知老板需要包子的种类和数量，调用<strong>wait方法</strong>，放弃cpu的执行，进入到WAITING状态(无限等待)<br>　　创建一个<strong>老板线程(生产者)</strong>：花了s秒生产包子，包子做好，调用<strong>notify()方法</strong>，唤醒顾客吃包子。</li>
<li>注意点：</li>
</ul>
<ol>
<li>顾客和老板线程必须使用同步代码块包裹，而且保证只有一个在执行。(使用同步技术-synchronized(对象)形式)</li>
<li>同步使用的锁对象必须保证唯一。(只有一个obj对象)</li>
<li>只有锁对象才可以使用wait和notify方法。(代码中obj.wait()方法/obj.notify()方法)</li>
</ol>
<p><code>Object类</code>中的方法：</p>
<ol>
<li><code>void wait()</code>：<br> 在其他线程调用此对象的notify()方法/notifyAll()方法前，导致当前线程等待。</li>
<li><code>void notify()</code>：<br> 唤醒在此对象监控器上等待的单个线程<br> 会继续执行wait()方法之后的代码</li>
</ol>
<ul>
<li>具体实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package dengdaihuanxing;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建锁对象(唯一)</span><br><span class="line">		Object obj&#x3D;new Object();</span><br><span class="line">		&#x2F;&#x2F;创建一个顾客线程(消费者)---匿名内部类</span><br><span class="line">		new Thread()&#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;保证只有一个执行---同步技术</span><br><span class="line">				synchronized(obj) &#123;</span><br><span class="line">				System.out.println(&quot;告知老板要的包子的种类和数量：&quot;);</span><br><span class="line">				&#x2F;&#x2F;调用wait方法---进入无限等待状态</span><br><span class="line">				try</span><br><span class="line">				&#123;</span><br><span class="line">					obj.wait(); &#x2F;&#x2F;锁对象才可以调用wait方法</span><br><span class="line">				&#125; </span><br><span class="line">				catch (InterruptedException e) </span><br><span class="line">				&#123;			</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;唤醒之后执行的代码</span><br><span class="line">				System.out.println(&quot;包子已经做好了，可以吃了！&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建一个老板线程(生产者)</span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;花五秒钟做包子</span><br><span class="line">				try </span><br><span class="line">				&#123;</span><br><span class="line">					Thread.sleep(5000);</span><br><span class="line">				&#125; </span><br><span class="line">				catch (InterruptedException e)</span><br><span class="line">				&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#x2F;&#x2F;保证只有一个执行---同步技术</span><br><span class="line">			synchronized(obj) &#123;</span><br><span class="line">				System.out.println(&quot;老板5秒后做好包子,可以来吃包子了&quot;);</span><br><span class="line">				&#x2F;&#x2F;调用notify()方法唤醒吃包子</span><br><span class="line">				obj.notify();&#x2F;&#x2F;锁对象才可以调用notify方法</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">告知老板要的包子的种类和数量：</span><br><span class="line">(不用输入等待5秒后就会弹出下面的结果)</span><br><span class="line">老板5秒后做好包子,可以来吃包子了</span><br><span class="line">包子已经做好了，可以吃了！</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>三、Object类中wait带参方法和notify方法</strong></p>
<ul>
<li><strong>进入TimeWaiting(计时等待)</strong>有两种方式：</li>
</ul>
<ol>
<li>使用<code>sleep(long m)</code>，在毫秒值结束之后，线程–&gt;Runnable/Blocked状态。</li>
<li>使用<code>wait(long m)</code>：wait方法如果在毫秒值结束之后，还没有被notify方法唤醒，就会自动醒来。</li>
</ol>
<ul>
<li><strong>唤醒</strong>的方法</li>
</ul>
<ol>
<li><code>notify()</code>： —&gt;唤醒<strong>单个</strong>线程</li>
<li><code>notify()All</code>： —&gt;唤醒<strong>所有</strong>线程</li>
</ol>
<hr>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">JAVA-多线程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-线程安全" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/05/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" class="article-date">
      <time datetime="2019-11-05T13:01:27.000Z" itemprop="datePublished">2019-11-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/05/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、安全问题</strong><br>  假如一个电影院有一部电影100张票：</p>
<ol>
<li>只有一个窗口卖1-100的票(单线程)：不会出现线程问题。</li>
<li>有三个窗口卖不同范围的票(多线程)：不会出现线程问题，没有访问共享数据，不会产生问题。</li>
<li>有三个窗口卖的都是1-100的票(多线程)：会出现线程<strong>访问共享数据</strong>–&gt;<strong>线程安全问题</strong>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;子类！！！！！</span><br><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个多线程共享的票源：</span><br><span class="line">	private int ticket&#x3D;100;</span><br><span class="line">	&#x2F;&#x2F;设置线程任务:卖票</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	  while(true) </span><br><span class="line">	  &#123;</span><br><span class="line">		&#x2F;&#x2F;先判断票是否存在</span><br><span class="line">		if(ticket&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;提高安全问题出现的概率，让程序睡眠</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(10);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;票存在，卖票 ticket--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">		ticket--;</span><br><span class="line">		&#125;</span><br><span class="line">	  &#125;	</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试类！！！！！！！！！！！！！！！！！</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 模拟卖票案例</span><br><span class="line">	 创建3个线程，同时开始，对共享的票进行出售</span><br><span class="line">	 *&#x2F;</span><br><span class="line">public class ShiXian &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建Runnable接口的实现类对象		</span><br><span class="line">		RunnableImpl run&#x3D;new RunnableImpl();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;三个线程争夺CPU</span><br><span class="line">		Thread t0&#x3D;new Thread(run);&#x2F;&#x2F;抢夺到CPU的执行权-进入到run方法之后执行if语句就会睡眠，失去cpu的执行权</span><br><span class="line">		Thread t1&#x3D;new Thread(run);</span><br><span class="line">		Thread t2&#x3D;new Thread(run);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;调用start()方法开启多线程</span><br><span class="line">		t0.start();</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong><br>Thread-1–&gt;正在卖第100张票<br>Thread-2–&gt;正在卖第100张票<br>Thread-0–&gt;正在卖第100张票<br>…<br>Thread-1–&gt;正在卖第3张票<br>Thread-0–&gt;正在卖第3张票<br>Thread-2–&gt;正在卖第1张票<br>Thread-1–&gt;正在卖第0张票<br>Thread-0–&gt;正在卖第1张票<br>(出现了同时卖出去票的问题！！！！！！)</p>
<hr>
<p><strong>二、线程同步(解决方案)</strong></p>
<ol>
<li>同步代码块</li>
<li>同步方法</li>
<li>锁机制(Lock接口)</li>
</ol>
<ul>
<li><strong>同步代码块(<code>synchronized</code>)：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> synchronized(同步锁)&#123;</span><br><span class="line">	需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>锁对象可以是任意的对象</li>
<li>保证多个线程使用的是同一个锁对象</li>
<li>锁对象的作用：<br> 把同步代码块锁住：只让一个线程在同步代码块中执行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个多线程共享的票源：</span><br><span class="line">	private int ticket&#x3D;100;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;创建一个锁对象</span><br><span class="line">	Object obj&#x3D;new Object();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;设置线程任务:卖票</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	  while(true) </span><br><span class="line">	  &#123;</span><br><span class="line"></span><br><span class="line">		synchronized (obj)   &#x2F;&#x2F;synchronized(锁对象)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		&#x2F;&#x2F;还是原来的那些if语句和sleep语句</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	  &#125;	</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong><br>Thread-0–&gt;正在卖第100张票<br>Thread-2–&gt;正在卖第99张票<br>Thread-2–&gt;正在卖第98张票<br>…(省略)<br>Thread-2–&gt;正在卖第4张票<br>Thread-2–&gt;正在卖第3张票<br>Thread-2–&gt;正在卖第2张票<br>Thread-2–&gt;正在卖第1张票</p>
<hr>
<ul>
<li><strong>同步方法</strong> </li>
</ul>
<ol>
<li>访问了共享数据的代码–&gt;方法</li>
<li>方法上+synchronized修饰符</li>
</ol>
<p>格式：定义方法的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package duoxianchegn;</span><br><span class="line"></span><br><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个多线程共享的票源：</span><br><span class="line">	private int ticket&#x3D;100;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;设置线程任务:卖票</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	  while(true) </span><br><span class="line">	  &#123;</span><br><span class="line">		  payTicket();  &#x2F;&#x2F;调用这个方法!</span><br><span class="line">			</span><br><span class="line">	  &#125;	</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;提出来一个payTicket()方法用于把共享的代码锁起来</span><br><span class="line">	public synchronized void payTicket() &#123;</span><br><span class="line">		&#x2F;&#x2F;先判断票是否存在</span><br><span class="line">		if(ticket&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;提高安全问题出现的概率，让程序睡眠</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(10);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;票存在，卖票 ticket--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">		ticket--;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong><br>Thread-0–&gt;正在卖第100张票<br>Thread-2–&gt;正在卖第99张票<br>Thread-2–&gt;正在卖第98张票<br>…(省略)<br>Thread-2–&gt;正在卖第4张票<br>Thread-2–&gt;正在卖第3张票<br>Thread-2–&gt;正在卖第2张票<br>Thread-2–&gt;正在卖第1张票</p>
<hr>
<ul>
<li><p><strong>锁机制(Lock锁)</strong><br><code>java.util.concurrent.locks.lock接口</code></p>
</li>
<li><p><strong>lock接口</strong>(比synchronized更好)<br>　1. 使用<strong>获取锁<code>void lock()</code>/释放锁<code>void unlock()</code></strong>方法。<br>　2. 实现类<code>ReentrantLock</code> <strong>implements</strong> <code>Lock接口</code></p>
</li>
<li><p>使用步骤：</p>
</li>
</ul>
<ol>
<li>在成员位置–&gt;ReentrantLock对象</li>
<li>在可能会出现安全问题的代码<strong>前</strong>调用Lock方法<strong>获取锁</strong></li>
<li>在可能会出现安全问题的代码<strong>后</strong>调用Lock方法<strong>释放锁</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个多线程共享的票源：</span><br><span class="line">	private int ticket&#x3D;100;</span><br><span class="line">	&#x2F;&#x2F;定义一个对象</span><br><span class="line">	Lock l&#x3D;new ReentrantLock();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;设置线程任务:卖票</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	  while(true) </span><br><span class="line">	  &#123;</span><br><span class="line">		 	l.lock();&#x2F;&#x2F;加一个锁</span><br><span class="line">		&#x2F;&#x2F;先判断票是否存在</span><br><span class="line">		if(ticket&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;提高安全问题出现的概率，让程序睡眠</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(10);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;票存在，卖票 ticket--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">		ticket--;</span><br><span class="line">		&#125;</span><br><span class="line">		l.unlock();&#x2F;&#x2F;释放一个锁</span><br><span class="line">	  &#125;</span><br><span class="line">	 					&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">JAVA-多线程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JAVA-多线程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/04/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
      <time datetime="2019-11-04T11:26:12.000Z" itemprop="datePublished">2019-11-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/04/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">JAVA-多线程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="第10章-多线程"><a href="#第10章-多线程" class="headerlink" title="第10章_多线程"></a>第10章_多线程</h1><hr>
<h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144573.png" alt="第3阶段：Java高级应用-第10章" style="zoom: 50%;">

<p><img src="/2019/11/04/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%AC%AC3%E9%98%B6%E6%AE%B5%EF%BC%9AJava%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8-%E7%AC%AC10%E7%AB%A0-16977849310392.png" alt></p>
<hr>
<p>我们之前学习的程序在没有跳转语句的情况下，都是由上至下沿着一条路径依次执行。现在想要设计一个程序，可以同时有多条执行路径同时执行。比如，<code>一边游戏，一边qq聊天，一边听歌</code>，怎么设计？</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144309.png" alt="c3dcb61e3b" style="zoom:50%;">

<p>要解决上述问题，需要使用<strong>多进程 *<em>/ *</em>多线程</strong>来解决。</p>
<h2 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h2><h3 id="1-1-程序、进程与线程"><a href="#1-1-程序、进程与线程" class="headerlink" title="1.1 程序、进程与线程"></a>1.1 程序、进程与线程</h3><ul>
<li><p><strong>程序（program）</strong>：为完成特定任务，用某种语言编写的<strong>一组指令的集合</strong>。即指<strong>一段静态的代码</strong>，静态对象。</p>
</li>
<li><p><strong>进程（process）</strong>：程序的一次执行过程，/ <strong>正在内存中运行的应用程序</strong>。如：运行中的QQ，运行中的网易音乐播放器。</p>
<ul>
<li>每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）</li>
<li>程序是静态的，进程是动态的</li>
<li>进程作为<strong>操作系统调度</strong>和<strong>分配资源的最小单位</strong>（/<strong>系统运行程序的基本单位</strong>），系统在运行时会为每个进程分配不同的内存区域。</li>
<li>现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。</li>
</ul>
</li>
<li><p><strong>线程（thread）</strong>：进程可进一步细化为线程，是<strong>程序内部的一条执行路径</strong>。一个进程中至少有一个线程。</p>
<ul>
<li><p><strong>一个进程</strong>同一时间若<strong>并行</strong>执行<strong>多个线程</strong>，就是支持多线程的。</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144895.png" alt="image-20220331233204504" style="zoom:67%;">
</li>
<li><p><strong>线程</strong>作为<strong>CPU调度和执行的最小单位</strong>。</p>
</li>
<li><p>一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来<code>安全的隐患</code>。</p>
</li>
<li><p>下图中，红框的蓝色区域为线程独享，黄色区域为线程共享。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144202.png" alt="image-20220514175737426" style="zoom:80%;">

<blockquote>
<p>注意：</p>
<p>不同的进程之间是不共享内存的。</p>
<p>进程之间的数据交换和通信的成本很高。</p>
</blockquote>
</li>
</ul>
<h3 id="1-2-查看进程和线程"><a href="#1-2-查看进程和线程" class="headerlink" title="1.2 查看进程和线程"></a>1.2 查看进程和线程</h3><p>我们可以在电脑底部任务栏，右键—–&gt;打开任务管理器，可以查看当前任务的进程：</p>
<p>1、每个应用程序的运行都是一个进程</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144299.png" style="zoom:80%;">

<p>2、一个应用程序的多次运行，就是多个进程</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144727.png" alt="1563267431480" style="zoom:80%;">

<p>3、一个进程中包含多个线程</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144152.png" alt="1563270525077" style="zoom:80%;">

<h3 id="1-3-线程调度"><a href="#1-3-线程调度" class="headerlink" title="1.3 线程调度"></a>1.3 线程调度</h3><ul>
<li><p><strong>分时调度</strong></p>
<p>所有线程<strong>轮流使用</strong> CPU 的使用权，并且<strong>平均分配</strong>每个线程占用 CPU 的时间。</p>
</li>
<li><p><strong>抢占式调度</strong></p>
<p>让<strong>优先级高的线程</strong>以<strong>较大概率</strong>优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，<strong>Java使用抢占式调度</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144911.bmp" alt></p>
</li>
</ul>
<h3 id="1-4-多线程程序的优点"><a href="#1-4-多线程程序的优点" class="headerlink" title="1.4 多线程程序的优点"></a>1.4 多线程程序的优点</h3><p><strong>背景：</strong>以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？</p>
<p><strong>多线程程序的优点：</strong></p>
<ol>
<li><p>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。[可以一边聊天，一边学习]</p>
</li>
<li><p>提高计算机系统CPU的利用率</p>
</li>
<li><p>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p>
</li>
</ol>
<h3 id="1-5-补充概念"><a href="#1-5-补充概念" class="headerlink" title="1.5 补充概念"></a>1.5 补充概念</h3><h4 id="1-5-1-单核CPU和多核CPU"><a href="#1-5-1-单核CPU和多核CPU" class="headerlink" title="1.5.1 单核CPU和多核CPU"></a>1.5.1 单核CPU和多核CPU</h4><p>单核CPU，在一个时间单元内，只能执行一个线程的任务。例如，可以把CPU看成是医院的医生诊室，在一定时间内只能给一个病人诊断治疗。所以单核CPU就是，代码经过前面一系列的前导操作（类似于医院挂号，比如有10个窗口挂号），然后到cpu处执行时发现，就只有一个CPU（对应一个医生），大家排队执行。</p>
<p>这时候想要提升系统性能，只有两个办法，要么提升CPU性能（让医生看病快点），要么多加几个CPU（多整几个医生），即为多核的CPU。</p>
<p><code>问题：多核的效率是单核的倍数吗？</code>譬如4核A53的cpu，性能是单核A53的4倍吗？理论上是，但是实际不可能，至少有两方面的损耗。</p>
<ul>
<li><code>一个是多个核心的其他共用资源限制</code>。譬如，4核CPU对应的内存、cache、寄存器并没有同步扩充4倍。这就好像医院一样，1个医生换4个医生，但是做B超检查的还是一台机器，性能瓶颈就从医生转到B超检查了。</li>
<li><code>另一个是多核CPU之间的协调管理损耗</code>。譬如多个核心同时运行两个相关的任务，需要考虑任务同步，这也需要消耗额外性能。好比公司工作，一个人的时候至少不用开会浪费时间，自己跟自己商量就行了。两个人就要开会同步工作，协调分配，所以工作效率绝对不可能达到2倍。</li>
</ul>
<h4 id="1-5-2-并行与并发"><a href="#1-5-2-并行与并发" class="headerlink" title="1.5.2 并行与并发"></a>1.5.2 并行与并发</h4><ul>
<li><p><strong>并行（parallel）</strong>：指两个或多个事件在<code>同一时刻</code>发生（同时发生）。指在同一时刻，<strong>有<code>多条指令</code>在<code>多个CPU</code>上<code>同时</code>执行</strong>。比如：多个人同时做不同的事。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144644.png" alt="image-20231017195504293"></p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144716.png" alt="image-20220513181758585" style="zoom: 50%;">
</li>
<li><p><strong>并发（concurrency）</strong>：指两个或多个事件在<code>同一个时间段内</code>发生。即在一段时间内，<strong>有<code>多条指令</code>在<code>单个CPU</code>上<code>快速轮换、交替</code>执行</strong>，使得在宏观上具有多个进程同时执行的效果。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144321.png" alt></p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144194.png" alt="image-20220513181815978" style="zoom:50%;">


</li>
</ul>
<p>在操作系统中，启动了多个程序，<code>并发</code>指的是在一段时间内宏观上有多个程序同时运行，这在单核 CPU 系统中，每一时刻只能有一个程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多核 CPU 系统中，则这些可以<code>并发</code>执行的程序便可以分配到多个CPU上，实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，<code>并行</code>处理的程序越多，能大大的提高电脑运行的效率。</p>
<h2 id="2-创建和启动线程"><a href="#2-创建和启动线程" class="headerlink" title="2.创建和启动线程"></a>2.创建和启动线程</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul>
<li><p>Java语言的JVM允许程序运行多个线程，使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。</p>
</li>
<li><p>Thread类的特性</p>
<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，因此把run()方法体称为<code>线程执行体</code>。</li>
<li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li>
<li>要想实现多线程，必须在主线程中创建新的线程对象。</li>
</ul>
</li>
</ul>
<h3 id="2-2-方式1：继承Thread类"><a href="#2-2-方式1：继承Thread类" class="headerlink" title="2.2 方式1：继承Thread类"></a>2.2 方式1：继承Thread类</h3><p>Java通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">"：正在执行！"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建自定义线程对象1</span></span><br><span class="line">        MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"子线程1"</span>);</span><br><span class="line">        <span class="comment">//开启子线程1</span></span><br><span class="line">        mt1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建自定义线程对象2</span></span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"子线程2"</span>);</span><br><span class="line">        <span class="comment">//开启子线程2</span></span><br><span class="line">        mt2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在主方法中执行for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main线程！"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144725.png" alt="image-20220401221215860" style="zoom:67%;">

<blockquote>
<p>注意：</p>
<ol>
<li><p>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</p>
</li>
<li><p>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</p>
</li>
<li><p>想要启动多线程，必须调用start方法。</p>
</li>
<li><p>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“<code>IllegalThreadStateException</code>”。</p>
</li>
</ol>
</blockquote>
<h3 id="2-3-方式2：实现Runnable接口"><a href="#2-3-方式2：实现Runnable接口" class="headerlink" title="2.3 方式2：实现Runnable接口"></a>2.3 方式2：实现Runnable接口</h3><p>Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写run()方法，然后再通过Thread类的对象代理启动和执行我们的线程体run()方法</p>
<p>步骤如下：</p>
<ol>
<li><p>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p>
</li>
<li><p>创建Runnable实现类的实例，并以此实例作为Thread的target参数来创建Thread对象，该Thread对象才是真正<br>的线程对象。</p>
</li>
<li><p>调用线程对象的start()方法，启动线程。调用Runnable接口实现类的run方法。</p>
</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象  线程任务对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr, <span class="string">"长江"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"黄河 "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过实现Runnable接口，使得该类有了多线程类的特征。所有的分线程要执行的代码都在run方法里面。</p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p>
<p>实际上，所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p>
<p>说明：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
<img src=".images/image-20220401222212377-169778493103914.png" alt="image-20220401222212377">

<h3 id="2-4-变形写法"><a href="#2-4-变形写法" class="headerlink" title="2.4 变形写法"></a>2.4 变形写法</h3><p><strong>使用匿名内部类对象来实现线程的创建和启动</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"新的线程！"</span>)&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">"：正在执行！"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"："</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h3 id="2-5-对比两种方式"><a href="#2-5-对比两种方式" class="headerlink" title="2.5 对比两种方式"></a>2.5 对比两种方式</h3><p><strong>联系</strong></p>
<p>Thread类实际上也是实现了Runnable接口的类。即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;&#125;   <span class="comment">//代理模式</span></span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<ul>
<li><p>继承Thread：线程代码存放Thread子类run方法中。</p>
</li>
<li><p>实现Runnable：线程代码存在接口的子类的run方法。</p>
</li>
</ul>
<p><strong>实现Runnable接口比继承Thread类所具有的优势</strong></p>
<ul>
<li>避免了单继承的局限性</li>
<li>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
</ul>
<h3 id="2-6-练习"><a href="#2-6-练习" class="headerlink" title="2.6 练习"></a>2.6 练习</h3><p>创建两个分线程，让其中一个线程输出1-100之间的偶数，另一个线程输出1-100之间的奇数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实现输出偶数</span><br><span class="line">class PrintNumber2 implements Runnable&#123;  &#x2F;&#x2F;1.创建一个子类实现Runnable接口</span><br><span class="line">    &#x2F;&#x2F;2.实现接口中的run()  ---&gt;将此线程要执行的操作声明在此方法体中</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">            if(i%2&#x3D;&#x3D;0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;实现输出奇数</span><br><span class="line">class PrintNumber3 implements Runnable&#123;  &#x2F;&#x2F;1.创建一个子类实现Runnable接口</span><br><span class="line">    &#x2F;&#x2F;2.实现接口中的run()  ---&gt;将此线程要执行的操作声明在此方法体中</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;&#x3D;100;i++) &#123;</span><br><span class="line">            if(i%2!&#x3D;0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">public class EvenNumberTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;3.创建当前实现类的对象</span><br><span class="line">        PrintNumber2 printNumber2&#x3D;new PrintNumber2();</span><br><span class="line">        &#x2F;&#x2F;4.将此对象作为参数传递给Thread的构造器中，创建Thread类的实例</span><br><span class="line">        Thread thread&#x3D;new Thread(printNumber2);</span><br><span class="line">        &#x2F;&#x2F;5.Thread类的实例调用start()</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3.创建当前实现类的对象</span><br><span class="line">        PrintNumber3 printNumber3&#x3D;new PrintNumber3();</span><br><span class="line">        &#x2F;&#x2F;再创建一个线程</span><br><span class="line">        &#x2F;&#x2F;4.将此对象作为参数传递给Thread的构造器中，创建Thread类的实例</span><br><span class="line">        Thread thread2&#x3D;new Thread(printNumber3);</span><br><span class="line">        &#x2F;&#x2F;5.Thread类的实例调用start()</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144290.png" alt="image-20231018154959304"></p>
<h2 id="3-Thread类的常用结构"><a href="#3-Thread类的常用结构" class="headerlink" title="3. Thread类的常用结构"></a>3. Thread类的常用结构</h2><h3 id="3-1-构造器"><a href="#3-1-构造器" class="headerlink" title="3.1 构造器"></a>3.1 构造器</h3><ul>
<li>public <strong>Thread()</strong> :分配一个新的线程对象。</li>
<li>public <strong>Thread(String name)</strong> :分配一个指定名字的新的线程对象。</li>
<li>public <strong>Thread(Runnable target)</strong> :指定创建线程的目标对象，它实现了Runnable接口中的run方法</li>
<li>public <strong>Thread(Runnable target,String name)</strong> :分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<h3 id="3-2-常用方法系列1"><a href="#3-2-常用方法系列1" class="headerlink" title="3.2 常用方法系列1"></a>3.2 常用方法系列1</h3><ul>
<li>public void <strong>run()</strong> :此线程要执行的任务在此处定义代码。</li>
<li>public void <strong>start()</strong> :导致此线程开始执行; Java虚拟机调用此线程的run方法。</li>
<li>public String <strong>getName()</strong> :获取当前线程名称。</li>
<li>public void <strong>setName(String name)</strong>：设置该线程名称。</li>
<li>public static Thread <strong>currentThread()</strong> :返回对当前正在执行的线程对象的引用。在Thread子类中就是this，通常用于主线程和Runnable实现类</li>
<li>public static void <strong>sleep(long millis)</strong> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li>
<li>public static void <strong>yield()</strong>：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。</li>
</ul>
<h3 id="3-3-常用方法系列2"><a href="#3-3-常用方法系列2" class="headerlink" title="3.3 常用方法系列2"></a>3.3 常用方法系列2</h3><ul>
<li><p>public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 </p>
</li>
<li><p>void join() ：等待该线程终止。 </p>
<p>void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 </p>
<p>void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 </p>
</li>
<li><p>public final void stop()：<code>已过时</code>，不建议使用。强行结束一个线程的执行，直接进入死亡状态。run()即刻停止，可能会导致一些清理性的工作得不到完成，如文件，数据库等的关闭。同时，会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。</p>
</li>
<li><p>void suspend() / void resume() : 这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend()调用会导致线程暂停，但不会释放任何锁资源，导致其它线程都无法访问被它占用的锁，直到调用resume()。<code>已过时</code>，不建议使用。</p>
</li>
</ul>
<h3 id="3-4-常用方法系列3"><a href="#3-4-常用方法系列3" class="headerlink" title="3.4 常用方法系列3"></a>3.4 常用方法系列3</h3><p>每个线程都有一定的优先级:</p>
<p>优先级相同的线程 —&gt; 分时调度策略<br>优先级高的线程 —&gt; 抢占式策略，获得较多的执行机会。<br>每个线程<strong>默认</strong>:和创建它的父线程优先级相同。</p>
<ul>
<li>Thread类的三个优先级常量：<ul>
<li>MAX_PRIORITY（10）：最高优先级 【max_priority】</li>
<li>MIN _PRIORITY （1）：最低优先级 【min_priority】</li>
<li>NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。 【norm_priority】</li>
</ul>
</li>
</ul>
<ul>
<li>public final int getPriority() ：返回线程优先级 </li>
<li>public final void setPriority(int newPriority) ：改变线程的优先级，范围在[1,10]之间。</li>
</ul>
<p>练习：获取main线程对象的名称和优先级。</p>
<p>声明一个匿名内部类继承Thread类，重写run方法，在run方法中获取线程名称和优先级。设置该线程优先级为最高优先级并启动该线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接在构造器内部重写Runnable接口  实现run方法</span></span><br><span class="line">        Thread t= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"获取main线程对象的名称和优先级"</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(t.getName());</span><br><span class="line">        System.out.println(t.getPriority());</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="comment">//currentThread()是一个静态方法</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">最终输出:</span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">--------------</span><br><span class="line">main</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<ul>
<li><p>声明一个匿名内部类继承Thread类，重写run方法，实现打印[1,100]之间的偶数，要求每隔1秒打印1个偶数。</p>
</li>
<li><p>声明一个匿名内部类继承Thread类，重写run方法，实现打印[1,100]之间的奇数，</p>
<ul>
<li>当打印到5时，让奇数线程暂停一下，再继续。</li>
<li>当打印到5时，让奇数线程停下来，让偶数线程执行完再打印。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//打印1-100的偶数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i+=<span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//每隔1秒就打印一个</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);  <span class="comment">//可能存在异常</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);  <span class="comment">//手动抛出异常  try-catch捕获异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//打印1-100的奇数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i+=<span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                        Thread.yield();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            t1.join(); <span class="comment">//可能存在异常</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);   <span class="comment">//手动抛出异常  try-catch捕获异常</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144802.png" alt="img"></p>
<h3 id="3-5-守护线程（看门狗）"><a href="#3-5-守护线程（看门狗）" class="headerlink" title="3.5 守护线程（看门狗）"></a>3.5 守护线程（看门狗）</h3><p>有一种线程，它是在后台运行的，它的任务是<strong>为其他线程提供服务</strong>，这种线程被称为“<strong>守护线程</strong>”。<br><strong>JVM的垃圾回收线程</strong>就是典型的守护线程。</p>
<p>守护线程有个特点，就是如果所有非守护线程都死亡，那么守护线程自动死亡。形象理解：<code>兔死狗烹</code>，<code>鸟尽弓藏</code></p>
<p>调用setDaemon(true)方法可将指定线程设置为守护线程。必须在线程启动之前设置，否则会报IllegalThreadStateException异常。</p>
<p>调用isDaemon()可以判断线程是否是守护线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建线程对象</span></span><br><span class="line">        MyDaemon m = <span class="keyword">new</span> MyDaemon();</span><br><span class="line">        <span class="comment">//设置为true</span></span><br><span class="line">        m.setDaemon(<span class="keyword">true</span>); <span class="comment">//指定线程为守护线程[必须在线程启动之前设置]  --否则会报IllegalThreadStateException异常</span></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        m.start();  </span><br><span class="line">        <span class="comment">//输出1-100</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"main:"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDaemon</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"我一直守护者你..."</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144616.png" alt="image-20231019100823015"></p>
<h2 id="4-多线程的生命周期"><a href="#4-多线程的生命周期" class="headerlink" title="4. 多线程的生命周期"></a>4. 多线程的生命周期</h2><p>Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下一些状态：</p>
<h3 id="4-1-JDK1-5之前：5种状态"><a href="#4-1-JDK1-5之前：5种状态" class="headerlink" title="4.1 JDK1.5之前：5种状态"></a>4.1 JDK1.5之前：5种状态</h3><p>线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。</p>
<img src=".images/image-20220401002307038-169778493103918.png" alt="image-20220401002307038" style="zoom: 67%;">



<p><strong>1.新建</strong></p>
<p>当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。此时它和其他Java对象一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体run()。</p>
<p><strong>2.就绪</strong></p>
<p>但是当线程对象调用了start()方法之后，就不一样了，线程就从新建状态转为就绪状态。JVM会为其创建方法调用栈和程序计数器，当然，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于JVM里线程调度器的调度。</p>
<blockquote>
<p>注意：</p>
<p>程序只能对新建状态的线程调用start()，并且只能调用一次，如果对非新建状态的线程，如已启动的线程或已死亡的线程调用start()都会报错IllegalThreadStateException异常。</p>
</blockquote>
<p><strong>3.运行</strong></p>
<p>如果处于就绪状态的线程获得了CPU资源时，开始执行run()方法的线程体代码，则该线程处于运行状态。如果计算机只有一个CPU核心，在任何时刻只有一个线程处于运行状态，如果计算机有多个核心，将会有多个线程并行(Parallel)执行。</p>
<p>当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程的优先级。</p>
<p><strong>4.阻塞</strong></p>
<p>当在运行过程中的线程遇到如下情况时，会让出 CPU 并临时中止自己的执行，进入阻塞状态：</p>
<ul>
<li>线程调用了sleep()方法，主动放弃所占用的CPU资源；</li>
<li>线程试图获取一个同步监视器，但该同步监视器正被其他线程持有；</li>
<li>线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）；</li>
<li>线程执行过程中，同步监视器调用了wait(time)</li>
<li>线程执行过程中，遇到了其他线程对象的加塞（join）；</li>
<li>线程被调用suspend方法被挂起（已过时，因为容易发生死锁）；</li>
</ul>
<p>当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入就绪状态，等待线程调度器再次调度它：</p>
<ul>
<li>线程的sleep()时间到；</li>
<li>线程成功获得了同步监视器；</li>
<li>线程等到了通知(notify)；</li>
<li>线程wait的时间到了</li>
<li>加塞的线程结束了；</li>
<li>被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）；</li>
</ul>
<p><strong>5.死亡</strong></p>
<p>线程会以以下三种方式之一结束，结束后的线程就处于死亡状态：</p>
<ul>
<li>run()方法执行完成，线程正常结束</li>
<li>线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）</li>
<li>直接调用该线程的stop()来结束该线程（已过时）</li>
</ul>
<h3 id="4-2-JDK1-5及之后：6种状态"><a href="#4-2-JDK1-5及之后：6种状态" class="headerlink" title="4.2 JDK1.5及之后：6种状态"></a>4.2 JDK1.5及之后：6种状态</h3><p>在java.lang.Thread.State的枚举类中这样定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">	NEW,</span><br><span class="line">	RUNNABLE,</span><br><span class="line">	BLOCKED,</span><br><span class="line">	WAITING,</span><br><span class="line">	TIMED_WAITING,</span><br><span class="line">	TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144613.png" alt="image-20231019103232090"></p>
<ul>
<li><code>NEW（新建）</code>：线程刚被创建，但是并未启动。还没调用start方法。</li>
<li><code>RUNNABLE（可运行）</code>：这里没有区分就绪和运行状态。因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。</li>
<li><code>Terminated（被终止）</code>：表明此线程已经结束生命周期，终止运行。</li>
<li>重点说明，根据Thread.State的定义，<strong>阻塞状态分为三种</strong>：<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>。<ul>
<li><code>BLOCKED（锁阻塞）</code>：在API中的介绍为：一个正在阻塞、等待一个监视器锁（锁对象）的线程处于这一状态。只有获得锁对象的线程才能有执行机会。<ul>
<li>比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</li>
</ul>
</li>
<li><code>TIMED_WAITING（计时等待）</code>：在API中的介绍为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。<ul>
<li>当前线程执行过程中遇到Thread类的<code>sleep</code>或<code>join</code>，Object类的<code>wait</code>，LockSupport类的<code>park</code>方法，并且在调用这些方法时，<code>设置了时间</code>，那么当前线程会进入TIMED_WAITING，直到时间到，或被中断。</li>
</ul>
</li>
<li><code>WAITING（无限等待）</code>：在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<ul>
<li>当前线程执行过程中遇到遇到Object类的<code>wait</code>，Thread类的<code>join</code>，LockSupport类的<code>park</code>方法，并且在调用这些方法时，<code>没有指定时间</code>，那么当前线程会进入WAITING状态，直到被唤醒。<ul>
<li>通过Object类的wait进入WAITING状态的要有Object的notify/notifyAll唤醒；</li>
<li>通过Condition的await进入WAITING状态的要有Condition的signal方法唤醒；</li>
<li>通过LockSupport类的park方法进入WAITING状态的要有LockSupport类的unpark方法唤醒</li>
<li>通过Thread类的join进入WAITING状态，只有调用join方法的线程对象结束才能让当前线程恢复；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>说明：当从WAITING或TIMED_WAITING恢复到Runnable状态时，如果发现当前线程没有得到监视器锁，那么会立刻转入BLOCKED状态。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144409.png" alt="image-20220524203355448"></p>
<blockquote>
<p>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，<br>比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。<br>这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是<br>如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两<br>得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态，直到倒计时完毕自动醒来；如果在倒<br>计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p>
</blockquote>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SubThread t = <span class="keyword">new</span> SubThread();</span><br><span class="line">        System.out.println(t.getName() + <span class="string">" 状态 "</span> + t.getState());</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.State.TERMINATED != t.getState()) &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">" 状态 "</span> + t.getState());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.getName() + <span class="string">" 状态 "</span> + t.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承Thread类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"打印："</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令行演示：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144933.png" alt="image-20220524195035355"></p>
<h2 id="5-线程安全问题及解决"><a href="#5-线程安全问题及解决" class="headerlink" title="5. 线程安全问题及解决"></a>5. 线程安全问题及解决</h2><p>当我们使用多个线程访问<strong>同一资源</strong>（可以是同一个变量、同一个文件、同一条记录等）的时候，若多个线程<code>只有读操作</code>，那么不会发生线程安全问题。但是如果多个线程中对资源有<code>读和写</code>的操作，就容易出现线程安全问题。</p>
<p>举例：</p>
<img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144458.png" alt="image-20220401233218326" style="zoom:67%;">



<p>类比：</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144853.gif" alt></p>
<h3 id="5-1-同一个资源问题和线程安全问题"><a href="#5-1-同一个资源问题和线程安全问题" class="headerlink" title="5.1 同一个资源问题和线程安全问题"></a>5.1 同一个资源问题和线程安全问题</h3><p>案例：</p>
<p>火车站要卖票，我们模拟火车站的卖票过程。因为疫情期间，本次列车的座位共100个（即，只能出售100张火车票）。我们来模拟车站的售票窗口，实现多个窗口同时售票的过程。注意：不能出现错票、重票。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">方式一:实现接口</span><br><span class="line">&#x2F;&#x2F;实现接口</span><br><span class="line">class SaleTicket implements Runnable&#123;</span><br><span class="line">    int ticket&#x3D;100;</span><br><span class="line">    &#x2F;&#x2F;实现接口的run方法</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(ticket&gt;0)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10); &#x2F;&#x2F;要让线程休眠10毫秒</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    throw new RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;售票,票号为&quot;+ticket);</span><br><span class="line">                ticket--; &#x2F;&#x2F;卖出去就少一张余额</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break; &#x2F;&#x2F;卖完了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WindowTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SaleTicket s&#x3D;new SaleTicket();</span><br><span class="line">        Thread t1&#x3D;new Thread(s);</span><br><span class="line">        Thread t2&#x3D;new Thread(s);</span><br><span class="line">        Thread t3&#x3D;new Thread(s);</span><br><span class="line">        &#x2F;&#x2F;给线程设置名称</span><br><span class="line">        t1.setName(&quot;窗口1&quot;);</span><br><span class="line">        t2.setName(&quot;窗口2&quot;);</span><br><span class="line">        t3.setName(&quot;窗口3&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">方式二:继承Thread类</span><br><span class="line">package thread;</span><br><span class="line">class Window extends Thread&#123;</span><br><span class="line">    static int ticket &#x3D; 100;  &#x2F;&#x2F;静态属性 </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(ticket &gt; 0)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;售票，票号为：&quot; + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WindowTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Window w1 &#x3D; new Window();</span><br><span class="line">        Window w2 &#x3D; new Window();</span><br><span class="line">        Window w3 &#x3D; new Window();</span><br><span class="line">        w1.setName(&quot;窗口1&quot;);</span><br><span class="line">        w2.setName(&quot;窗口2&quot;);</span><br><span class="line">        w3.setName(&quot;窗口3&quot;);</span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是会出现一些安全问题:</strong></p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212144551.png" alt="image-20231019144713478"></p>
<h4 id="5-1-1-局部变量不能共享"><a href="#5-1-1-局部变量不能共享" class="headerlink" title="5.1.1 局部变量不能共享"></a>5.1.1 局部变量不能共享</h4><p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一 继承Thread类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> run() &#123;</span><br><span class="line">        int ticket = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">"卖出一张票，票号:"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo1</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        Window w1 = <span class="keyword">new</span> Window();</span><br><span class="line">        Window w2 = <span class="keyword">new</span> Window();</span><br><span class="line">        Window w3 = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        w1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        w2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        w3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现卖出300张票。</p>
<p>问题：局部变量是每次调用方法都是独立的，那么每个线程的run()的ticket是独立的，不是共享数据。</p>
<h4 id="5-1-2-不同对象的实例变量不共享"><a href="#5-1-2-不同对象的实例变量不共享" class="headerlink" title="5.1.2 不同对象的实例变量不共享"></a>5.1.2 不同对象的实例变量不共享</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">"卖出一张票，票号:"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TicketWindow w1 = <span class="keyword">new</span> TicketWindow();</span><br><span class="line">        TicketWindow w2 = <span class="keyword">new</span> TicketWindow();</span><br><span class="line">        TicketWindow w3 = <span class="keyword">new</span> TicketWindow();</span><br><span class="line"></span><br><span class="line">        w1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        w2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        w3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现卖出300张票。</p>
<p>问题：不同的实例对象的实例变量是独立的。</p>
<h4 id="5-1-3-静态变量是共享的"><a href="#5-1-3-静态变量是共享的" class="headerlink" title="5.1.3 静态变量是共享的"></a>5.1.3 静态变量是共享的</h4><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketSaleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">"卖出一张票，票号:"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TicketSaleThread t1 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line">        TicketSaleThread t2 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line">        TicketSaleThread t3 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">100</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">100</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">100</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">97</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">97</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">97</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">94</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">94</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">94</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">91</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">91</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">91</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">88</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">88</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">88</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">85</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">85</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">85</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">82</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">82</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">82</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">79</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">79</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">79</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">76</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">76</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">76</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">73</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">73</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">73</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">70</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">70</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">70</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">67</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">67</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">67</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">64</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">64</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">64</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">61</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">61</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">61</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">58</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">58</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">58</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">55</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">55</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">55</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">52</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">52</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">52</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">49</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">49</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">49</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">46</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">46</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">46</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">43</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">43</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">43</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">40</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">40</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">40</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">37</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">37</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">37</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">34</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">34</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">34</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">31</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">31</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">31</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">28</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">28</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">28</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">25</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">25</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">25</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">22</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">22</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">22</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">19</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">19</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">19</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">16</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">16</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">16</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">13</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">13</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">13</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">10</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">10</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">10</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">7</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">7</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">7</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">4</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">4</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">4</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">1</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">1</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>结果：发现卖出近100张票。</p>
<p>问题1：但是有重复票或负数票问题。</p>
<p>原因：线程安全问题</p>
<p>问题2：如果要考虑有两场电影，各卖100张票等</p>
<p>原因：TicketThread类的静态变量，是所有TicketThread类的对象共享</p>
<h4 id="5-1-4-同一个对象的实例变量共享"><a href="#5-1-4-同一个对象的实例变量共享" class="headerlink" title="5.1.4 同一个对象的实例变量共享"></a>5.1.4 同一个对象的实例变量共享</h4><p>示例代码：多个Thread线程使用同一个Runnable对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketSaleRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出一张票，票号:"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TicketSaleRunnable tr = <span class="keyword">new</span> TicketSaleRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(tr, <span class="string">"窗口一"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(tr, <span class="string">"窗口二"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(tr, <span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现卖出近100张票。</p>
<p>问题：但是有重复票或负数票问题。</p>
<p>原因：线程安全问题</p>
<h4 id="5-1-5-抽取资源类，共享同一个资源对象"><a href="#5-1-5-抽取资源类，共享同一个资源对象" class="headerlink" title="5.1.5 抽取资源类，共享同一个资源对象"></a>5.1.5 抽取资源类，共享同一个资源对象</h4><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、编写资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出一张票，票号:"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有票了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2、创建资源对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、启动多个线程操作资源类的对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"窗口一"</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="string">"窗口二"</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：发现卖出近100张票。</p>
<p>问题：但是有重复票或负数票问题。</p>
<p>原因：线程安全问题</p>
<h3 id="5-2-同步机制解决线程安全问题"><a href="#5-2-同步机制解决线程安全问题" class="headerlink" title="5.2 同步机制解决线程安全问题"></a>5.2 同步机制解决线程安全问题</h3><p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制<br>(synchronized)来解决。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212145217.png" alt="1563372934332"></p>
<p>根据案例简述：</p>
<p>窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p>
<p>为了保证每个线程都能正常执行原子操作，Java引入了<strong>线程同步机制</strong>。注意:在任何时候,最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着(BLOCKED)。</p>
<h4 id="5-2-1-同步机制解决线程安全问题的原理"><a href="#5-2-1-同步机制解决线程安全问题的原理" class="headerlink" title="5.2.1 同步机制解决线程安全问题的原理"></a>5.2.1 同步机制解决线程安全问题的原理</h4><p>同步机制的原理，其实就相当于给某段代码加“锁”，任何线程想要执行这段代码，都要先获得“锁”，我们称它为同步锁。因为Java对象在堆中的数据分为分为对象头、实例变量、空白的填充。而对象头中包含：</p>
<ul>
<li>Mark Word：记录了和当前对象有关的GC、锁标记等信息。</li>
<li>指向类的指针：每一个对象需要记录它是由哪个类创建出来的。</li>
<li>数组长度（只有数组对象才有）</li>
</ul>
<p>哪个线程获得了“同步锁”对象之后，”同步锁“对象就会记录这个线程的ID，这样其他线程就只能等待了，除非这个线程”释放“了锁对象，其他线程才能重新获得/占用”同步锁“对象。</p>
<h4 id="5-2-2-同步代码块和同步方法"><a href="#5-2-2-同步代码块和同步方法" class="headerlink" title="5.2.2 同步代码块和同步方法"></a>5.2.2 同步代码块和同步方法</h4><ul>
<li><strong>同步代码块</strong>：synchronized 关键字可以用于<strong>某个区</strong>块前面，表示只对这个区块的资源实行互斥访问。<br>格式:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器/同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>同步方法：</strong>synchronized 关键字<strong>直接修饰方法</strong>，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-3-同步锁机制"><a href="#5-2-3-同步锁机制" class="headerlink" title="5.2.3 同步锁机制"></a>5.2.3 同步锁机制</h4><p>在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p>
<h4 id="5-2-4-synchronized的锁是什么"><a href="#5-2-4-synchronized的锁是什么" class="headerlink" title="5.2.4 synchronized的锁是什么"></a>5.2.4 synchronized的锁是什么</h4><p>同步锁对象可以是任意类型，但是必须保证竞争“同一个共享资源”的多个线程必须使用同一个“同步锁对象”。</p>
<p>对于同步代码块来说，同步锁对象是由程序员手动指定的（很多时候也是指定为this或类名.class），但是对于同步方法来说，同步锁对象只能是默认的：</p>
<ul>
<li><p>静态方法：当前类的Class对象（类名.class）</p>
</li>
<li><p>非静态方法：this</p>
</li>
</ul>
<h4 id="5-2-5-同步操作的思考顺序"><a href="#5-2-5-同步操作的思考顺序" class="headerlink" title="5.2.5 同步操作的思考顺序"></a>5.2.5 同步操作的思考顺序</h4><p>1、如何找问题，即代码是否存在线程安全？（非常重要）<br>（1）明确哪些代码是多线程运行的代码<br>（2）明确多个线程是否有共享数据<br>（3）明确多线程运行代码中是否有多条语句操作共享数据</p>
<p>2、如何解决呢？（非常重要）<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。<br>即所有操作共享数据的这些语句都要放在同步范围中</p>
<p>3、切记：</p>
<p>范围太小：不能解决安全问题</p>
<p>范围太大：因为一旦某个线程抢到锁，其他线程就只能等待，所以范围太大，效率会降低，不能合理利用CPU资源。</p>
<h4 id="5-2-6-代码演示"><a href="#5-2-6-代码演示" class="headerlink" title="5.2.6 代码演示"></a>5.2.6 代码演示</h4><h5 id="示例一：静态方法加锁"><a href="#示例一：静态方法加锁" class="headerlink" title="示例一：静态方法加锁"></a>示例一：静态方法加锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketSaleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">//直接锁这里，肯定不行，会导致，只有一个窗口卖票</span></span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            saleOneTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saleOneTicket</span><span class="params">()</span></span>&#123;<span class="comment">//锁对象是TicketSaleThread类的Class对象，而一个类的Class对象在内存中肯定只有一个</span></span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出一张票，票号:"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TicketSaleThread t1 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line">        TicketSaleThread t2 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line">        TicketSaleThread t3 = <span class="keyword">new</span> TicketSaleThread();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例二：非静态方法加锁"><a href="#示例二：非静态方法加锁" class="headerlink" title="示例二：非静态方法加锁"></a>示例二：非静态方法加锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TicketSaleRunnable tr = <span class="keyword">new</span> TicketSaleRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(tr, <span class="string">"窗口一"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(tr, <span class="string">"窗口二"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(tr, <span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketSaleRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//直接锁这里，肯定不行，会导致，只有一个窗口卖票</span></span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            saleOneTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleOneTicket</span><span class="params">()</span> </span>&#123;<span class="comment">//锁对象是this，这里就是TicketSaleRunnable对象，因为上面3个线程使用同一个TicketSaleRunnable对象，所以可以</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出一张票，票号:"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例三：同步代码块"><a href="#示例三：同步代码块" class="headerlink" title="示例三：同步代码块"></a>示例三：同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2、创建资源对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、启动多个线程操作资源类的对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"窗口一"</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//不能给run()直接加锁，因为t1,t2,t3的三个run方法分别属于三个Thread类对象，</span></span><br><span class="line">                <span class="comment">// run方法是非静态方法，那么锁对象默认选this，那么锁对象根本不是同一个</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">                        ticket.sale();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="string">"窗口二"</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">                        ticket.sale();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">                        ticket.sale();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"窗口三"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、编写资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;<span class="comment">//也可以直接给这个方法加锁，锁对象是this，这里就是Ticket对象</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"卖出一张票，票号:"</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有票了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-练习"><a href="#5-3-练习" class="headerlink" title="5.3 练习"></a>5.3 练习</h3><p>银行有一个账户。<br>有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。</p>
<p>问题：该程序是否有安全问题，如果有，如何解决？</p>
<p>【提示】<br>1，明确哪些代码是多线程运行代码，须写入run()方法   —deposit存钱方法【因为可能会出现存钱异常】<br>2，明确什么是共享数据。   —balance余额<br>3，明确多线程运行代码中哪些语句是操作共享数据的。</p>
<p>【拓展问题】可否实现两个储户交替存钱的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Account&#123; &#x2F;&#x2F;账户</span><br><span class="line">    private double balance;&#x2F;&#x2F;余额</span><br><span class="line">    &#x2F;&#x2F;set和get方法</span><br><span class="line">    public double getBalance() &#123;</span><br><span class="line">        return balance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setBalance(double balance) &#123;</span><br><span class="line">        this.balance &#x3D; balance;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;存款方法  --要写成同步方法 </span><br><span class="line">    public synchronized void deposit(double money)&#123;  &#x2F;&#x2F;非静态方法默认是this  因为account是唯一的  所以可以</span><br><span class="line">        this.balance+&#x3D;money;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;充了1000元,现在余额是:&quot;+this.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Customer extends Thread&#123;</span><br><span class="line">    &#x2F;&#x2F;有一个账户对象</span><br><span class="line">    Account account;</span><br><span class="line">    &#x2F;&#x2F;有参构造器</span><br><span class="line">    public Customer(Account account)&#123;</span><br><span class="line">        this.account&#x3D;account;</span><br><span class="line">    &#125;</span><br><span class="line">    public Customer(Account account,String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.account&#x3D;account;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        &#x2F;&#x2F;存钱的操作要放入run方法</span><br><span class="line">        for(int i&#x3D;0;i&lt;3;i++)&#123;</span><br><span class="line">            account.deposit(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AccountTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建账户类对象</span><br><span class="line">        Account account &#x3D; new Account();</span><br><span class="line">        Customer customer1 &#x3D; new Customer(account,&quot;甲&quot;);</span><br><span class="line">        Customer customer2 &#x3D; new Customer(account,&quot;乙&quot;);</span><br><span class="line">        customer1.start();</span><br><span class="line">        customer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212145916.png" alt="image-20231019162559285"></p>
<h2 id="6-再谈同步"><a href="#6-再谈同步" class="headerlink" title="6. 再谈同步"></a>6. 再谈同步</h2><h3 id="6-1-单例设计模式的线程安全问题"><a href="#6-1-单例设计模式的线程安全问题" class="headerlink" title="6.1 单例设计模式的线程安全问题"></a>6.1 单例设计模式的线程安全问题</h3><h4 id="6-1-1-饿汉式没有线程安全问题"><a href="#6-1-1-饿汉式没有线程安全问题" class="headerlink" title="6.1.1 饿汉式没有线程安全问题"></a>6.1.1 饿汉式没有线程安全问题</h4><p>饿汉式：在类初始化时就直接创建单例对象，而类初始化过程是没有线程安全问题的</p>
<p>形式一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingle INSTANCE = <span class="keyword">new</span> HungrySingle(); <span class="comment">//对象是否声明为final 都可以</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingle</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingle <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形式二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HungryOne&#123;</span></span><br><span class="line"><span class="comment">    public static final HungryOne INSTANCE = new HungryOne();</span></span><br><span class="line"><span class="comment">    private HungryOne()&#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HungryOne&#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.hungry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HungrySingle hs1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> HungrySingle hs2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示存在的线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                hs1 = HungrySingle.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                hs2 = HungrySingle.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(hs1);</span><br><span class="line">        System.out.println(hs2);</span><br><span class="line">        System.out.println(hs1 == hs2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-懒汉式线程安全问题"><a href="#6-1-2-懒汉式线程安全问题" class="headerlink" title="6.1.2 懒汉式线程安全问题"></a>6.1.2 懒汉式线程安全问题</h4><p>懒汉式：延迟创建对象，第一次调用getInstance方法再创建对象</p>
<p>形式一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyOne</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyOne</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title">getInstance1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazyOne();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式2：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title">getInstance2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazyOne<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> LazyOne();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式3：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title">getInstance3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyOne<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);<span class="comment">//加这个代码，暴露问题</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazyOne();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意：上述方式3中，有指令重排问题</span></span><br><span class="line"><span class="comment">    mem = allocate(); 为单例对象分配内存空间</span></span><br><span class="line"><span class="comment">    instance = mem;   instance引用现在非空，但还未初始化</span></span><br><span class="line"><span class="comment">    ctorSingleton(instance); 为单例对象通过instance调用构造器</span></span><br><span class="line"><span class="comment">    从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。但是需要   </span></span><br><span class="line"><span class="comment">    volatile关键字，避免指令重排。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形式二：使用内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingle</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingle <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> LazySingle INSTANCE = <span class="keyword">new</span> LazySingle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内部类只有在外部类被调用才加载，产生INSTANCE实例；又不用加锁。</p>
<p>此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式。</p>
<p>此时的内部类，使用enum进行定义，也是可以的。</p>
</blockquote>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLazy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LazyOne s1 = LazyOne.getInstance();</span><br><span class="line">        LazyOne s2 = LazyOne.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把s1和s2声明在外面，是想要在线程的匿名内部类中为s1和s2赋值</span></span><br><span class="line">    LazyOne s1;</span><br><span class="line">    LazyOne s2;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                s1 = LazyOne.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                s2 = LazyOne.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LazySingle obj1;</span><br><span class="line">    LazySingle obj2;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                obj1 = LazySingle.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                obj2 = LazySingle.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">        System.out.println(obj1 == obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-死锁"><a href="#6-2-死锁" class="headerlink" title="6.2 死锁"></a>6.2 死锁</h3><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212145190.png" alt="thread-lock"></p>
<blockquote>
<p>【小故事】</p>
<p>面试官：你能解释清楚什么是死锁，我就录取你！<br>面试者：你录取我，我就告诉你什么是死锁！<br>….<br>恭喜你，面试通过了</p>
</blockquote>
<p>一旦出现死锁，整个程序既不会发生异常，也不会给出任何提示，<strong>只是所有线程处于阻塞状态</strong>，无法继续。</p>
<p>举例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		StringBuilder s2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">					s1.append(<span class="string">"a"</span>);</span><br><span class="line">					s2.append(<span class="string">"1"</span>);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">						s1.append(<span class="string">"b"</span>);</span><br><span class="line">						s2.append(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">						System.out.println(s1);</span><br><span class="line">						System.out.println(s2);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">					s1.append(<span class="string">"c"</span>);</span><br><span class="line">					s2.append(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">						s1.append(<span class="string">"d"</span>);</span><br><span class="line">						s2.append(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">						System.out.println(s1);</span><br><span class="line">						System.out.println(s2);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"当前线程名: "</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">" 进入了A实例的foo方法"</span>); <span class="comment">// ①</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"当前线程名: "</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">" 企图调用B实例的last方法"</span>); <span class="comment">// ③</span></span><br><span class="line">		b.last();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"进入了A类的last方法内部"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"当前线程名: "</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">" 进入了B实例的bar方法"</span>); <span class="comment">// ②</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"当前线程名: "</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">" 企图调用A实例的last方法"</span>); <span class="comment">// ④</span></span><br><span class="line">		a.last();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"进入了B类的last方法内部"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	A a = <span class="keyword">new</span> A();</span><br><span class="line">	B b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread.currentThread().setName(<span class="string">"主线程"</span>);</span><br><span class="line">		<span class="comment">// 调用a对象的foo方法</span></span><br><span class="line">		a.foo(b);</span><br><span class="line">		System.out.println(<span class="string">"进入了主线程之后"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread.currentThread().setName(<span class="string">"副线程"</span>);</span><br><span class="line">		<span class="comment">// 调用b对象的bar方法</span></span><br><span class="line">		b.bar(a);</span><br><span class="line">		System.out.println(<span class="string">"进入了副线程之后"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DeadLock dl = <span class="keyword">new</span> DeadLock();</span><br><span class="line">		<span class="keyword">new</span> Thread(dl).start();</span><br><span class="line">		dl.init();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object g = <span class="keyword">new</span> Object();</span><br><span class="line">		Object m = <span class="keyword">new</span> Object();</span><br><span class="line">		Owner s = <span class="keyword">new</span> Owner(g,m);</span><br><span class="line">		Customer c = <span class="keyword">new</span> Customer(g,m);</span><br><span class="line">		<span class="keyword">new</span> Thread(s).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(c).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Owner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object goods;</span><br><span class="line">	<span class="keyword">private</span> Object money;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Owner</span><span class="params">(Object goods, Object money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.goods = goods;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (goods) &#123;</span><br><span class="line">			System.out.println(<span class="string">"先给钱"</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (money) &#123;</span><br><span class="line">				System.out.println(<span class="string">"发货"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object goods;</span><br><span class="line">	<span class="keyword">private</span> Object money;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Object goods, Object money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.goods = goods;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (money) &#123;</span><br><span class="line">			System.out.println(<span class="string">"先发货"</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (goods) &#123;</span><br><span class="line">				System.out.println(<span class="string">"再给钱"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>诱发死锁的原因：</strong></p>
<ul>
<li>互斥条件【一定会存在，因为同步机制】</li>
<li>占用且等待</li>
<li>不可抢夺（或不可抢占）</li>
<li>循环等待</li>
</ul>
<p>以上4个条件，同时出现就会触发死锁。</p>
<p><strong>解决死锁：</strong>破坏2,3,4其中一个</p>
<p>死锁一旦出现，基本很难人为干预，只能尽量规避。可以考虑打破上面的诱发条件。</p>
<p>针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。</p>
<p>针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</p>
<p>针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</p>
<p>针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</p>
<h3 id="6-3-JDK5-0新特性：Lock-锁"><a href="#6-3-JDK5-0新特性：Lock-锁" class="headerlink" title="6.3 JDK5.0新特性：Lock(锁)"></a>6.3 JDK5.0新特性：Lock(锁)</h3><ul>
<li><p>JDK5.0的新增功能，保证线程的安全。与采用synchronized相比，Lock可提供多种锁方案，更灵活、更强大。Lock通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p>
</li>
<li><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
</li>
<li><p>在实现线程安全的控制中，比较常用的是<code>ReentrantLock</code>，可以显式加锁、释放锁。</p>
<ul>
<li>ReentrantLock类实现了 Lock 接口，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。</li>
</ul>
</li>
<li><p>Lock锁也称同步锁，加锁与释放锁方法，如下：</p>
<ul>
<li>public void lock() :加同步锁。</li>
<li>public void unlock() :释放同步锁。</li>
</ul>
</li>
<li><p>代码结构</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//2. 调动lock()，实现需共享的代码的锁定</span></span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//保证线程安全的代码;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果同步代码有异常，要将unlock()写入finally语句块。</p>
</blockquote>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//2. 调动lock()，实现需共享的代码的锁定</span></span><br><span class="line">				lock.lock();</span><br><span class="line">				<span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">10</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(ticket--);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">//3. 调用unlock()，释放共享代码的锁定</span></span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLock</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Window t = <span class="keyword">new</span> Window();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(t);	</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized与Lock的对比</strong></p>
<ol>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域、遇到异常等自动解锁</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。</li>
<li>（了解）Lock锁可以对读不加锁，对写加锁，synchronized不可以</li>
<li>（了解）Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以</li>
</ol>
<blockquote>
<p>说明：开发建议中处理线程安全问题优先使用顺序为：</p>
<p>•    Lock —-&gt; 同步代码块 —-&gt; 同步方法</p>
</blockquote>
<h2 id="7-线程的通信"><a href="#7-线程的通信" class="headerlink" title="7. 线程的通信"></a>7. 线程的通信</h2><h3 id="7-1-线程间通信"><a href="#7-1-线程间通信" class="headerlink" title="7.1 线程间通信"></a>7.1 线程间通信</h3><p><strong>为什么要处理线程间通信：</strong></p>
<p>当我们<code>需要多个线程</code>来共同完成一件任务，并且我们希望他们<code>有规律的执行</code>，那么多线程之间需要一些通信机制，可以协调它们的工作，以此实现多线程共同操作一份数据。</p>
<p>比如：线程A用来生产包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即—— <strong>等待唤醒机制。</strong></p>
<h3 id="7-2-等待唤醒机制"><a href="#7-2-等待唤醒机制" class="headerlink" title="7.2 等待唤醒机制"></a>7.2 等待唤醒机制</h3><p>这是多个线程间的一种<code>协作机制</code>。谈到线程我们经常想到的是线程间的<code>竞争（race）</code>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p>
<p>在一个线程满足某个条件时，就进入等待状态（<code>wait() / wait(time)</code>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 <code>notifyAll()</code>来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制。</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 <code>wait set</code> 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个<code>特别的动作</code>，也即“<code>通知（notify）</code>”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（<code>ready queue</code>）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>被通知的线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；</li>
<li>否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态</li>
</ul>
</blockquote>
<h3 id="7-3-举例"><a href="#7-3-举例" class="headerlink" title="7.3 举例"></a>7.3 举例</h3><p>例题：使用两个线程打印 1-100。线程1, 线程2 交替打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">replaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建实现类的对象</span></span><br><span class="line">        replace r=<span class="keyword">new</span> replace();</span><br><span class="line">        <span class="comment">//执行两个线程</span></span><br><span class="line">        <span class="comment">//4.执行start方法</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//4.执行start方法</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(r);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">replace</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  <span class="comment">//1.实现Runnable接口</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//2.重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                notify();  <span class="comment">//唤醒</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i++);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="comment">//会抛出异常要记得捕获异常</span></span><br><span class="line">                    wait();  <span class="comment">//等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-调用wait和notify需注意的细节"><a href="#7-4-调用wait和notify需注意的细节" class="headerlink" title="7.4 调用wait和notify需注意的细节"></a>7.4 调用wait和notify需注意的细节</h3><ol>
<li>wait方法与notify方法必须要由<code>同一个锁对象调用</code>。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在<code>同步代码块</code>或者是<code>同步函数</code>中使用。因为：必须要<code>通过锁对象</code>调用这2个方法。否则会报java.lang.IllegalMonitorStateException异常。</li>
</ol>
<h3 id="7-5-生产者与消费者问题"><a href="#7-5-生产者与消费者问题" class="headerlink" title="7.5 生产者与消费者问题"></a>7.5 生产者与消费者问题</h3><p>等待唤醒机制可以解决经典的“生产者与消费者”的问题。生产者与消费者问题（英语：Producer-consumer problem）/限缓冲问题（英语：Bounded-buffer problem），是一个<strong>多线程同步问题</strong>的经典案例。该问题描述了两个（多个）<code>共享固定大小缓冲区的线程</code>——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。</p>
<p>生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。<strong>该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</strong></p>
<p><strong>举例：</strong></p>
<p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p>
<p>类似的场景，比如厨师和服务员等。</p>
<p><strong>生产者与消费者问题中其实隐含了两个问题：</strong></p>
<ul>
<li>线程安全问题：因为生产者与消费者共享数据缓冲区，产生安全问题。不过这个问题可以使用同步解决。</li>
<li>线程的协调工作问题：<ul>
<li>要解决该问题，就必须让生产者线程在缓冲区<strong>满时等待(wait)</strong>，暂停进入阻塞状态，<strong>等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)</strong>正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区<strong>空时进入等待(wait)</strong>，暂停进入阻塞状态，<strong>等到生产者往缓冲区添加数据之后，再通知(notify)</strong>正在等待的线程恢复到就绪状态。</li>
</ul>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk=<span class="keyword">new</span> Clerk();</span><br><span class="line">        Producer p1=<span class="keyword">new</span> Producer(clerk);</span><br><span class="line">        p1.setName(<span class="string">"生产者1"</span>);</span><br><span class="line">        Consumer c1=<span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        c1.setName(<span class="string">"消费者1"</span>);</span><br><span class="line">        Consumer c2=<span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        c1.setName(<span class="string">"消费者2"</span>);</span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123; <span class="comment">//店员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum=<span class="number">0</span>; <span class="comment">//商品数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加产品数量方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addProduct</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  <span class="comment">//共享数据是productNum  所以要将方法改为同步方法</span></span><br><span class="line">        <span class="keyword">if</span>(productNum&gt;=<span class="number">20</span>)&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            productNum++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"生产了第"</span> + productNum + <span class="string">"个产品"</span>);</span><br><span class="line">            <span class="comment">//只要生产了一个那就唤醒消费者消费</span></span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减少产品数量方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">minusProduct</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="comment">//共享数据是productNum  所以要将方法改为同步方法</span></span><br><span class="line">        <span class="keyword">if</span>(productNum&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"消费了第"</span> + productNum + <span class="string">"个产品"</span>);</span><br><span class="line">            productNum--;</span><br><span class="line">            <span class="comment">//只要消费了一个那就唤醒生产者生产</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk=clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   <span class="comment">//生产</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者开始生产产品"</span>);</span><br><span class="line">            <span class="comment">//sleep一会吧</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消费产品</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clerk.addProduct();  <span class="comment">//生产商品</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  <span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk=clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   <span class="comment">//消费</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者开始消费产品"</span>);</span><br><span class="line">        <span class="comment">//sleep一会吧</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//消费产品</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clerk.minusProduct(); <span class="comment">//消费商品</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-6-面试题：区分sleep-和wait"><a href="#7-6-面试题：区分sleep-和wait" class="headerlink" title="7.6 面试题：区分sleep()和wait()"></a>7.6 面试题：区分sleep()和wait()</h3><p>相同点：一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。</p>
<p>不同点：</p>
<p> ① 定义方法所属的类：sleep():Thread中定义。  wait():Object中定义</p>
<p>② 使用范围的不同：sleep()可以在任何需要使用的位置被调用； wait():必须使用在同步代码块或同步方法中</p>
<p>③ 都在同步结构中使用的时候，是否释放同步监视器的操作不同：sleep():不会释放同步监视器 ;wait():会释放同步监视器</p>
<p>④ 结束等待的方式不同：sleep()：指定时间一到就结束阻塞。 wait():可以指定时间/无限等待直到notify或notifyAll。</p>
<h3 id="7-7-是否释放锁的操作"><a href="#7-7-是否释放锁的操作" class="headerlink" title="7.7 是否释放锁的操作"></a>7.7 是否释放锁的操作</h3><p>任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？</p>
<h4 id="7-7-1-释放锁的操作"><a href="#7-7-1-释放锁的操作" class="headerlink" title="7.7.1 释放锁的操作"></a>7.7.1 释放锁的操作</h4><p>当前线程的同步方法、同步代码块执行结束。</p>
<p>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</p>
<p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致当前线程异常结束。</p>
<p>当前线程在同步代码块、同步方法中执行了锁对象的wait()方法，当前线程被挂起，并释放锁。</p>
<h4 id="7-7-2-不会释放锁的操作"><a href="#7-7-2-不会释放锁的操作" class="headerlink" title="7.7.2 不会释放锁的操作"></a>7.7.2 不会释放锁的操作</h4><p>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行。</p>
<p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该该线程挂起，该线程不会释放锁（同步监视器）。</p>
<ul>
<li>应尽量避免使用suspend()和resume()这样的过时来控制线程。</li>
</ul>
<h2 id="8-JDK5-0新增线程创建方式"><a href="#8-JDK5-0新增线程创建方式" class="headerlink" title="8. JDK5.0新增线程创建方式"></a>8. JDK5.0新增线程创建方式</h2><h3 id="8-1-新增方式一：实现Callable接口"><a href="#8-1-新增方式一：实现Callable接口" class="headerlink" title="8.1 新增方式一：实现Callable接口"></a>8.1 新增方式一：实现Callable接口</h3><ul>
<li>与使用Runnable相比， Callable功能更强大些<ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值（需要借助FutureTask类，获取返回结果）</li>
</ul>
</li>
<li>Future接口（了解）<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutureTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
</li>
<li>缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。</li>
<li>代码举例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建多线程的方式三：实现Callable （jdk5.0新增的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      接收返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"总和为："</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-新增方式二：使用线程池"><a href="#8-2-新增方式二：使用线程池" class="headerlink" title="8.2 新增方式二：使用线程池"></a>8.2 新增方式二：使用线程池</h3><p><strong>现有问题：</strong></p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p><strong>思路：</strong>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<p><img src="https://raw.githubusercontent.com/Larkkkkkkk/hexo-picture/main/.images/202310212145582.jpg" alt="线程池的理解"></p>
<p><strong>好处：</strong></p>
<ul>
<li><p>提高响应速度（减少了创建新线程的时间）</p>
</li>
<li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
</li>
<li><p>便于线程管理</p>
<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>线程池相关API</strong></p>
<ul>
<li>JDK5.0之前，我们必须手动自定义线程池。<br>从JDK5.0开始，Java内置线程池相关的API。<br>在<strong>java.util.concurrent</strong>包下提供了线程池相关API：<code>ExecutorService</code> 和 <code>Executors</code>。</li>
<li><code>ExecutorService</code>：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li><code>void execute(Runnable command)</code> ：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般又来执行Callable</li>
<li><code>void shutdown()</code> ：关闭连接池</li>
</ul>
</li>
<li><code>Executors</code>：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。<ul>
<li><code>Executors.newCachedThreadPool()</code>：创建一个可<strong>根据需要</strong>创建新线程的线程池</li>
<li><code>Executors.newFixedThreadPool(int nThreads)</code>; 创建一个<strong>可重用固定线程数</strong>的线程池</li>
<li><code>Executors.newSingleThreadExecutor()</code> ：创建一个<strong>只有一个线程</strong>的线程池</li>
<li><code>Executors.newScheduledThreadPool(int corePoolSize)</code>：创建一个线程池，它可在<strong>延迟后运行命令/定期执行</strong>。</li>
</ul>
</li>
</ul>
<p><strong>代码举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> evenSum = <span class="number">0</span>;<span class="comment">//记录偶数的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                evenSum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evenSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;</span><br><span class="line"><span class="comment">//        //设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());//ThreadPoolExecutor</span></span><br><span class="line">        service1.setMaximumPoolSize(<span class="number">50</span>); <span class="comment">//设置线程池中线程数的上限</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread1());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future future = service.submit(<span class="keyword">new</span> NumberThread2());<span class="comment">//适合使用于Callable</span></span><br><span class="line">            System.out.println(<span class="string">"总和为："</span> + future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src=".images/image-20231020102356783.png" alt="image-20231020102356783"></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-List" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/02/List/" class="article-date">
      <time datetime="2019-11-02T08:27:43.000Z" itemprop="datePublished">2019-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/02/List/">List接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、List接口</strong><br> <code>java.util.List接口</code> <strong>extends</strong> <code>Collection接口</code></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>有序</strong>的集合(存储和取出元素的顺序一致)</li>
<li>有<strong>索引</strong>，包括了一些有索引的方法</li>
<li>存储<strong>重复</strong>的元素</li>
<li><strong>实现类</strong>：<br><strong>Arraylist</strong>(底层采用数组结构，查询快，增删慢),<br><strong>LinkedList</strong>(底层采用链表结构，查询慢,增删快),<br><strong>Vector</strong>(底层采用数组结构，查询快，增删慢)</li>
</ol>
<p><strong>举例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main extends Object&#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个List集合对象(多态)	</span><br><span class="line">		List&lt;String&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">		list.add(&quot;a&quot;);</span><br><span class="line">		list.add(&quot;b&quot;);</span><br><span class="line">		list.add(&quot;c&quot;);</span><br><span class="line">		list.add(&quot;d&quot;);</span><br><span class="line">		list.add(&quot;a&quot;);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(&quot;!!!!!!!!!!!!!!!!!!!&quot;);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;使用增强for循环</span><br><span class="line">		for(String i:list)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;!!!!!!!!!!!!!!!!!!!&quot;);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;使用迭代器</span><br><span class="line">		Iterator&lt;String&gt; lists&#x3D;set.iterator();</span><br><span class="line">		while(sets.hasNext()) </span><br><span class="line">		&#123;</span><br><span class="line">			String a&#x3D;lists.next();</span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br>[a, b, c, d, a]  <strong>(重复的a可以打印出来！！！)</strong><br>!!!!!!!!!!!!!!!!!!!<br>a<br>b<br>c<br>d<br>a<br>!!!!!!!!!!!!!!!!!!!<br>a<br>b<br>c<br>d<br>a</p>
<hr>
<p><strong><code>特定(索引)的方法：</code></strong></p>
<ol>
<li><code>public void add(int index,E element);</code>将指定元素<strong>添加</strong>到集合的指定位置</li>
<li><code>public E get(int index);</code><strong>返回</strong>指定位置元素</li>
<li><code>public E remove(int index);</code><strong>移除</strong>指定位置元素(返回被移除的元素)　　<strong>需要赋给一个变量</strong></li>
<li><code>public E set(int index,E element);</code><strong>替换</strong>指定位置元素(返回之前的元素)　　<strong>需要赋给一个变量</strong></li>
</ol>
<p><strong>举例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main extends Object&#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个List集合对象(多态)</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">		list.add(&quot;a&quot;);</span><br><span class="line">		list.add(&quot;b&quot;);</span><br><span class="line">		list.add(&quot;c&quot;);</span><br><span class="line">		list.add(&quot;d&quot;);</span><br><span class="line">		list.add(&quot;a&quot;);</span><br><span class="line">		System.out.println(list);  &#x2F;&#x2F;[a, b, c, d, a]</span><br><span class="line">	</span><br><span class="line">		&#x2F;&#x2F;public void add(int index,E element);  添加</span><br><span class="line">		list.add(3,&quot;woaini&quot;);  &#x2F;&#x2F;形参为给第几个位置添加什么字符串</span><br><span class="line">		System.out.println(list);  &#x2F;&#x2F;[a, b, c, woaini, d, a]</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;public E remove(int index);  移除(返回被移除的元素)</span><br><span class="line">		String yuanlai1&#x3D;list.remove(2);  &#x2F;&#x2F;形参是int型</span><br><span class="line">		System.out.println(&quot;被移除的是:&quot;+yuanlai1);  &#x2F;&#x2F;输出字符串必须要用&quot;+&quot;符号</span><br><span class="line">		System.out.println(list);  &#x2F;&#x2F;[a, b, woaini, d, a]</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;public E set(int index,E element);  替换(返回之前的元素)</span><br><span class="line">		String yuanlai2&#x3D;list.set(1, &quot;aa&quot;);</span><br><span class="line">		System.out.println(&quot;被替换的是:&quot;+yuanlai2);  &#x2F;&#x2F;输出字符串必须要用&quot;+&quot;符号</span><br><span class="line">		System.out.println(list);  &#x2F;&#x2F;[a, aa, woaini, d, a]</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;public E get(int index);  返回</span><br><span class="line">		String zhiding&#x3D;list.get(4);  &#x2F;&#x2F;5就会导致&quot;java.lang.IndexOutOfBoundsException&quot;异常</span><br><span class="line">		System.out.println(&quot;指定的是:&quot;+zhiding);  &#x2F;&#x2F;指定的是:a</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br>[a, b, c, d, a]<br>[a, b, c, woaini, d, a]<br>被移除的是:c<br>[a, b, woaini, d, a]<br>被替换的是:b<br>[a, aa, woaini, d, a]<br>指定的是:a</p>
<hr>
<p><strong>二、ArrayList集合(实现类)</strong><br>　　它的方法和List定义的基本一致(基本被用于接口的实现类)！</p>
<hr>
<p><strong>三、LinkedList集合</strong><br>　　LinkedList集合的底层结构是<strong>链表结构</strong>，方便元素的<strong>增、删、添、首尾操作</strong>。</p>
<p><strong>方法：</strong></p>
<ol>
<li>除了和List接口中的方法(<strong>继承</strong>)+特有的方法；</li>
<li><strong><code>特有(首尾操作)的方法：</code></strong><br>第一组：<br>  <code>void addFirst(E e);</code><br> <code>void addLast(E e);</code><br> 第二组(返回移除的元素)：<br> <code>E removeFirst();</code><br> <code>E removeLast();</code><br> 第三组(返回特定的元素)：<br> <code>E getFirst();</code><br> <code>E getLast();</code><br> 第四组：<br> <code>E pop();</code>  //弹出,删除集合中的第一个元素<br> <code>void push(E e);</code>//推入,往集合中增加一个元素</li>
</ol>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main extends Object&#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		LinkedList&lt;String&gt; list&#x3D;new LinkedList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;使用父类的添加方法</span><br><span class="line">		list.add(&quot;123&quot;);</span><br><span class="line">		list.add(&quot;WWW&quot;);</span><br><span class="line">		list.add(&quot;12SW&quot;);</span><br><span class="line">		System.out.println(list);  &#x2F;&#x2F;[123, WWW, 12SW]</span><br><span class="line">		System.out.println(&quot;!!!!!!!!!!!&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;使用LinkedList的特定方法添加</span><br><span class="line">		list.addFirst(&quot;ASD&quot;);  </span><br><span class="line">		list.addFirst(&quot;AHHAHAHA&quot;); &#x2F;&#x2F;[AHHAHAHA, ASD, 123, WWW, 12SW]  会不断地当第一个！！</span><br><span class="line">		System.out.println(list);  &#x2F;&#x2F;[AHHAHAHA, ASD, 123, WWW, 12SW]</span><br><span class="line">		System.out.println(&quot;!!!!!!!!!!!&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;删除元素</span><br><span class="line">		String shanchu&#x3D;list.removeFirst(); &#x2F;&#x2F;删除第一个AHHAHAHA</span><br><span class="line">		System.out.println(shanchu);</span><br><span class="line">		System.out.println(list); &#x2F;&#x2F;[ASD, 123, WWW, 12SW]</span><br><span class="line">		System.out.println(&quot;!!!!!!!!!!!&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取元素</span><br><span class="line">		String get&#x3D;list.getLast(); &#x2F;&#x2F;获取最后一个元素</span><br><span class="line">		System.out.println(get);  &#x2F;&#x2F;12SW</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(&quot;!!!!!!!!!!!&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;pop弹出</span><br><span class="line">		String pop&#x3D;list.pop();  &#x2F;&#x2F;弹出第一个元素</span><br><span class="line">		System.out.println(pop);  &#x2F;&#x2F;ASD</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(&quot;!!!!!!!!!!!&quot;);</span><br><span class="line">	</span><br><span class="line">		&#x2F;&#x2F;push推入</span><br><span class="line">		list.push(&quot;MAMMAMAM&quot;);</span><br><span class="line">		System.out.println(list);  &#x2F;&#x2F;[MAMMAMAM, 123, WWW, 12SW]</span><br><span class="line">		System.out.println(&quot;!!!!!!!!!!!&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong><br>添加了三个元素：<br>[123, WWW, 12SW]<br>!!!!!!!!!!!</p>
<p>通过addFirst添加了第一个元素<br>[AHHAHAHA, ASD, 123, WWW, 12SW]<br>!!!!!!!!!!!</p>
<p>通过removeFirst第一个元素<br>AHHAHAHA<br>[ASD, 123, WWW, 12SW]<br>!!!!!!!!!!!</p>
<p>通过getLast获取最后一个元素<br>12SW<br>[ASD, 123, WWW, 12SW]<br>!!!!!!!!!!!</p>
<p>通过pop弹出第一个元素<br>ASD<br>[123, WWW, 12SW]<br>!!!!!!!!!!!</p>
<p>通过push推入第一个元<br>[MAMMAMAM, 123, WWW, 12SW]<br>!!!!!!!!!!!</p>
<hr>
<p><strong>四、Vector<E>类</E></strong><br>　　jdk1.2(现在是1.9)之后被ArrayList类取代。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E9%9B%86%E5%90%88/" rel="tag">JAVA-集合</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Set" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/02/Set/" class="article-date">
      <time datetime="2019-11-02T05:54:38.000Z" itemprop="datePublished">2019-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/02/Set/">Set集合</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、Set集合的特点：</strong></p>
<ol>
<li>java.util.Set接口 <strong>extends</strong> Collection接口</li>
<li>不允许存储重复的元素</li>
<li>没有索引，没有带索引的方法，也不能使用普通的for循环。(<strong>和Collection接口方法一样</strong>)</li>
</ol>
<p><strong>二、java.util.HashSet<code>&lt;E&gt;</code></strong></p>
<ol>
<li>java.util.HashSet集合 <strong>implements</strong> Set接口</li>
<li>不允许存储重复的元素</li>
<li>没有索引，没有带索引的方法，必须使用增强for循环。(<strong>和Collection接口方法一样</strong>)</li>
<li>是一个<strong>无序</strong>的集合(存储元素和取出元素的顺序可能不同)</li>
<li>底层实现是一个<strong>哈希表结构</strong>(查询速度非常快)</li>
</ol>
<p><strong>举例说明不允许存储重复的元素：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		Set&lt;Integer&gt; set&#x3D;new HashSet&lt;&gt;();  &#x2F;&#x2F;生成一个set集合的对象</span><br><span class="line">		&#x2F;&#x2F;使用add方法   &#x2F;&#x2F;和Collection接口方法一样  </span><br><span class="line">		set.add(1);</span><br><span class="line">		set.add(2);</span><br><span class="line">		set.add(3);</span><br><span class="line">		set.add(1);</span><br><span class="line">			</span><br><span class="line">		&#x2F;&#x2F;使用迭代器;</span><br><span class="line">		Iterator&lt;Integer&gt; set2&#x3D;set.iterator();</span><br><span class="line">		while(set2.hasNext())  </span><br><span class="line">		&#123;</span><br><span class="line">			int s&#x3D;set2.next();</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;！！！！！！！！！！！&quot;);  &#x2F;&#x2F;分隔符，比较和增强for循环的区别</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;增强for循环</span><br><span class="line">		for(int i:set)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);   &#x2F;&#x2F;set为上面set集合的对象</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果分析</strong>：<br>1<br>2<br>3<br>！！！！！！！！！！！<br>1<br>2<br>3<br><strong>(没有出现第四个重复的元素1！！！)</strong></p>
<hr>
<p><strong>三、HashSet集合存储数据的结构(哈希表)</strong><br>　　<strong>哈希值：</strong>是<strong>一个十进制的整数</strong>，由系统<strong>随机</strong>给出(对象的地址值，是一个<strong>逻辑地址</strong>，是模拟出来的地址，不是数据实际存储的物理地址)。<br>　　在<strong>Object类</strong>有一个方法可以获取对象的哈希值：<strong>hashCode();</strong></p>
<p><code>hashCode方法的源码:</code><br><strong>public native int hashCode();</strong><br>native：代表该方法调用的是本地操作系统的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Main extends Object&#123;  &#x2F;&#x2F;写继承Object类更加明显看出是Object类的方法</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		Main i&#x3D;new Main();</span><br><span class="line">		int a&#x3D;i.hashCode(); &#x2F;&#x2F;调用方法</span><br><span class="line">		System.out.println(a); &#x2F;&#x2F;2018699554(逻辑地址)</span><br><span class="line">		</span><br><span class="line">		Main j&#x3D;new Main();</span><br><span class="line">		int b&#x3D;j.hashCode(); &#x2F;&#x2F;调用方法</span><br><span class="line">		System.out.println(b); &#x2F;&#x2F;1311053135(逻辑地址)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toString方法的源码:</code><br> <strong>return getClass().getName()+”@”+Integer.toHexString(hashCode());</strong>　　输出为“类名@十六进制数字”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Main extends Object &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		Main i&#x3D;new Main();</span><br><span class="line">		int a&#x3D;i.hashCode();</span><br><span class="line">		System.out.println(a); &#x2F;&#x2F;2018699554</span><br><span class="line">		</span><br><span class="line">		Main j&#x3D;new Main();</span><br><span class="line">		int b&#x3D;j.hashCode(); &#x2F;&#x2F;1311053135</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		</span><br><span class="line">		&#x2F;*toString方法的源码：</span><br><span class="line">		  return getClass().getName()+&quot;@&quot;+Integer.toHexString(hashCode());  &#x2F;&#x2F;“类名@十六进制数字”</span><br><span class="line">		*&#x2F;</span><br><span class="line">		System.out.println(i); &#x2F;&#x2F;Main@7852e922</span><br><span class="line">		System.out.println(j); &#x2F;&#x2F;Main@4e25154f</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>四、哈希表</strong><br>jdk1.8版本之<strong>前</strong>：<br>　　哈希表=数组+链表<br>jdk1.8版本之<strong>后</strong>：<br>　　哈希表=数组+链表<br>　　哈希表+数组+<strong>红黑树(提高查询速度)</strong><br><strong>数组结构</strong>：<strong>相同</strong>哈希值的元素<strong>分为一组</strong><br><strong>链表结构//红黑树</strong>：<strong>相同</strong>哈希值的元素<strong>连接一起</strong></p>
<p>步骤：</p>
<ol>
<li>将数据存储到集合中，先计算元素的哈希值。</li>
<li>然后按照哈希值将其放入不同的数组中，相同的就连接在一起。</li>
<li>如果连接的元素&gt;=8 —-<strong>链表-&gt;红黑树</strong>(一层红色结点，一层黑色结点)</li>
</ol>
<p><img src="/2019/11/02/Set/haxibiao.png" alt></p>
<hr>
<p><strong>五、Set集合存储元素不重复的原理</strong></p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main extends Object&#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">    HashSet&lt;String&gt; set&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">    String s1&#x3D;new String(&quot;abc&quot;);</span><br><span class="line">    String s2&#x3D;new String(&quot;abc&quot;);</span><br><span class="line">    set.add(s1);  &#x2F;&#x2F;会调用元素的hashCode方法和equals方法判断是否重复</span><br><span class="line">    set.add(s2);</span><br><span class="line">    set.add(&quot;重地&quot;);</span><br><span class="line">    set.add(&quot;通话&quot;);</span><br><span class="line">    set.add(&quot;abc&quot;);	</span><br><span class="line">		System.out.println(set);  &#x2F;&#x2F;只输出 [重地, 通话, abc]	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果分析</strong>:<br><code>set.add(s1);</code>　　<br>　　add方法调用s1的hashCode方法　-&gt;　计算字符串”abc”的哈希值(96354)　-&gt;　在集合中找是否有96354这个哈希值的元素　-&gt;　没有就把s1存储到集合中</p>
<p><code>set.add(s2);</code>　<br>　　add方法调用s2的hashCode方法　-&gt;　计算字符串”abc”的哈希值(96354)　-&gt;　在集合中找是否有96354这个哈希值的元素　-&gt;　有就是<strong>哈希冲突(值相同，元素不同)</strong>　-&gt;　调用s2.equals(s1)返回true 　-&gt;　不会将s2存储到集合中</p>
<p><code>set.add(&quot;重地&quot;);</code><br>　　add方法调用”重地”的hashCode方法　-&gt;　计算字符串”重地”的哈希值(1179395)　-&gt;　在集合中找是否有1179395这个哈希值的元素　-&gt;　没有就把”重地”存储到集合中</p>
<p><code>set.add(&quot;通话&quot;);</code><br>　　add方法调用”通话”的hashCode方法　-&gt;　计算字符串”通话”的哈希值(1179395)　-&gt;　在集合中找是否有1179395这个哈希值的元素　-&gt;　有就是<strong>哈希冲突(值相同，元素不同)</strong>　-&gt;　“通话”.equals(“重地”)返回false　-&gt;　将”通话”存储到集合中</p>
<hr>
<p><strong>六、HashSet存储自定义类型元素</strong></p>
<p>必须<strong>重写</strong>HashSet()和equals()方法。</p>
<hr>
<p><strong>七、LinkedHashSet<code>&lt;E&gt;</code></strong><br>LinkedHashSet集合(具有可预知的迭代顺序)　<strong>extends</strong>　HashSet集合(具有可预知的迭代顺序)</p>
<ol>
<li>底层实现是一个<strong>哈希表结构</strong>(查询速度非常快)</li>
<li>哈希表=数组+链表/红黑树+<strong>链表(记录元素的存储顺序)</strong></li>
</ol>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main extends Object&#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">	LinkedHashSet&lt;String&gt; set&#x3D;new LinkedHashSet&lt;&gt;();	</span><br><span class="line">	set.add(&quot;www&quot;);</span><br><span class="line">	set.add(&quot;abc&quot;);</span><br><span class="line">	set.add(&quot;abc&quot;);</span><br><span class="line">	set.add(&quot;itcast&quot;);</span><br><span class="line">	System.out.println(set);  &#x2F;&#x2F;输出[www, abc, itcast]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-Set%E9%9B%86%E5%90%88/" rel="tag">JAVA-Set集合</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/10/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
      <time datetime="2019-10-31T13:23:08.000Z" itemprop="datePublished">2019-10-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式(regex)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、正则表达式(所有编程语言支持)</strong><br>　　正则表达式：是一个<strong>字符串</strong>(“正则表达式内容”)</p>
<ul>
<li>普通字符串内容只是内容，而正则表达式的内容是规则</li>
<li>正则表达式用来匹配普通字符串　(boolean b=”普通字符串” 匹配”正则表达式”  )</li>
<li>代码实现：</li>
</ul>
<p><strong>String类</strong>中：<br>　　<strong>public boolean matches(String regex);</strong><br>    boolean b=”普通字符串”.matches(“正则表达式”);</p>
<ul>
<li>练习校验qq号码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">	   qq();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*QQ号码满足的规则:</span><br><span class="line">	*1.必须是0-9的数字</span><br><span class="line">	*2.开头必须是1-9的数字(没有0)</span><br><span class="line">	*3.位数必须是5-12位</span><br><span class="line">	*&#x2F;</span><br><span class="line">	public static void qq()</span><br><span class="line">	&#123;</span><br><span class="line">		String qq&#x3D;&quot;3457437467&quot;;  &#x2F;&#x2F;普通字符串</span><br><span class="line">		String regex&#x3D;(&quot;[1-9][0-9]&#123;4,11&#125;&quot;);  &#x2F;&#x2F;正则表达式  []表示一位的范围，&#123;X，Y&#125;表示从x到y位的数字范围。</span><br><span class="line">		boolean b&#x3D;qq.matches(regex);  &#x2F;&#x2F;使用matches方法</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>代码实现：</li>
</ul>
<p><strong>String类</strong>中：<br>　　<strong>public String[] split(String regex);</strong></p>
<ul>
<li>切割电话：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">	split01();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void split01() &#123;</span><br><span class="line">		String phone&#x3D; &quot;2345--4564----6546----------1345&quot;;</span><br><span class="line">		String[] phones&#x3D;phone.split(&quot;-+&quot;);  &#x2F;&#x2F;表示多个-字符。</span><br><span class="line">		for(int i&#x3D;0;i&lt;phones.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(phones[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li>“.”在正则表达式中表示任意字符</li>
<li>“+”在正则表达式中表示连续的多个字符</li>
</ol>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">JAVA-正则表达式</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-迭代器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/10/29/%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="article-date">
      <time datetime="2019-10-29T15:21:31.000Z" itemprop="datePublished">2019-10-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/29/%E8%BF%AD%E4%BB%A3%E5%99%A8/">集合2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>②Collection集合的迭代器对象：</strong><br>　　在根接口（无下标）中使用了一种公共的遍历方式：迭代器遍历（和下标无关）。<br>如图所示：<br><img src="/2019/10/29/%E8%BF%AD%E4%BB%A3%E5%99%A8/diedaiqi.png" alt></p>
<p><strong>注意点：</strong><br>　　<strong>Iterator的对象就是迭代器对象（仓库管理员）！只关心有人来仓库取数据或者存数据，判断有的话取走，没有的话报错。</strong><br>2. 一个集合的迭代器对象是集合自带的！<br>3. 对象.hasNext();—-判断有没有下一个元素<br>4. 对象.next();—-取出下一个元素<br>5. Iterator接口的实现类实现，3和4就是接口的其中两个常用方法。</p>
<p><strong>具体实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个集合对象(多态)</span><br><span class="line">		Collection&lt;String&gt; names&#x3D;new ArrayList&lt;String&gt;();</span><br><span class="line">		&#x2F;&#x2F;添加</span><br><span class="line">		names.add(&quot;郭德纲&quot;);</span><br><span class="line">		names.add(&quot;刘德华&quot;);</span><br><span class="line">		names.add(&quot;柳岩&quot;);</span><br><span class="line">		names.add(&quot;范伟&quot;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;获取names集合的迭代器对象</span><br><span class="line">		Iterator&lt;String&gt; it&#x3D;names.iterator(); &#x2F;&#x2F;要和上面集合元素String类型一致</span><br><span class="line">		&#x2F;&#x2F;标准代码(迭代器循环取值)：</span><br><span class="line">		while(it.hasNext())  &#x2F;&#x2F;判断有没有下一个元素－对象.hasNext();</span><br><span class="line">		&#123;</span><br><span class="line">		  String s&#x3D;it.next();  &#x2F;&#x2F;取出下一个元素－对象.next();</span><br><span class="line">		  System.out.println(s);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果：</strong><br>郭德纲<br>刘德华<br>柳岩<br>范伟</p>
<hr>
<p><strong>三、Iterator接口：</strong><br>　　该接口规定了<strong>迭代集合</strong>所需要的方法：<br>　　1. 对象.hasNext();—-判断有没有下一个元素<br>　　2. 对象.next();—-取出下一个元素
　　</p>
<hr>
<p><strong>四、并发修改异常(ConcurrentModificationException)</strong><br>　　使用<strong>Iterator对象/增强for循环</strong>遍历集合出现“itcast”字符串 -&gt; 向集合中增加一个“ITCAST(大写)”字符串</p>
<p><strong>举例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;定义一个集合</span><br><span class="line">		Collection&lt;String&gt; its&#x3D;new ArrayList&lt;String&gt;();</span><br><span class="line">		its.add(&quot;alibaba&quot;);</span><br><span class="line">		its.add(&quot;tenxun&quot;);</span><br><span class="line">		its.add(&quot;itcast&quot;); &#x2F;&#x2F;出现了小写的“itcast”字符串</span><br><span class="line">		its.add(&quot;baidu&quot;);</span><br><span class="line">		its.add(&quot;sohu&quot;);</span><br><span class="line">		its.add(&quot;netease&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;迭代器遍历集合</span><br><span class="line">		&#x2F;&#x2F;获取集合的迭代器对象</span><br><span class="line">		Iterator&lt;String&gt; it &#x3D;its.iterator();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;循环遍历</span><br><span class="line">		while(it.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">		    String itname&#x3D;it.next();</span><br><span class="line">		    if(&quot;itcast&quot;.equals(itname)) &#x2F;&#x2F;避免问题(常量在前面就不会有null的情况)</span><br><span class="line">		    &#123;	</span><br><span class="line">		    	its.add(&quot;ITCAST&quot;); &#x2F;&#x2F;通过集合去添加</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果：</strong><br>Exception in thread “main” <strong>java.util.ConcurrentModificationException</strong>(<strong>出现异常</strong>)<br>    at java.util.ArrayList$Itr.checkForComodification(Unknown Source)<br>    at java.util.ArrayList$Itr.next(Unknown Source)<br>    at Main.main(Main.java:21)</p>
<p><strong>分析Concurrent(并发)Modification(修改)Exception(异常)：</strong><br>　　JAVA规定，如果一个集合使用迭代器遍历，那么在遍历的过程中不允许修改集合的长度(add/clear/remove)。</p>
<hr>
<p>五、<strong>增强for循环（底层为迭代器）</strong></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;普通循环遍历数组</span><br><span class="line"> for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line"> &#123;</span><br><span class="line">System.out.println(a[i]);  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;增强for循环遍历数组</span><br><span class="line"> for(i:a)</span><br><span class="line"> &#123;</span><br><span class="line">System.out.println(i);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>　　遍历集合还是在<strong>使用迭代器遍历</strong>，那么在遍历的过程中不允许修改集合的长度(add/clear/remove)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;增强for循环遍历集合</span><br><span class="line">  Collection&lt;String&gt; names&#x3D;new ArrayList&lt;String&gt;();  &#x2F;&#x2F;定义</span><br><span class="line">		names.add(&quot;abc&quot;);	</span><br><span class="line">		names.add(&quot;jack&quot;);	</span><br><span class="line">		names.add(&quot;rose&quot;);	</span><br><span class="line">		names.add(&quot;tom&quot;);</span><br><span class="line">        &#x2F;&#x2F;循环遍历	</span><br><span class="line">		for(String name:names)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;	 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E9%9B%86%E5%90%88/" rel="tag">JAVA-集合</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-泛型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/10/29/%E6%B3%9B%E5%9E%8B/" class="article-date">
      <time datetime="2019-10-29T14:42:47.000Z" itemprop="datePublished">2019-10-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/29/%E6%B3%9B%E5%9E%8B/">泛型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、泛型(JDK1.5的一个新特性)</strong><br>　　泛泛的类型，<strong>不确定</strong>的类型，可以用应用于不同的类、接口、方法等。</p>
<p><strong>格式</strong>：</p>
<p>  <strong><code>&lt;E&gt;</code></strong></p>
<p>（E）只是一个类型符号，本质是一个变量，等待接收的是一种数据类型。</p>
<p><strong>1.使用泛型的好处</strong>：</p>
<ul>
<li>将运行时期的ClassCastException转换为编译时期的编译错误。</li>
<li>避免类型强转的麻烦。</li>
</ul>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		demo01();</span><br><span class="line">		demo02();	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;不使用泛型(不写&lt;E&gt;)</span><br><span class="line">	public static void demo01() &#123;</span><br><span class="line">		ArrayList names&#x3D;new ArrayList();</span><br><span class="line">		names.add(123);</span><br><span class="line">		names.add(true);</span><br><span class="line">		names.add(&quot;asd&quot;);</span><br><span class="line">		</span><br><span class="line">		for(Object i:names)</span><br><span class="line">		&#123;</span><br><span class="line">			String s&#x3D;(String)i;  &#x2F;&#x2F;强制类型转换</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;使用泛型</span><br><span class="line">	public static void demo02() &#123;</span><br><span class="line">		ArrayList&lt;String&gt; names&#x3D;new ArrayList&lt;String&gt;();　　&#x2F;&#x2F;使用泛型进行创建</span><br><span class="line">		names.add(&quot;123&quot;);</span><br><span class="line">		names.add(&quot;asded0&quot;);</span><br><span class="line">		names.add(&quot;asd&quot;);</span><br><span class="line"></span><br><span class="line">		for(String i:names)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果分析：</strong><br>执行demo01()方法：<br><strong>不使用泛型的话，编译时期没有错误，但是执行就会报错。</strong><br>　　Exception in thread “main” <strong>java.lang.ClassCastException</strong>: java.lang.Integer cannot be cast to java.lang.String<br>    at Main.demo01(Main.java:17)<br>    at Main.main(Main.java:4)</p>
<p>执行demo02()方法：<br><strong>使用泛型(<E>)的话，可以将其转换到编译时期出错。</E></strong><br>　　123<br>　　asded0<br>　　asd</p>
<p>扩展：<br>可以使用<strong>迭代器</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		demo01();	</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;使用迭代器</span><br><span class="line">	public static void demo01() &#123;</span><br><span class="line">		ArrayList&lt;String&gt; names&#x3D;new ArrayList&lt;String&gt;(); &#x2F;&#x2F;定义names对象</span><br><span class="line">		names.add(&quot;123&quot;);   &#x2F;&#x2F;使用add方法</span><br><span class="line">		names.add(&quot;asded0&quot;);</span><br><span class="line">		names.add(&quot;asd&quot;);		</span><br><span class="line">	   Iterator&lt;String&gt; s&#x3D;names.iterator(); &#x2F;&#x2F;对象生成迭代器</span><br><span class="line">	   while(s.hasNext())  &#x2F;&#x2F;判断是否由下一个</span><br><span class="line">	   &#123;</span><br><span class="line">		   String a&#x3D;s.next();  &#x2F;&#x2F;当前位置的值传给a</span><br><span class="line">		   System.out.println(a); &#x2F;&#x2F;输出a然后指针自动后移下一个</span><br><span class="line">	   &#125;	   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>二、泛型类</strong><br>格式：<br>**    　　public class 类名<code>&lt;E&gt;</code><br>**<br>　注：当你创建类对象的时候，会确定对应的E是那个类型，增加了你的多项选择！</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个Person</span><br><span class="line">		Person p&#x3D;new Person();</span><br><span class="line">		p.setAaa(&quot;123&quot;);  &#x2F;&#x2F;报错（只有int可以）		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person&#123;</span><br><span class="line">	E aaa;</span><br><span class="line">	public int getAaa() &#123;</span><br><span class="line">		return aaa;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int setAaa(int aaa) &#123;</span><br><span class="line">		this.aaa &#x3D; aaa;</span><br><span class="line">	&#125;	</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　如果这样，p。setAaa方法会报错，因为set方法要返回的是int型，而我定义的p对象调用方法给的是String类型的，会报错。</p>
<p><strong>使用泛型类：</strong><br><strong>1. Person后面加一个<code>&lt;E&gt;</code></strong><br><strong>2. 然后将set和get方法返回值都改为E</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public  static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个Person</span><br><span class="line">		Person p&#x3D;new Person();</span><br><span class="line">		p.setAaa(&quot;123&quot;); </span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建一个Person&lt;E&gt;  </span><br><span class="line">		Person&lt;String&gt; pp&#x3D;new Person&lt;String&gt;;</span><br><span class="line">		pp.setAaa(&quot;ASD&quot;);  &#x2F;&#x2F;可以设置String的</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;创建一个Person&lt;E&gt;</span><br><span class="line">		Person&lt;Integer&gt; pp&#x3D;new Person&lt;Integer&gt;;</span><br><span class="line">		pp.setAaa(123);   &#x2F;可以设置int的</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person&lt;E&gt;&#123;</span><br><span class="line">	E aaa;</span><br><span class="line"></span><br><span class="line">	public E getAaa() &#123;</span><br><span class="line">		return aaa;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setAaa(E aaa) &#123;</span><br><span class="line">		this.aaa &#x3D; aaa;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>三、泛型方法(少用)</strong><br>格式：<br>**    　　public <code>&lt;T&gt;</code>  返回值类型  方法名(T t);<br>**<br>　注：当你调用方法，传递参数的时候确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Main方法调用</span><br><span class="line">Person&lt;String&gt; pp2&#x3D;new Person&lt;String&gt;();</span><br><span class="line">		pp2.show(&quot;asd&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Person类里面的一个泛型方法：</span><br><span class="line">public &lt;T&gt; void show(T t) &#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>四、泛型接口</strong><br>格式：<br>**    　　public interface 接口名  <code>&lt;E&gt;</code><br>**</p>
<ol>
<li>当子类实现接口时候，确定接口的泛型。</li>
<li>当子类实现接口时候，还是不确定泛型，把接口的泛型继续实现下来（就跟抽象类一样，如果实现类没有覆盖重写所有的抽象方法，那么继续让它的实现类实现）</li>
</ol>
<hr>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E6%B3%9B%E5%9E%8B/" rel="tag">JAVA-泛型</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-蓝桥杯练习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/" class="article-date">
      <time datetime="2019-10-26T15:08:52.000Z" itemprop="datePublished">2019-10-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/">蓝桥杯</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>　　小目标：从今天开始争取每天做一道蓝桥杯题目(用JAVA做！)，希望今年能够进国赛！！！</p>
<p>一、<strong>矩阵相乘（去年校赛卡住的题目）</strong><br><strong>问题描述</strong><br>　　给定一个N阶矩阵A，输出A的M次幂（M是非负整数）<br>　　例如：<br>　　A =<br>　　1 2<br>　　3 4<br>　　A的2次幂<br>　　7 10<br>　　15 22<br>　　输入格式<br>　　第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数<br>　　接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值<br>　　输出格式<br>　　输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开<br>　　样例输入<br>　　2 2<br>　　1 2<br>　　3 4<br>　　样例输出<br>　　7 10<br>　　15 22</p>
<p><strong>思路</strong>：<br>　　我先定义两个数组，a数组用来存放一开始的值，然后通过定义num不断地将更新的值放入后面的t数组之中，就可以减少不断的用新的数组去存旧数组的值，保证减少算法时间和空间复杂度。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Collection &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">       int n&#x3D;input.nextInt(); &#x2F;&#x2F;定义矩阵的行和列</span><br><span class="line">       int m&#x3D;input.nextInt(); &#x2F;&#x2F;定义矩阵乘方次数</span><br><span class="line">       int[][] a&#x3D;new int[n][n]; &#x2F;&#x2F;定义原始数组</span><br><span class="line">       for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           for(int j&#x3D;0;j&lt;n;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               a[i][j] &#x3D; input.nextInt(); &#x2F;&#x2F;输入数组元素</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        int[][] t&#x3D;new int[n][n]; &#x2F;&#x2F;最终存放的数组</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                int num&#x3D;0;</span><br><span class="line">                for(int k&#x3D;0;k&lt;n;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    num+&#x3D;a[i][k]*a[k][j]; &#x2F;&#x2F;利用矩阵相乘原理得到新的数组所对应的位置的值</span><br><span class="line">                &#125;</span><br><span class="line">                t[i][j]&#x3D;num; &#x2F;&#x2F;将相乘结果传给数组t</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                    System.out.print(t[i][j]+&quot; &quot;); </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(); &#x2F;&#x2F;保证每行分割</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下</strong>：<br><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/juzhenxiangcheng.png" alt></p>
<hr>
<p>二、<strong>斐波拉契数列(基础题)</strong><br><strong>问题描述</strong><br>　　Fn除以10007的余数是多少。<br>　　说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。<br>　　样例1输入<br>　　10<br>　　样例1输出<br>　　55<br>　　样例2输入<br>　　22<br>　　样例2输出<br>　　7704　<br>　　数据规模与约定<br>1 &lt;= n &lt;= 1,000,000。</p>
<p><strong>思路：</strong><br>①<strong>递归(不推荐)</strong>：<br>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。<br><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Collection &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">       int n&#x3D;input.nextInt();</span><br><span class="line">       int[] a&#x3D;new int[n];</span><br><span class="line">       a[1]&#x3D;a[2]&#x3D;1;</span><br><span class="line">       int m&#x3D;feibo(n)%10007;  &#x2F;&#x2F;最终的值除以10007求余数</span><br><span class="line">        System.out.println(m);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int  feibo(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)  &#x2F;&#x2F;前两个的值需要给出，才能依次算出后面的值</span><br><span class="line">            return 1;</span><br><span class="line">        else</span><br><span class="line">            return (feibo(n-1)+feibo(n-2));  &#x2F;&#x2F;递归主要思路</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下:</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/feibo.png" alt></p>
<p>②<strong>动态规划</strong>：<br>动态规划和递归有很大的相同处，但是动态规划而言，起码性能很高，不会出现提交代码系统超时的问题，而且很容易想到和实现。<br>将前两项赋值为1，然后从第三项开始是前两项加，假设算前三项，第一项为l，第二项为r，第三项为l+r。然后要计算第四项的时候，我们需要将第二项的r就成了计算第四项的l，那么第三项的sum就成了第四项计算时候的r，因此不断地替换计算，动态规划的思路就是往前推，求上一个结果的答案，然后依次推出接下来答案的结果。<br><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Collection &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">       Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">       int n&#x3D;input.nextInt();</span><br><span class="line">       int[] a&#x3D;new int[n];</span><br><span class="line">       int m&#x3D;feibo(n-1,a)%10007;  &#x2F;&#x2F;题目要求对10007取余</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int  feibo(int n,int[] a)&#123;</span><br><span class="line">        int l&#x3D;1,r&#x3D;1,sum&#x3D;0;</span><br><span class="line">        if(n&lt;&#x3D;1)</span><br><span class="line">            return n;</span><br><span class="line">           for(int i&#x3D;2;i&lt;&#x3D;n;i++)</span><br><span class="line">           &#123;</span><br><span class="line">               sum&#x3D;l+r;  &#x2F;&#x2F;前两项之和</span><br><span class="line">                l&#x3D;r;   &#x2F;&#x2F;将现在的第二项变成计算下一项的左边值</span><br><span class="line">               r&#x3D;sum;  &#x2F;&#x2F;将现在的和变成计算下一项的右边值</span><br><span class="line">           &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下:</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/feibo.png" alt></p>
<hr>
<p><strong>三、字母图形</strong><br><strong>问题描述</strong><br>　　利用字母可以组成一些美丽的图形，下面给出了一个例子：<br>　　ABCDEFG<br>　　BABCDEF<br>　　CBABCDE<br>　　DCBABCD<br>　　EDCBABC<br>这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。<br>　　<br>输入格式<br>　　输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。<br>输出格式<br>　　输出n行，每个m个字符，为你的图形。<br>　　<br>　　样例输入<br>　　5 7<br>　　样例输出<br>　　ABCDEFG<br>　　BABCDEF<br>　　CBABCDE<br>　　DCBABCD<br>　　EDCBABC<br>数据规模与约定<br>1 &lt;= n, m &lt;= 26。</p>
<p><strong>思路：</strong><br> 　　肯定需要使用二维数组去存放最后的字母图形，使用二重循环去遍历每一个位置。通过规律可以得到只要i和j的差的绝对值为哪个数就对应字母表中和A的差距位置，因此<strong>利用数组下标</strong>去判断绝对值为1就输出B，2就输出C，以此类推。<br>　　假设i为2，j为3：<br>　　则判断a[2][3]的位置存放的应该就是 2-3的绝对值为1所以存放B。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        int n&#x3D;input.nextInt();</span><br><span class="line">        int m&#x3D;input.nextInt();</span><br><span class="line">        int[][] a&#x3D;new int[n][m];</span><br><span class="line">        char[] b&#x3D;&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;U&#39;,&#39;V&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;&#125;;  &#x2F;&#x2F;用下标方便的放入相对于的值</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                int c&#x3D;i-j;  &#x2F;&#x2F;求下标之差（可能有负数）</span><br><span class="line">              int d&#x3D;(Math.abs(c))%26;  &#x2F;&#x2F;求下标之差的绝对值（如果大于26行就需要求余）</span><br><span class="line">              System.out.print(b[d]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/zumutuxing.png" alt></p>
<p><strong>编程出现的问题：</strong></p>
<ol>
<li>定义26个字母的数组的时候写错了，导致只有百分之30的准确性。</li>
<li>这个题目限制了行数为26，但是如果行数太多的话下标的d就需要对26取余数(int d=(Math.abs(c))%26;)。</li>
<li>输出格式之间没有空格，当时打了空格，只有百分之10的准确性。</li>
</ol>
<hr>
<p><strong>四、十进制转十六进制</strong><br><strong>问题描述</strong><br>　　十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。<br>　　给出一个非负整数，将它表示成十六进制的形式。<br>输入格式<br>　　输入包含一个非负整数a，表示要转换的数。0&lt;=a&lt;=2147483647<br>输出格式<br>　　输出这个整数的16进制表示<br>样例输入<br>30<br>样例输出<br>1E</p>
<p><strong>思路：</strong><br>不再像c语言那样手写，我们可以考虑直接通过使用<strong>toHexString()方法</strong>转换成十六进制、使用<strong>toUpperCase()方法</strong>将小写字母转换为大写字母。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);  </span><br><span class="line">        long n&#x3D;input.nextLong();  &#x2F;&#x2F;定义了一个long型的数字</span><br><span class="line">        System.out.printf(Long.toHexString(n).toUpperCase());  &#x2F;&#x2F;转换为十六进制数并且为大写字母</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p>！<a href="shizhuanshiliu.png"></a></p>
<hr>
<p><strong>五、十六进制转十进制</strong><br><strong>问题描述</strong><br>　　从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。<br>　　注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。<br>样例输入<br>FFFF<br>样例输出<br>65535</p>
<p><strong>思路：</strong><br>    利用JAVA中<strong>parseLong(要被转换的数,被转换的数位几进制)方法</strong>。<br>  例如要将16进制的FFFF转换就需要输入n=FFFF然后调用praseLong函数(num,16)。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        String num&#x3D;input.nextLine();</span><br><span class="line">        Long da&#x3D;Long.parseLong(num,16);</span><br><span class="line">        System.out.println(da);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong></p>
<p>！<a href="shiliuzhuanshi.png"></a></p>
<hr>
<p><strong>六、集合运算</strong><br><strong>问题描述</strong><br>给出两个整数集合A、B，求出他们的交集、并集以及B在A中的余集。<br>输入格式<br>　　第一行为一个整数n，表示集合A中的元素个数。<br>　　第二行有n个互不相同的用空格隔开的整数，表示集合A中的元素。<br>　　第三行为一个整数m，表示集合B中的元素个数。<br>　　第四行有m个互不相同的用空格隔开的整数，表示集合B中的元素。<br>　　集合中的所有元素均为int范围内的整数，n、m&lt;=1000。<br>输出格式<br>　　第一行按从小到大的顺序输出A、B交集中的所有元素。<br>　　第二行按从小到大的顺序输出A、B并集中的所有元素。<br>　　第三行按从小到大的顺序输出B在A中的余集中的所有元素。<br>样例输入<br>5<br>1 2 3 4 5<br>5<br>2 4 6 8 10<br>样例输出<br>2 4<br>1 2 3 4 5 6 8 10<br>1 3 5<br>样例输入<br>4<br>1 2 3 4<br>3<br>5 6 7<br>样例输出<br>1 2 3 4 5 6 7<br>1 2 3 4</p>
<p><strong>思路：</strong><br>　　一开始没想到集合!!想着暴力循环找到的相同的就是交集，然后A里面有的B没有的就是差集，并就是A和差集之和。<br>　　最后看大佬的思路才发现用<strong>集合</strong>，我选择使用<code>Set集合</code>(set存放的是不重复的元素)。</p>
<ol>
<li><code>add()</code>增加元素</li>
<li><code>retain（）</code>求交集</li>
<li><code>remove</code>求差集</li>
<li><code>add两次</code>求并集(存放不重复的元素！)</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	  Set&lt;Integer&gt; result&#x3D;new HashSet&lt;Integer&gt;();&#x2F;&#x2F;存放最终结果</span><br><span class="line">	  Set&lt;Integer&gt; set1&#x3D;new HashSet&lt;Integer&gt;();&#x2F;&#x2F;第一个</span><br><span class="line">	  Set&lt;Integer&gt; set2&#x3D;new HashSet&lt;Integer&gt;();&#x2F;&#x2F;第二个</span><br><span class="line">	  int n&#x3D;input.nextInt();&#x2F;&#x2F;输入第一个集合的长度</span><br><span class="line">	  for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	  &#123;</span><br><span class="line">		  set1.add(input.nextInt());&#x2F;&#x2F;add输入集合的元素</span><br><span class="line">	  &#125;</span><br><span class="line">	  int m&#x3D;input.nextInt(); &#x2F;&#x2F;输入第二个集合的长度</span><br><span class="line">	  for (int i &#x3D; 0; i &lt; m; i++) </span><br><span class="line">	  &#123;	 </span><br><span class="line">		  set2.add(input.nextInt());&#x2F;&#x2F;add输入集合的元素</span><br><span class="line">	  &#125;  </span><br><span class="line">	  </span><br><span class="line">	  result.clear();   &#x2F;&#x2F;清空结果集合</span><br><span class="line">	  result.addAll(set1);&#x2F;&#x2F;将第一个集合的元素放进去</span><br><span class="line">	  result.retainAll(set2);&#x2F;&#x2F;retain求两个的交集</span><br><span class="line">	  System.out.println(&quot;交集 &#x3D; &quot; + result);</span><br><span class="line">	  </span><br><span class="line">      result.clear();&#x2F;&#x2F;清空(为下一个要求服务)</span><br><span class="line">      result.addAll(set1);&#x2F;&#x2F;将第一个集合的元素放进去</span><br><span class="line">      result.addAll(set2);&#x2F;&#x2F;将第二个集合的元素放进去(不会把重复的放进去)</span><br><span class="line">      System.out.println(&quot;并集 &#x3D; &quot; + result);</span><br><span class="line">      </span><br><span class="line">	  result.clear();&#x2F;&#x2F;清空(防止上面的过程干扰)</span><br><span class="line">      result.addAll(set1);&#x2F;&#x2F;将第一个集合的元素放进来</span><br><span class="line">      result.removeAll(set2);&#x2F;&#x2F;将相同的元素排除掉</span><br><span class="line">      System.out.println(&quot;差集 &#x3D; &quot;+result);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/jihe.png" alt></p>
<ul>
<li>因为这个题目需要让集合中的元素一个一个输出，因此需要<strong>增强for循环</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	  result.clear();   &#x2F;&#x2F;清空结果集合</span><br><span class="line">	  result.addAll(set1);&#x2F;&#x2F;将第一个集合的元素放进去</span><br><span class="line">	  result.retainAll(set2);&#x2F;&#x2F;retain求两个的交集</span><br><span class="line">	  </span><br><span class="line">      for(int i:result)</span><br><span class="line">      System.out.print(i+&quot; &quot;);</span><br><span class="line"></span><br><span class="line">      System.out.println();</span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">      result.clear();&#x2F;&#x2F;清空(为下一个要求服务)</span><br><span class="line">      result.addAll(set1);&#x2F;&#x2F;将第一个集合的元素放进去</span><br><span class="line">      result.addAll(set2);&#x2F;&#x2F;将第二个集合的元素放进去(不会把重复的放进去)</span><br><span class="line">      </span><br><span class="line">      for(int i:result)</span><br><span class="line">      System.out.print(i+&quot; &quot;);</span><br><span class="line"></span><br><span class="line">      System.out.println();</span><br><span class="line">	  </span><br><span class="line">      </span><br><span class="line">	  result.clear();&#x2F;&#x2F;清空(防止上面的过程干扰)</span><br><span class="line">      result.addAll(set1);&#x2F;&#x2F;将第一个集合的元素放进来</span><br><span class="line">      result.removeAll(set2);&#x2F;&#x2F;将相同的元素排除掉</span><br><span class="line">      </span><br><span class="line">	  for(int i:result)</span><br><span class="line">      System.out.print(i+&quot; &quot;);</span><br><span class="line"></span><br><span class="line">      System.out.println();</span><br><span class="line">	  </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/jihe2.png" alt></p>
<hr>
<p><strong>七、报时助手</strong><br><strong>问题描述</strong><br>　　给定当前的时间，请用英文的读法将它读出来。<br>　　时间用时h和分m表示，在英文的读法中，读一个时间的方法是：<br>　　如果m为0，则将时读出来，然后加上“o’clock”，如3:00读作“three o’clock”。<br>　　如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。<br>　　时和分的读法使用的是英文数字的读法，其中0~20读作：<br>　　0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen, 15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。<br>　　30读作thirty，40读作forty，50读作fifty。<br>　　对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。<br>　　按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。<br>输入格式<br>　　输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。<br>输出格式<br>　　输出时间时刻的英文。<br>样例输入<br>0 15<br>样例输出<br>zero fifteen</p>
<p><strong>思路：</strong><br>　　分为判断分钟是否为0的情况：如果为0就直接判断小时输出“小时+o’clock”；如果不为0就要分为判断小时和分钟然后依次输出。主要是提前要用String数组分别存放好0-20 和 20 30 40 50的英文字母。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class ReflectTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;用a和b的字符串数组存放时刻时间</span><br><span class="line">		String a[]&#x3D;&#123;&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;,&quot;ten&quot;,&quot;eleven&quot;,&quot;twelve&quot;,&quot;thirteen&quot;,&quot;fourteen&quot;,&quot;fifteen&quot;,&quot;sixteen&quot;,&quot;seventeen&quot;,&quot;eighteen&quot;,&quot;nineteen&quot;,&quot;twenty&quot;&#125;;</span><br><span class="line">		String b[]&#x3D;&#123;&quot;twenty&quot;,&quot;thirty&quot;,&quot;forty&quot;,&quot;fifty&quot;&#125;;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;设置h和m为输入的分钟和小时数</span><br><span class="line">		Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">		int h&#x3D;input.nextInt();</span><br><span class="line">		int m&#x3D;input.nextInt();</span><br><span class="line">		</span><br><span class="line">		if(m&#x3D;&#x3D;0)&#x2F;&#x2F;如果分钟为0的话就是只有小时 后面加o&#39;clock</span><br><span class="line">		&#123;</span><br><span class="line">			switch(h&#x2F;10)&#x2F;&#x2F;判断输出</span><br><span class="line">			&#123;</span><br><span class="line">			case 0:System.out.println(a[h%10]+&quot; &quot;+&quot;o&#39;clock&quot;);break; &#x2F;&#x2F;直接在a数组找</span><br><span class="line">			case 1:System.out.println(a[h]+&quot; &quot;+&quot; &quot;+&quot;o&#39;clock&quot;);break;&#x2F;&#x2F;直接在a数组找</span><br><span class="line">			case 2:System.out.println(b[0]+&quot; &quot;+a[h%10]+&quot; &quot;+&quot;o&#39;clock&quot;);break; &#x2F;&#x2F;twenty+个位的</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			switch(h&#x2F;10)&#x2F;&#x2F;和if条件里面的相同</span><br><span class="line">			&#123;</span><br><span class="line">			case 0:System.out.print(a[h%10]);break;</span><br><span class="line">			case 1:System.out.print(a[h]);break;</span><br><span class="line">			case 2:System.out.print(b[0]+&quot; &quot;+a[h%10]);break;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			switch(m&#x2F;10)</span><br><span class="line">			&#123;</span><br><span class="line">			case 0:System.out.print(&quot; &quot;+a[m%10]);break;</span><br><span class="line">			case 1:System.out.print(&quot; &quot;+a[m]);break;&#x2F;&#x2F;直接在a数组找</span><br><span class="line">			case 2:System.out.print(&quot; &quot;+b[0]+&quot; &quot;+a[m%10]);break;</span><br><span class="line">			case 3:System.out.print(&quot; &quot;+b[1]+&quot; &quot;+a[m%10]);break;</span><br><span class="line">			case 4:System.out.print(&quot; &quot;+b[2]+&quot; &quot;+a[m%10]);break;</span><br><span class="line">			case 5:System.out.print(&quot; &quot;+b[3]+&quot; &quot;+a[m%10]);break;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;	</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>八、集合运算</strong><br><strong>问题描述</strong><br>给出两个整数集合A、B，求出他们的交集、并集以及B在A中的余集。<br>输入格式<br>第一行为一个整数n，表示集合A中的元素个数。<br>第二行有n个互不相同的用空格隔开的整数，表示集合A中的元素。<br>第三行为一个整数m，表示集合B中的元素个数。<br>第四行有m个互不相同的用空格隔开的整数，表示集合B中的元素。<br>集合中的所有元素均为int范围内的整数，n、m&lt;=1000。<br>输出格式<br>第一行按从小到大的顺序输出A、B交集中的所有元素。<br>第二行按从小到大的顺序输出A、B并集中的所有元素。<br>第三行按从小到大的顺序输出B在A中的余集中的所有元素。<br>样例输入<br>5<br>1 2 3 4 5<br>5<br>2 4 6 8 10<br>样例输出<br>2 4<br>1 2 3 4 5 6 8 10<br>1 3 5<br>样例输入<br>4<br>1 2 3 4<br>3<br>5 6 7<br>样例输出<br>1 2 3 4 5 6 7<br>1 2 3 4</p>
<p><strong>解题思路：</strong><br>　　本来打算使用数组去做，发现一排序之后相同的数字不一样在一个位置而且比较麻烦。所以我选择了用<strong>集合(TreeSet)</strong><br>–&gt;<strong>交集</strong>：使用一个tempA复制了a-&gt;然后用a移除所有b中和a相同的，然后用tempA把剩下的移除之后就剩下交集。<br>–&gt;<strong>并集</strong>：使用addALL(b)就可以吧不重复的b放进去<br>–&gt;<strong>差集</strong>：使用removeALL(b)把A和B相同的移过以外的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package lianxi;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	TreeSet&lt;Integer&gt; treeSetA&#x3D;new TreeSet&lt;Integer&gt;();&#x2F;&#x2F;第一个集合A</span><br><span class="line">	int n&#x3D;input.nextInt();</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		treeSetA.add(input.nextInt());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	TreeSet&lt;Integer&gt; treeSetB&#x3D;new TreeSet&lt;Integer&gt;();&#x2F;&#x2F;第二个集合B</span><br><span class="line">	int m&#x3D;input.nextInt();</span><br><span class="line">	for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		treeSetB.add(input.nextInt());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	input.close();</span><br><span class="line">	printDivide(treeSetA, treeSetB);</span><br><span class="line">    printAdd(treeSetA, treeSetB);</span><br><span class="line">    printRemain(treeSetA, treeSetB);</span><br><span class="line">&#125;</span><br><span class="line">	public static void printDivide(TreeSet&lt;Integer&gt; a,TreeSet&lt;Integer&gt; b) </span><br><span class="line">	&#123;</span><br><span class="line">			TreeSet&lt;Integer&gt; tempA&#x3D;(TreeSet&lt;Integer&gt;) a.clone();&#x2F;&#x2F;第三个集合是复制a集合的</span><br><span class="line">			a.removeAll(b);</span><br><span class="line">			tempA.removeAll(a);</span><br><span class="line">			for (int i : tempA) &#123;</span><br><span class="line">	            System.out.print(i + &quot; &quot;);</span><br><span class="line">	        &#125;</span><br><span class="line">	        System.out.println();</span><br><span class="line">	 &#125;</span><br><span class="line">	</span><br><span class="line">	public static void printAdd(TreeSet&lt;Integer&gt; a,TreeSet&lt;Integer&gt; b)</span><br><span class="line">	&#123;</span><br><span class="line">		a.addAll(b);</span><br><span class="line">		for(int i:a)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(i+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	public static void printRemain(TreeSet&lt;Integer&gt; a, TreeSet&lt;Integer&gt; b) </span><br><span class="line">	&#123;</span><br><span class="line">        a.removeAll(b);</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.print(i + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码结果如下：</p>
<p>！<a href="jiheyunsuan.png"></a></p>
<hr>
<p><strong>九、大等于n的最小完全平方数 **<br>**问题描述</strong><br>　　输出大等于n的最小的完全平方数。<br>　　若一个数能表示成某个自然数的平方的形式，则称这个数为完全平方数<br>　　Tips：注意数据范围<br>输入格式<br>　　一个整数n<br>输出格式<br>　　大等于n的最小的完全平方数<br>样例输入<br>71711<br>样例输出<br>71824<br>数据规模和约定<br>　　n是32位有符号整数</p>
<p><strong>思路：</strong><br>　　这道题目主要是将n先分为小于等于0和大于0的数两类，小于等于0的数最小的完全平方数就是0；而大于等于0的数需要让x转换成long型去比对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	int n&#x3D;input.nextInt();</span><br><span class="line">	double x&#x3D;Math.sqrt(n);&#x2F;&#x2F;取double类型的x</span><br><span class="line">	long j&#x3D;0;</span><br><span class="line">	if(n&lt;&#x3D;0)  &#x2F;&#x2F;第一种情况结果为0</span><br><span class="line">	&#123;</span><br><span class="line">		j&#x3D;0;</span><br><span class="line">		System.out.println(j*j);</span><br><span class="line">	&#125;	</span><br><span class="line">	else&#x2F;&#x2F;第二种情况结果要从x转换为long之后一个一个挪直到结果</span><br><span class="line">	&#123;</span><br><span class="line">		if((long)x*(long)x&#x3D;&#x3D;n)</span><br><span class="line">			j&#x3D; (long)x;</span><br><span class="line">		else</span><br><span class="line">			j&#x3D;(long)x+1;</span><br><span class="line">		System.out.println(j*j);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/wanquanpingfangshu.png" alt></p>
<hr>
<p><strong>十、阿尔法乘积</strong><br><strong>问题描述</strong><br>　　计算一个整数的阿尔法乘积。对于一个整数x来说，它的阿尔法乘积是这样来计算的：如果x是一个个位数，那么它的阿尔法乘积就是它本身；否则的话，x的阿尔法乘积就等于它的各位非0的数字相乘所得到的那个整数的阿尔法乘积。例如：4018224312的阿尔法乘积等于8，它是按照以下的步骤来计算的：<br>　　4018224312 → 4<em>1</em>8<em>2</em>2<em>4</em>3<em>1</em>2 → 3072 → 3<em>7</em>2 → 42 → 4*2 → 8<br>　　编写一个程序，输入一个正整数（该整数不会超过6,000,000），输出它的阿尔法乘积。<br>　　输入格式：输入只有一行，即一个正整数。<br>　　输出格式：输出相应的阿尔法乘积。<br>　　输入输出样例<br>样例输入<br>4018224312<br>样例输出<br>8</p>
<p><strong>思路如下：</strong><br>　　发现这个题目就是不停的乘不停的乘，一开始本来用数组但是发现两个while循环之后答案只有70%的准确率(就是因为int不能满足题意，所以改用函数+定义long型)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	long n&#x3D;input.nextLong();&#x2F;&#x2F;输入的数定义为long型</span><br><span class="line">	System.out.println(f(n));</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   public static long f(long n) &#123;&#x2F;&#x2F;不断地输入n</span><br><span class="line">	   if(n&lt;10)  &#x2F;&#x2F;满足乘积最终为个位数</span><br><span class="line">		   return n;</span><br><span class="line">	   long sum&#x3D;1;</span><br><span class="line">	   while(n&gt;0)</span><br><span class="line">	   &#123;</span><br><span class="line">		   if(n%10!&#x3D;0) &#x2F;&#x2F;拆开的目前位数字不为0</span><br><span class="line">		   sum*&#x3D;n%10;  &#x2F;&#x2F;不断乘积得到目前阶段的积</span><br><span class="line">		    n&#x2F;&#x3D;10;  &#x2F;&#x2F;拆数（拆的更小）</span><br><span class="line">	   &#125;</span><br><span class="line">	   return f(sum);&#x2F;&#x2F;不停地递归找答案</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br>！<a href="aerfachengji.png"></a></p>
<hr>
<p><strong>十一、求阶乘最右边的第一个非0数(BigDecimal)</strong><br>一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13！就已经比较大了，已经无法存放在一个整型变量中；而35！就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5！=1<em>2</em>3<em>4</em>5=120，因此5!最右边的那个非0的数字是2。再如，7！=5040，因此7！最右边的那个非0的数字是4。再如，15！= 1307674368000，因此15！最右边的那个非0的数字是8。请编写一个程序，输入一个整数n(0&lt;n&lt;=100)，然后输出n!最右边的那个非0的数字是多少。<br>输入：<br>　　7<br>输出：<br>　　4</p>
<p><strong>思路如下：</strong><br>　　使用BigDecimal类定义一个sum得出结果用。<br>然后通过 <strong><code>valueof()</code></strong> 方法制造BigDecimal类的对象，通过multiply方法从1乘到n的结果返回给sum。<br>然后将结果通过<strong><code>toString()</code></strong>方法转成字符串，倒序判断是不是为0最后得出结果。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        int n&#x3D;input.nextInt();</span><br><span class="line">        BigDecimal sum&#x3D;BigDecimal.ONE;&#x2F;&#x2F;设置为1</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum&#x3D;sum.multiply(BigDecimal.valueOf(i));&#x2F;&#x2F;1*2*3*...*n就是一直到n(阶乘)</span><br><span class="line">        &#125;</span><br><span class="line">        String s&#x3D;sum.toString();  &#x2F;&#x2F;转为字符串</span><br><span class="line">        for(int i&#x3D;s.length()-1;i&gt;&#x3D;0;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s.charAt(i)!&#x3D;&#39;0&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(s.charAt(i));</span><br><span class="line">                break ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/feiling.png" alt></p>
<hr>
<p><strong>十二、二进制—&gt;十进制</strong><br><strong>问题描述</strong><br>　　编写一个程序，输入一个二进制的字符串（长度不超过32），然后计算出相应的十进制整数，并把它打印出来。<br>　　输入格式：输入为一个字符串，每个字符都是’0’或’1’，字符串的长度不超过32。<br>　　输出格式：输出一个整数。<br>　　输入输出样例<br>样例输入<br>1101<br>样例输出<br>13</p>
<p><strong>思路：</strong><br><strong>方法1.</strong>使用字符串n输入一连串2进制数字，然后通过BigInteger类对象创建BigInteger(n,2)即可得到答案。<br><strong>方法2.</strong>通过字符串转字符数组，然后从最后面到最前面循环，不断地sum求和就可以了。</p>
<p><strong>方法1代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        String n&#x3D;input.next();</span><br><span class="line">        BigInteger s&#x3D;new BigInteger(n,2);&#x2F;&#x2F;使用new就行</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法2代码实现：</strong><br>注意：<br>1.一定要将字符1转为数字1！！！  ——-<code>(int)a[i]-48</code><br>2.<code>pow()</code>用于求2的多少次方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        String n&#x3D;input.next();&#x2F;&#x2F;输入一个字符串</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        char[] a&#x3D;n.toCharArray();&#x2F;&#x2F;字符串转成字符数组(相反就用valueOf()方法)</span><br><span class="line">        for(int i&#x3D;a.length-1;i&gt;&#x3D;0;i--)&#x2F;&#x2F;倒序寻找(方便2的0次方增大)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+&#x3D;((int)a[i]-48)*Math.pow(2,a.length-i-1);&#x2F;&#x2F;一定要记得将字符1强制类型转换后减去48(0的ASCII码)*2的对应次方</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>十三、阶乘末尾(求末尾len位)</strong><br><strong>问题描述</strong><br>　　给定n和len，输出n!末尾len位。<br>输入格式<br>　　一行两个正整数n和len。<br>输出格式<br>　　一行一个字符串，表示答案。长度不足用前置零补全。<br>样例输入<br>6 5<br>样例输出<br>00720<br>数据规模和约定<br>　　n&lt;=30, len&lt;=10。</p>
<p><strong>思路：</strong><br>　　和之前的题目一样需要考虑用BigDecimal类定义一个s大数，然后调用multiply方法计算阶乘，可以直接通过输出s得到阶乘的结果。但是这个题目需要将其转换为字符串然后转换为字符数组对比长度和len大小。如果长度&gt;len就直接输出就行，如果小于的话需要在前面输出cha这么多个0才行。  </p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        int n&#x3D;input.nextInt();</span><br><span class="line">        int len&#x3D;input.nextInt();</span><br><span class="line">        BigDecimal s&#x3D;BigDecimal.ONE;&#x2F;&#x2F;设定一个大数s</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s&#x3D;s.multiply(s.valueOf(i));&#x2F;&#x2F;利用乘法方法 然后从1*2*...n</span><br><span class="line">        &#125;</span><br><span class="line">        String s1&#x3D;s.toString();&#x2F;&#x2F;转成字符串s1</span><br><span class="line">        char[] a&#x3D;s1.toCharArray();&#x2F;&#x2F;转为字符数组a</span><br><span class="line">        int cha&#x3D;a.length-len;</span><br><span class="line">        if(cha&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            int jueduizhi&#x3D;Math.abs(cha);</span><br><span class="line">            while(jueduizhi--!&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(&quot;0&quot;);  &#x2F;&#x2F;差记为补几个0在前面</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                    System.out.print(a[i]);  &#x2F;&#x2F;补了0之后再输出其他的数字</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else  &#x2F;&#x2F;如果长度够长</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i&#x3D;cha;i&lt;a.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                    System.out.print(a[i]); &#x2F;&#x2F;直接从cha的位置正序输出</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/jiechengmowei.png" alt></p>
<hr>
<p><strong>十四题、明明的随机数</strong><br><strong>问题描述</strong><br>　　明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。<br>输入格式<br>　　输入有2行，第1行为1个正整数，表示所生成的随机数的个数：<br>　　N<br>　　第2行有N个用空格隔开的正整数，为所产生的随机数。<br>输出格式<br>　　输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。<br>样例输入<br>10<br>20 40 32 67 40 20 89 300 400 15<br>样例输出<br>8<br>15 20 32 40 67 89 300 400</p>
<p><strong>思路：</strong><br>　　我发现动态的和数据有关的一定要去使用<strong><code>集合</code></strong>！！！集合的动态变换比较方便！这道题目就用TreeSet集合(可以自动排序加减少重读的内容)。<br>　　然后使用while循环不断地判断是不是有下一个，用add方法去添加内容，然后添加之后size方法输出不重复的排序之后的集合长度，for循环输出每一个内容。</p>
<p><strong>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        while(input.hasNext())  &#x2F;&#x2F;判断是否有下一个</span><br><span class="line">        &#123;</span><br><span class="line">            int num&#x3D;input.nextInt();</span><br><span class="line">            TreeSet&lt;Integer&gt; set&#x3D;new TreeSet&lt;&gt;();  &#x2F;&#x2F;TreeSet集合存储</span><br><span class="line">            for(int i&#x3D;0;i&lt;num;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                set.add(input.nextInt());  &#x2F;&#x2F;输入内容</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(set.size());  &#x2F;&#x2F;自动排序然后删除重复值之后的长度</span><br><span class="line"></span><br><span class="line">            for(int i:set)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(i+&quot; &quot;);  &#x2F;&#x2F;增强for循环去输出结果</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/mingmingdesuijishu.png" alt></p>
<hr>
<p><strong>十五、 黑色星期五(使用Calendar)</strong><br><strong>问题描述</strong><br>　　有些西方人比较迷信，如果某个月的13号正好是星期五，他们就会觉得不太吉利，用古人的说法，就是“诸事不宜”。请你编写一个程序，统计出在某个特定的年份中，出现了多少次既是13号又是星期五的情形，以帮助你的迷信朋友解决难题。<br>　　输入输出样例<br>　　样例输入<br>　　1998<br>　　样例输出<br>　　3</p>
<p><strong>思路：</strong><br>使用JAVA中Calendar类可以很方便的得出结果，使用getInstance()方法获取一个默认时区的日历，通过set方法寻找第一个条件某个月的13号，然后通过对比Calendar类中固定的DAT_OF_WEEK==6(周五)从而满足两个条件。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        int n&#x3D;input.nextInt();</span><br><span class="line">        int sum&#x3D;0;&#x2F;&#x2F;计数</span><br><span class="line">        Calendar c&#x3D;Calendar.getInstance();&#x2F;&#x2F;获得一个时区默认的日历</span><br><span class="line">        for(int i&#x3D;1;i&lt;13;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c.set(n,i,13);  &#x2F;&#x2F;寻找每个月的13号日子</span><br><span class="line">            if(c.get(Calendar.DAY_OF_WEEK)&#x3D;&#x3D;6) &#x2F;&#x2F;1是周日 2是周一 3是周二...6是周五</span><br><span class="line">                sum++;  &#x2F;&#x2F;如果c获得的是周五就增加一个</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/heisexingqiwu.png" alt></p>
<hr>
<p><strong>十六、身份证号码升级</strong><br><strong>问题描述</strong><br>　　从1999年10月1日开始，公民身份证号码由15位数字增至18位。(18位身份证号码简介)。升级方法为：<br>　　1、把15位身份证号码中的年份由2位(7,8位)改为四位。<br>　　2、最后添加一位验证码。验证码的计算方案：<br>　　将前 17 位分别乘以对应系数 (7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2) 并相加，然后除以 11 取余数，0-10 分别对应 1 0 x 9 8 7 6 5 4 3 2。<br>　　请编写一个程序，用户输入15位身份证号码，程序生成18位身份证号码。假设所有要升级的身份证的四位年份都是19××年<br>输入格式<br>　　一个15位的数字串，作为身份证号码<br>输出格式<br>　　一个18位的字符串，作为升级后的身份证号码<br>样例输入<br>110105491231002<br>样例输出<br>11010519491231002x<br>数据规模和约定<br>　　不用判断输入的15位字符串是否合理</p>
<p><strong>思路：</strong><br>　　考虑要用字符串s将15位身份证号码输入进去，然后转成字符数组a，设置一个数组b去一个一个从a拿到(赋值-48)。然后例如：49-1949我就是将4直接加190转换成194之后每一位去乘相应的系数得到最后一位，然后switch语句判断得到答案(x先用-1替换掉)，最后依次输出b数组。</p>
<p><strong>代码实现如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        String s&#x3D;input.next();&#x2F;&#x2F;用字符串输入15位身份证</span><br><span class="line">        char[] a&#x3D;s.toCharArray();&#x2F;&#x2F;转成字符数组</span><br><span class="line">        int[] b&#x3D;new int[16];&#x2F;&#x2F;用16位去表示结果(17-1917只把1编程191)</span><br><span class="line">        for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i]&#x3D;a[i];&#x2F;&#x2F;把每一位传给int型数组b</span><br><span class="line">            b[i]&#x3D;b[i]-48;&#x2F;&#x2F;必须减48才能从字符转为数字的0&#x2F;1...9</span><br><span class="line">        &#125;</span><br><span class="line">        b[6]&#x3D;b[6]+190;&#x2F;&#x2F;将第一位x直接变成19x</span><br><span class="line">        b[15]&#x3D;(b[0]*7)+(b[1]*9)+(b[2]*10)+(b[3]*5)+(b[4]*8)+(b[5]*4)+2+9+((b[6]%10)*6)+(b[7]*3)+(b[8]*7)+(b[9]*9)+(b[10]*10)+(b[11]*5)+(b[12]*8)+(b[13]*4)+(b[14]*2);&#x2F;&#x2F;注意我现在的只有16位(每一位对应的乘要变化)</span><br><span class="line">        b[15]&#x3D;b[15]%11;&#x2F;&#x2F;计算出来之后对11取余</span><br><span class="line">        switch (b[15])&#x2F;&#x2F;依次判断出最后一位是什么</span><br><span class="line">        &#123;</span><br><span class="line">            case 0:b[15]&#x3D;1;break;</span><br><span class="line">            case 1:b[15]&#x3D;0;break;</span><br><span class="line">            case 2:b[15]&#x3D;-1;break;  &#x2F;&#x2F;先用-1代替x</span><br><span class="line">            case 3:b[15]&#x3D;9;break;</span><br><span class="line">            case 4:b[15]&#x3D;8;break;</span><br><span class="line">            case 5:b[15]&#x3D;7;break;</span><br><span class="line">            case 6:b[15]&#x3D;6;break;</span><br><span class="line">            case 7:b[15]&#x3D;5;break;</span><br><span class="line">            case 8:b[15]&#x3D;4;break;</span><br><span class="line">            case 9:b[15]&#x3D;3;break;</span><br><span class="line">            case 10:b[15]&#x3D;2;break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;b.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i!&#x3D;15)</span><br><span class="line">            System.out.print(b[i]);&#x2F;&#x2F;输出除过最后一位的数字</span><br><span class="line">            else  &#x2F;&#x2F;判断最后一位</span><br><span class="line">                if(b[15]&#x3D;&#x3D;-1)</span><br><span class="line">                System.out.print(&quot;x&quot;);&#x2F;&#x2F;这里将-1换成x</span><br><span class="line">                else</span><br><span class="line">                    System.out.println(b[15]);&#x2F;&#x2F;其他的就按照switch语句的答案输出</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/shenfenzhengshengji.png" alt></p>
<hr>
<p><strong>十七、不同单词个数统计(split()方法)</strong><br><strong>问题描述</strong><br>　　编写一个程序，输入一个句子，然后统计出这个句子当中不同的单词个数。例如：对于句子“one little two little three little boys”，总共有5个不同的单词：one, little, two, three, boys。<br>　　说明：（1）由于句子当中包含有空格，所以应该用gets函数来输入这个句子；（2）输入的句子当中只包含英文字符和空格，单词之间用一个空格隔开；（3）不用考虑单词的大小写，假设输入的都是小写字符；（4）句子长度不超过100个字符。<br>　　输入格式：输入只有一行，即一个英文句子。<br>　　输出格式：输出只有一行，是一个整数，表示句子中不同单词的个数。<br>输入输出样例<br>样例输入<br>one little two little three little boys<br>样例输出<br>5</p>
<p><strong>思路：</strong><br>　　主要是用<strong>nextLine()输入</strong>！！！(next会把单词之间的空格当做结束符)，然后通过<strong><code>split()</code>方法</strong>将s隔开成一个一个单词存放在String字符串数组之中，这一步其实可以输出a.length得到长度。但是这个题目必须要输出不重复单词的个数，可以<strong>通过二重循环将相同的单词其中一个变成空格</strong>(可以二次使用split方法)<br>　　然后只要数组不为空就可以sum加一个，最终sum值就是答案。<br><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        String s &#x3D; input.nextLine();&#x2F;&#x2F;用nextLine格式输入要判断的字符串</span><br><span class="line">        String[] a &#x3D; s.split(&quot; &quot;);&#x2F;&#x2F;用split方法得到每个单词</span><br><span class="line">        int sum &#x3D; 0;&#x2F;&#x2F;计数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; a.length; j++)&#x2F;&#x2F;二重循环依次判断</span><br><span class="line">            &#123;</span><br><span class="line">                if (a[i].equals(a[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    a[j] &#x3D; &quot; &quot;;&#x2F;&#x2F;将相同的其中一个单词换成空格</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i]!&#x3D;&quot; &quot;)</span><br><span class="line">                sum++;&#x2F;&#x2F;输出不是空格的位置的单词数量</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/butongdancigeshutongji.png" alt></p>
<hr>
<p><strong>十八、判断回文(字符串)</strong><br><strong>问题描述：</strong><br>  编程判断一个字符串是否是回文，当字符串是回文时，输出字符串：yes!，否则输出字符串：no!。所谓回文即正向与反向的拼写都一样，如adgda。　　长度在100以内，且全为小写字母<br>样例输入<br>adgda<br>样例输出<br>yes!</p>
<p><strong>思路：</strong><br>　　我考虑的是输入字符串s1和s2对比，s1就用字符串转字符串数组的方式转成字符串数组a，然后反序得到b，从而字符串数组转字符串s2，然后进行对比。<br><strong>字符串—-&gt;字符串数组/字符数组：</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s&#x3D;input.next();</span><br><span class="line">char[] a&#x3D;s.toCharArray();&#x2F;&#x2F;字符数组</span><br><span class="line">String[] a&#x3D;s.split(&quot;&quot;);&#x2F;&#x2F;字符串数组(&quot;里面随自己&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>字符串数组—-&gt;字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] b&#x3D;new String[n];</span><br><span class="line">StringBuffer s&#x3D;new StringBuffer();</span><br><span class="line">for(String i：b)</span><br><span class="line">&#123;</span><br><span class="line">	s.append(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s.toString());&#x2F;&#x2F;要用toString方法才能转成字符串</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        String s1 &#x3D; input.next();&#x2F;&#x2F;输入要判断的字符串s1</span><br><span class="line">        String[] a &#x3D; s1.split(&quot;&quot;);&#x2F;&#x2F;利用split方法隔成字符串数组a</span><br><span class="line">        String[] b &#x3D; new String[a.length];&#x2F;&#x2F;创建一个字符串数组b</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; a.length - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            b[j++] &#x3D; a[i]; &#x2F;&#x2F;反序把a输入到b里面</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer s2 &#x3D; new StringBuffer();&#x2F;&#x2F;使用StringBuffer 创建一个字符串s2</span><br><span class="line">        for (String i : b)</span><br><span class="line">        &#123;</span><br><span class="line">               s2.append(i);&#x2F;&#x2F;增强for循环将字符串数组转成字符串</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(s1.equals(s2.toString()))&#x2F;&#x2F;必须将s2.toString才可以判断</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;yes!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;no!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/panduanhuiwen.png" alt></p>
<hr>
<p><strong>十九、十六进制转10/8进制</strong><br>　　用户输入三个字符，每个字符取值范围是0-9，A-F。然后程序会把这三个字符转化为相应的十六进制整数，并分别以十六进制，十进制，八进制输出，十六进制表示成3位，八进制表示成4位，若不够前面补0。（不考虑输入不合法的情况）<br>输入<br>　　1D5<br>输出<br>（注意冒号后面有一个空格）<br>　　Hex: 0x1D5<br>　　Decimal: 469<br>　　Octal: 0725<br><strong>思路：</strong><br>  16进制就是直接输出；10进制就是用Long型的<code>parseLong</code>方法；8进制就是使用Integer的<code>toOctalString()</code>方法，但是里面的属性是Integer的valueOf方法(s，16)。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        String s &#x3D; input.next();</span><br><span class="line">        System.out.println(&quot;Hex: Ox&quot; + s);</span><br><span class="line"></span><br><span class="line">        Long shi &#x3D; Long.parseLong(s, 16);&#x2F;&#x2F;转成十进制</span><br><span class="line">        System.out.println(&quot;Decimal: &quot; + shi);</span><br><span class="line"></span><br><span class="line">        String ba &#x3D; Integer.toOctalString(Integer.valueOf(s, 16));&#x2F;&#x2F;转成8进制</span><br><span class="line">        char[] a &#x3D; ba.toCharArray();</span><br><span class="line">        int cha &#x3D; 4 - a.length;</span><br><span class="line">        if (cha &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Octal: &quot; +ba);</span><br><span class="line">        &#125;</span><br><span class="line">        if (cha &#x3D;&#x3D; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Octal: 0&quot; +ba);</span><br><span class="line">        &#125;</span><br><span class="line">        if (cha &#x3D;&#x3D; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Octal: 00&quot; +ba);</span><br><span class="line">        &#125;</span><br><span class="line">        if (cha &#x3D;&#x3D; 3)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Octal: 000&quot; +ba);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/jinzhizhuanhuan.png" alt></p>
<hr>
<p><strong>二十、删除重复元素(使用数组下标)</strong><br><strong>问题描述</strong><br>　　为库设计新函数DelPack，删除输入字符串中所有的重复元素。不连续的重复元素也要删除。<br>　　要求写成函数，函数内部使用指针操作。<br>样例输入<br>1223445667889<br>样例输出<br>13579<br>样例输入<br>else<br>样例输出<br>ls<br>数据规模和约定<br>　　字符串数组最大长度为100。</p>
<p><strong>思路分析：</strong><br>　　通过数组下标，所有的先为0而后面将字符串出现一次增加一次，当最后为1就输出(可以去掉出现两次以上的元素)</p>
<p><strong>代码结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        String s&#x3D;input.next();</span><br><span class="line">        int[] a&#x3D;new int[10001];</span><br><span class="line">        for(int i&#x3D;0;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">         a[s.charAt(i)]++;&#x2F;&#x2F;字符串的每一次为字符对应的下标数组元素从1变</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[s.charAt(i)]&#x3D;&#x3D;1)&#x2F;&#x2F;只让出现一次的元素输出</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br><img src="/2019/10/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%83%E4%B9%A0/yuansuchongfu.png" alt></p>
<hr>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" rel="tag">蓝桥杯</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/22/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/24/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2023 Larkkkkkkk
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="http://bestwing.me" target="_blank">Sw'blog</a> by Swing
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


    <script type="text/javascript">
      window.onload = function(){
        document.getElementById("search").onclick = function(){
            console.log("search")
            search();
        }
      }
      function search(){
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','A1Pz-LKMXbrzcFg2FWi6','2.0.0');
      }
    </script>

  </div>
</body>
</html>