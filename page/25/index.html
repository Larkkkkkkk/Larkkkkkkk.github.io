<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Larkkkkkkk</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Larkkkkkkk">
<meta property="og:url" content="https://larkkkkkkk.github.io/page/25/index.html">
<meta property="og:site_name" content="Larkkkkkkk">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Larkkkkkkk">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Larkkkkkkk" type="application/atom+xml">
  
  
    <link rel="icon" href="/http://oayoilchh.bkt.clouddn.com/2016/07/27/18:05:26%20">
  
  
      
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="img/head.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Larkkkkkkk</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="https://github.com/Larkkkkkkk" target="_blank" rel="noopener">博客首页</a></li>
                        
                            <li><a  href="/archives">文章归档</a></li>
                        
                            <li><a  href="/CTFStudy">学习导航</a></li>
                        
                            <li><a  href="/PWNABLE">PWNABLE</a></li>
                        
                            <li><a  href="/resume">个人简历</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail"  target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=U2JgZ2ZlY2VmamATIiJ9MDw_" title="mail">mail</a>
                            
                                <a class="fl github"  target="_blank" href="https://github.com/Larkkkkkkk" title="github">github</a>
                            
                                <a class="fl zhihu"  target="_blank" href="https://www.zhihu.com/people/plain-3-78/activities" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo"  target="_blank" href="https://weibo.com/5304208276/profile?topnav=1&wvr=6" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Ajax/" style="font-size: 12px;">Ajax</a> <a href="/tags/Cookie%E5%92%8CSession/" style="font-size: 14px;">Cookie和Session</a> <a href="/tags/DBUtils/" style="font-size: 11px;">DBUtils</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">EL表达式</a> <a href="/tags/Elasticsearch/" style="font-size: 11px;">Elasticsearch</a> <a href="/tags/Filter/" style="font-size: 11px;">Filter</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTPServletReauest%E5%92%8CHTTPServletResponse/" style="font-size: 10px;">HTTPServletReauest和HTTPServletResponse</a> <a href="/tags/Hexo%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">Hexo博客</a> <a href="/tags/IDEA%E5%AE%89%E8%A3%85%E5%92%8C%E7%A0%B4%E8%A7%A3/" style="font-size: 10px;">IDEA安装和破解</a> <a href="/tags/JAVA/" style="font-size: 19px;">JAVA</a> <a href="/tags/JAVA-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">JAVA-Lambda表达式</a> <a href="/tags/JAVA-Set%E9%9B%86%E5%90%88/" style="font-size: 10px;">JAVA-Set集合</a> <a href="/tags/JAVA-%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">JAVA-反射</a> <a href="/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 12px;">JAVA-多线程</a> <a href="/tags/JAVA-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">JAVA-正则表达式</a> <a href="/tags/JAVA-%E6%B3%9B%E5%9E%8B/" style="font-size: 10px;">JAVA-泛型</a> <a href="/tags/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 12px;">JAVA-网络编程</a> <a href="/tags/JAVA-%E9%9B%86%E5%90%88/" style="font-size: 12px;">JAVA-集合</a> <a href="/tags/JAVA%E7%BB%83%E4%B9%A0/" style="font-size: 11px;">JAVA练习</a> <a href="/tags/JAVA%E7%BB%83%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">JAVA练习-动态规划</a> <a href="/tags/JQuery/" style="font-size: 13px;">JQuery</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Jmeter/" style="font-size: 10px;">Jmeter</a> <a href="/tags/LeetCode/" style="font-size: 17px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Listener/" style="font-size: 10px;">Listener</a> <a href="/tags/Mybatis/" style="font-size: 18px;">Mybatis</a> <a href="/tags/MybatisPlus/" style="font-size: 10px;">MybatisPlus</a> <a href="/tags/Mysql/" style="font-size: 12px;">Mysql</a> <a href="/tags/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CJDBC/" style="font-size: 15px;">Mysql数据库和JDBC</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Servlet/" style="font-size: 11px;">Servlet</a> <a href="/tags/Spring/" style="font-size: 16px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/Web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 20px;">Web前端知识点</a> <a href="/tags/XML/" style="font-size: 11px;">XML</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/flask%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">flask框架</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/jsp%E6%A0%87%E5%87%86%E6%A0%87%E7%AD%BE%E5%BA%93/" style="font-size: 10px;">jsp标准标签库</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/picture/" style="font-size: 10px;">picture</a> <a href="/tags/python/" style="font-size: 12px;">python</a> <a href="/tags/pytorch/" style="font-size: 10px;">pytorch</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/ssm%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BF/" style="font-size: 10px;">ssm框架模板</a> <a href="/tags/webserver%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">webserver编程</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BA%AC%E4%B8%9C/" style="font-size: 11px;">京东</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%90%8E%E7%BC%80%E6%A0%91/" style="font-size: 10px;">后缀树</a> <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 10px;">哈希表</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/" style="font-size: 10px;">复杂度分析</a> <a href="/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">学生管理系统</a> <a href="/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F2-0/" style="font-size: 12px;">学生管理系统2.0</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 15px;">微服务</a> <a href="/tags/%E6%8B%BC%E5%A4%9A%E5%A4%9A/" style="font-size: 10px;">拼多多</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 10px;">数据分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" style="font-size: 10px;">数据库连接池</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数据结构-稀疏数组</a> <a href="/tags/%E6%96%87%E5%AD%97%E7%AF%87-%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">文字篇-记录</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 12px;">机器学习</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 12px;">树</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10px;">注解</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 14px;">深度学习</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 11px;">爬虫</a> <a href="/tags/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/" style="font-size: 10px;">生物信息学</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 12px;">知识图谱</a> <a href="/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%88%9D%E8%AF%95/" style="font-size: 12px;">研究生初试</a> <a href="/tags/%E7%A7%8B%E6%8B%9B/" style="font-size: 10px;">秋招</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">算法-动态规划</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/" style="font-size: 10px;">算法-回溯法</a> <a href="/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法-贪心算法</a> <a href="/tags/%E8%80%83%E7%A0%94/" style="font-size: 10px;">考研</a> <a href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 13px;">蓝桥杯</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11px;">计算机网络</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE-%E8%BD%AF%E4%BB%B6%E4%B8%93%E4%B8%9A%E9%A2%98%E7%9B%AE/" style="font-size: 10px;">计算机网络课设(软件专业题目)</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12px;">设计模式</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" style="font-size: 10px;">软件体系结构</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 10px;">递归</a> <a href="/tags/%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">重新部署</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/tags/%E9%A1%B5%E9%9D%A2%EF%BC%88H5-CSS%EF%BC%89/" style="font-size: 10px;">页面（H5+CSS）</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0/" style="font-size: 10px;">项目上传</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://ring3.xyz/">Yllen</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://mxny.org/">麦香浓郁</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://whereisk0shl.top/">K0sh1</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.ycjcl.cc/">信鑫</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://bystudent.com/">ByStundet表哥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.jarviswang.me/">汪神_Jarvis</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sh3ll.me/">Chu</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.hackfun.org/">4ido10n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/iamstudy">L3m0n</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://o0xmuhe.me/">muhe</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.nuptzj.cn/">_画船听雨</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.virzz.com/index.html">Virink</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.sqlsec.com/">国光</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bodkin.ren/">老锥</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cizel.cn/">C1zel</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://1phan.cc">1phan</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.liuil.top/">liuil</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/Ox9A82/">Ox9A82</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://burnegg.com/">burnegg</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://jwrsec.cn/">jwr-sec</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://sudalover.cn/">苏打</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.binklac.com">VeroFess</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.bendawang.site/">bendawang</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://weeklyalgo.codes/">hook</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.flier.net.cn/">Flier&#39;blog</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.mutepig.club">mutepig</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://blog.iret.xyz/list.aspx">Silver</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://simp1e.leanote.com/">Simple</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://processor.pub/">Processor</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">一只淹死在二进制海洋里的二进制狗!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Larkkkkkkk</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Larkkkkkkk</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="https://github.com/Larkkkkkkk" target="_blank" rel="noopener">博客首页</a></li>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="/CTFStudy">学习导航</a></li>
                
                    <li><a href="/PWNABLE">PWNABLE</a></li>
                
                    <li><a href="/resume">个人简历</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=U2JgZ2ZlY2VmamATIiJ9MDw_" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/Larkkkkkkk" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/plain-3-78/activities" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="https://weibo.com/5304208276/profile?topnav=1&wvr=6" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-网络课设" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/30/%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE/" class="article-date">
      <time datetime="2019-12-30T00:15:53.000Z" itemprop="datePublished">2019-12-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/30/%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE/">网络课设</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、题目和要求</strong><br>题目：协议分析软件开发及网络协议分析<br>（1）教学内容<br>网络协议分层结构，网络协议工作过程，协议数据单元结构，协议分析，协议设计，协议分析软件开发。<br>（2）教学要求<br>理解网络协议的层次结构及网络协议的工作过程，掌握网络协议的分析方法及网络协议的设计与应用。</p>
<hr>
<p><strong>二、了解必须的协议首部格式</strong></p>
<ul>
<li>IP协议(首部格式)：</li>
</ul>
<p><img src="/2019/12/30/%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE/ipxieyi.png" alt></p>
<p>  IP协议，又译为网际协议或互联网协议，是用在TCP/IP协议簇中的网络层协议。IP协议位于TCP/IP协议的网络层，位于同一层次的协议还有下面的ARP和RARP以及上面的ICMP(Internet控制报文协议)和IGMP(Internet组管理协议)。除了ARP和RARP报文以外的几乎所有的数据都要经过IP协议进行传送。ARP和RARP报文没有封装在IP数据报中，而ICMP和IGMP的数据则要封装在IP数据报中进行传输。由于IP协议在网络层中具有重要的地位，TCP/IP协议的网络层又被称为IP层。</p>
<ul>
<li>TCP协议(首部格式)：</li>
</ul>
<p><img src="/2019/12/30/%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE/tcpxieyi.png" alt></p>
<p>  传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。<br>TCP旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。TCP假设它可以从较低级别的协议获得简单的，可能不可靠的数据报服务。 原则上，TCP应该能够在从硬线连接到分组交换或电路交换网络的各种通信系统之上操作。<br>当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。 </p>
<ul>
<li>UDP协议(首部格式)： </li>
</ul>
<p><img src="/2019/12/30/%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE/udpxieyi.png" alt></p>
<p>　　UDP协议概述：一种无连接协议，提供无连接服务，在传送数据之前不需要先建立连接；传送的数据单位协议是 UDP 报文或用户数据报。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。</p>
<hr>
<p><strong>三、实现思路</strong></p>
<ol>
<li>JAVA语言虽然在TCP/UDP传输方面给予了良好的定义，但对于网络层以下的控制，却是无能为力的。JPCAP扩展包弥补了这一点，<code>jPcap</code>是一个可以让java工作在链路层的类库；当然，它底层还是使用了本机API通过Jini调用，在javaAPI中得到数据。JPCAP实际上并非一个真正去实现对数据链路层的控制，而是一个中间件，JPCAP调用wincap/libpcap，而给JAVA语言提供一个公共的接口，从而实现了平台无关性。</li>
<li>通过使用主函数main去调用分析函数analyzePacke()和其他的方法去解决各个功能。通过while循环不断的输入选项去完成选择。通过线程抓获去获取数据包(用数组去存放数据包)，然后重写run()方法去获取数据包。</li>
<li>最后可以通过break跳出menu菜单(或者选择停止抓数据包)。</li>
</ol>
<hr>
<p><strong>四、具体实现代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line">import jpcap.*;</span><br><span class="line">import jpcap.packet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import javax.xml.bind.annotation.adapters.HexBinaryAdapter;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    &#x2F;&#x2F;定义默认最大抓包数</span><br><span class="line">    private static final int max &#x3D; 1000;</span><br><span class="line">    &#x2F;&#x2F;显示所有网络设备信息</span><br><span class="line">private static void showDeviceList(NetworkInterface[] devices) &#123;</span><br><span class="line">&#x2F;&#x2F;展示当前主机设备信息</span><br><span class="line">        System.out.println(&quot;本机上所有适配器如下：&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; devices.length; i++) </span><br><span class="line">&#123;</span><br><span class="line">            &#x2F;&#x2F;网络适配器名称(循环输出所有的适配器)</span><br><span class="line">            System.out.println(&quot;Adapter &quot; + (i + 1) + &quot;(名称)&quot; + devices[i].description);</span><br><span class="line">           </span><br><span class="line"> &#x2F;&#x2F;MAC地址</span><br><span class="line">            System.out.print(&quot;    MAC address(MAC地址): &quot;);  </span><br><span class="line">            for (byte b : devices[i].mac_address) &#x2F;&#x2F;用：隔开输出16进制</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(Integer.toHexString(b &amp; 0xff) + &quot;:&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;IP地址</span><br><span class="line">            for (NetworkInterfaceAddress a : devices[i].addresses) &#x2F;&#x2F;调用方法输IP地址</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;    IPv6&#x2F;IPv4 address(IP地址): &quot; + a.address);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;网络接口监听</span><br><span class="line">private static JpcapCaptor openDevice(NetworkInterface[] devices, int choice) throws java.io.IOException  &#x2F;&#x2F;抛出异常</span><br><span class="line">&#123;</span><br><span class="line">        JpcapCaptor captor &#x3D; null;</span><br><span class="line">        Try</span><br><span class="line">&#123;</span><br><span class="line">            captor &#x3D; JpcapCaptor.openDevice(devices[choice], 65535, false, 3000);</span><br><span class="line">&#x2F;&#x2F;方法中的变量为一次性抓65535的长度,超时时间为3000ms</span><br><span class="line">        &#125; </span><br><span class="line">        catch (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();&#x2F;&#x2F;打印异常信息在程序中出错的位置以及原因</span><br><span class="line">            System.out.println(&quot;打开网络接口失败！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">         return captor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;数据包捕获线程(Thread)</span><br><span class="line">     private static class AThread implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">        Thread thread;</span><br><span class="line">        JpcapCaptor captor;</span><br><span class="line">        Packet[] packet;</span><br><span class="line">       </span><br><span class="line">        &#x2F;&#x2F;线程中断标志</span><br><span class="line">        volatile boolean cancel;</span><br><span class="line">        AThread(JpcapCaptor captor) throws IOException&#123;</span><br><span class="line">            this.captor &#x3D; captor;&#x2F;&#x2F;用this调用数据</span><br><span class="line">            this.packet &#x3D; new Packet[max];&#x2F;&#x2F;用this调用数据</span><br><span class="line">            this.cancel &#x3D; false;&#x2F;&#x2F;用this调用数据</span><br><span class="line">            thread &#x3D; new Thread(this);&#x2F;&#x2F;用this调用数据</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">        @Override &#x2F;&#x2F;重写线程中的run方法</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            packet &#x3D; new Packet[max];</span><br><span class="line">            for(int i &#x3D; 0; i &lt; max &amp;&amp; cancel &#x3D;&#x3D; false; i++)&#123;</span><br><span class="line">                packet[i] &#x3D; captor.getPacket();&#x2F;&#x2F;调用getpacket()方法获取数据包</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;设置中断的方法(主要用于选项2的操作)</span><br><span class="line">        public void cancel()</span><br><span class="line">&#123;</span><br><span class="line">            cancel &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Packet[] getPacket()</span><br><span class="line">&#123;</span><br><span class="line">            return packet;&#x2F;&#x2F;获取数据包</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">private static Packet[] readPacket(JpcapCaptor captor, String filename)</span><br><span class="line">&#123;</span><br><span class="line">        Packet[] packet &#x3D; new Packet[max];&#x2F;&#x2F;定义一个packet数组去存取数据包</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            captor &#x3D; JpcapCaptor.openFile(filename);</span><br><span class="line">        &#125; </span><br><span class="line">        catch (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 0;;i++)&#123;</span><br><span class="line">            packet[i] &#x3D; captor.getPacket();</span><br><span class="line">            if(packet[i] &#x3D;&#x3D; null)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return packet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;按键5的功能去实现展示当前有多少数据包</span><br><span class="line">private static void analyzePacket(Packet[] packet)</span><br><span class="line">&#123;     </span><br><span class="line">&#x2F;&#x2F;定义三个泛型去动态存取数据包个数 </span><br><span class="line">  ArrayList&lt;UDPPacket&gt; udpPacketArray &#x3D; new ArrayList&lt;UDPPacket&gt;();</span><br><span class="line">        ArrayList&lt;ARPPacket&gt; arpPacketArray &#x3D; new ArrayList&lt;ARPPacket&gt;();</span><br><span class="line">        ArrayList&lt;TCPPacket&gt; tcpPacketArray &#x3D; new ArrayList&lt;TCPPacket&gt;();</span><br><span class="line">        int count, count1, count2, count3,;</span><br><span class="line">        count &#x3D; count1 &#x3D; count2 &#x3D; count3 &#x3D; 0;   </span><br><span class="line">        for(int i &#x3D; 0; packet[i] !&#x3D; null &amp;&amp; i &lt; max; i++) &#x2F;&#x2F;循环存各个类型的</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            if (packet[i] instanceof UDPPacket)&#x2F;&#x2F;如果获取的数据包属于UDPPacket包</span><br><span class="line">            &#123;</span><br><span class="line">                UDPPacket udp &#x3D; (UDPPacket) packet[i];</span><br><span class="line">                udpPacketArray.add(udp);</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            	if(packet[i] instanceof ARPPacket)&#x2F;&#x2F;如果获取的数据包属于ARPPacket包</span><br><span class="line">            	&#123;</span><br><span class="line">            		ARPPacket arp &#x3D; (ARPPacket) packet[i];</span><br><span class="line">            		arpPacketArray.add(arp);</span><br><span class="line">            		count2++;</span><br><span class="line">            	&#125;</span><br><span class="line">            	else </span><br><span class="line">            		if(packet[i] instanceof TCPPacket)&#x2F;&#x2F;如果获取的数据包属于TCPPacket包            		&#123;</span><br><span class="line">            			TCPPacket tcp &#x3D; (TCPPacket) packet[i];</span><br><span class="line">            			tcpPacketArray.add(tcp);</span><br><span class="line">            			count3++;</span><br><span class="line">            		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();&#x2F;&#x2F;换行方便查看</span><br><span class="line">        System.out.println(&quot;所有数据包数：&quot; + count);</span><br><span class="line">        System.out.println(&quot;UDP数据包数：&quot; + count1);</span><br><span class="line">        System.out.println(&quot;ARP数据包数：&quot; + count2);</span><br><span class="line">        System.out.println(&quot;TCP数据包数：&quot; + count3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;此方法循环输出每个包的信息</span><br><span class="line">private static void showPacket(Packet[] packet)</span><br><span class="line">&#123;</span><br><span class="line">        for(int i &#x3D; 0; packet[i] !&#x3D; null &amp;&amp; i &lt; max-1; i++)</span><br><span class="line">&#123;</span><br><span class="line">            System.out.println(&quot;Packet &quot; + (i+1) + &quot; : &quot; + packet[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;按键4显示数据包详细情况</span><br><span class="line">private static void showPacketDetail(Packet[] packet)</span><br><span class="line">&#123;    </span><br><span class="line">	System.out.print(&quot;输入你想查看的包序号&quot;);</span><br><span class="line">        Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">        int num&#x3D;input.nextInt();&#x2F;&#x2F;输入你要选择看的包序号</span><br><span class="line">        num&#x3D;num-1;</span><br><span class="line">        for(int i &#x3D; 0; packet[i] !&#x3D; null &amp;&amp; i &lt; max-1; i++) </span><br><span class="line">&#123;</span><br><span class="line">          if(i&#x3D;&#x3D;num) &#x2F;&#x2F;如果选的那个数字和循环的符合的话去判断是哪个数据包</span><br><span class="line">&#123;</span><br><span class="line">            if(packet[i] instanceof UDPPacket) &#x2F;&#x2F; 如果获取的数据包属于UDPPacket包</span><br><span class="line">&#123;</span><br><span class="line">                UDPPacket udp &#x3D; (UDPPacket) packet[i];</span><br><span class="line">                HexBinaryAdapter head &#x3D;  new HexBinaryAdapter();</span><br><span class="line">				String str &#x3D; head.marshal(udp.header);</span><br><span class="line">				int tou &#x3D; (str.charAt(29)-48)*4*2;&#x2F;&#x2F;主要用于判断推送字节输出检验和	</span><br><span class="line">                  System.out.println(&quot;Packet &quot; + (i+1) + &quot; : UDP&quot; );</span><br><span class="line">                  System.out.println(&quot;    数据 : &quot; + str);</span><br><span class="line">                  System.out.println(&quot;**********ip首部*********&quot;);</span><br><span class="line">                  System.out.println(&quot;    版本：IPv&quot;+ udp.version);</span><br><span class="line">				System.out.println(&quot;    首部长度:&quot; + str.substring(29,30));</span><br><span class="line">				System.out.println(&quot;    区分服务: 0&quot;);</span><br><span class="line">				System.out.println(&quot;    总长度：&quot; + udp.length);</span><br><span class="line">				System.out.println(&quot;    标识：&quot; + udp.ident);</span><br><span class="line">				System.out.println(&quot;    MF: &quot; + udp.more_frag);</span><br><span class="line">				System.out.println(&quot;    DF: &quot; + udp.dont_frag);</span><br><span class="line">				System.out.println(&quot;    片偏移：&quot; + udp.offset);</span><br><span class="line">				System.out.println(&quot;    生存时间：&quot; + udp.hop_limit);</span><br><span class="line">                   System.out.println(&quot;    源 ip地址 : &quot; + udp.src_ip.toString());</span><br><span class="line">                  System.out.println(&quot;    目的ip地址 : &quot; + udp.dst_ip.toString());</span><br><span class="line">                  System.out.println(&quot;**********数据部分*********&quot;);</span><br><span class="line">                  System.out.println(&quot;    源端口 : &quot; + String.valueOf(udp.src_port));</span><br><span class="line">                  System.out.println(&quot;    目的端口 : &quot; + String.valueOf(udp.dst_port));</span><br><span class="line">                  System.out.println(&quot;    长度 : &quot; + String.valueOf(udp.length));</span><br><span class="line">                  System.out.println(&quot;   校验和 : +str.substring(28+tou+12,28+tou+16));</span><br><span class="line">                  System.out.println();</span><br><span class="line">              &#125;</span><br><span class="line">else </span><br><span class="line">if(packet[i] instanceof TCPPacket)  &#x2F;&#x2F;如果获取的数据包属于TCPPacket包</span><br><span class="line">&#123;</span><br><span class="line">                TCPPacket tcp &#x3D; (TCPPacket) packet[i];&#x2F;&#x2F;TCP</span><br><span class="line">                HexBinaryAdapter head &#x3D;  new HexBinaryAdapter();&#x2F;&#x2F;转成16进制</span><br><span class="line">				String str &#x3D; head.marshal(tcp.header);</span><br><span class="line">				int tou &#x3D; (str.charAt(29)-48)*4*2;&#x2F;&#x2F;主要用于判断推送字节输出检验和</span><br><span class="line">                  System.out.println(&quot;Packet &quot; + (i+1) + &quot; : TCP&quot; );</span><br><span class="line">                  System.out.println(&quot;    数据 : &quot; + str);</span><br><span class="line">                  System.out.println(&quot;**********ip首部*********&quot;);</span><br><span class="line">                  System.out.println(&quot;    版本：IPv&quot;+ tcp.version);</span><br><span class="line">				System.out.println(&quot;    首部长度:&quot; + str.substring(29,30));</span><br><span class="line">				System.out.println(&quot;    区分服务: 0&quot;);</span><br><span class="line">				System.out.println(&quot;    总长度：&quot; + tcp.length);</span><br><span class="line">				System.out.println(&quot;    标识：&quot; + tcp.ident);</span><br><span class="line">				System.out.println(&quot;    MF: &quot; + tcp.more_frag);</span><br><span class="line">				System.out.println(&quot;    DF: &quot; + tcp.dont_frag);</span><br><span class="line">				System.out.println(&quot;    片偏移：&quot; + tcp.offset);</span><br><span class="line">				System.out.println(&quot;    生存时间：&quot; + tcp.hop_limit);</span><br><span class="line">				System.out.println(&quot;    源 ip地址 : &quot; + tcp.src_ip.toString());</span><br><span class="line">                  System.out.println(&quot;    目的ip地址 : &quot; + tcp.dst_ip.toString());</span><br><span class="line">                  System.out.println(&quot;**********数据部分*********&quot;);</span><br><span class="line">                  System.out.println(&quot;    源 ip地址 : &quot; + tcp.src_ip.toString());</span><br><span class="line">                  System.out.println(&quot;    目的ip地址 : &quot; + tcp.dst_ip.toString());</span><br><span class="line">                  System.out.println(&quot;    源端口 : &quot; + String.valueOf(tcp.src_port));</span><br><span class="line">                  System.out.println(&quot;    目的端口 : &quot; + String.valueOf(tcp.dst_port));</span><br><span class="line">                  System.out.println(&quot;    序号：&quot; + tcp.sequence);</span><br><span class="line">				System.out.println(&quot;    确认号：&quot; + tcp.ack_num);</span><br><span class="line">				System.out.println(&quot;    数据偏移：&quot; + tcp.offset);</span><br><span class="line">				System.out.println(&quot;    保留：0&quot;);</span><br><span class="line">				System.out.println(&quot;    紧急URG：&quot; + tcp.urg);</span><br><span class="line">				System.out.println(&quot;    确认ACK：&quot; + tcp.ack);</span><br><span class="line">				System.out.println(&quot;    推送PSH：&quot; + tcp.psh);</span><br><span class="line">				System.out.println(&quot;    复位RST：&quot; + tcp.rst);</span><br><span class="line">				System.out.println(&quot;    同步SYN：&quot; + tcp.syn);</span><br><span class="line">				System.out.println(&quot;    终止FIN：&quot; + tcp.fin);</span><br><span class="line">				System.out.println(&quot;    窗口：&quot; + tcp.window);</span><br><span class="line">			    System.out.println(&quot;  检验和:&quot; + str.substring(28+tou+32,28+tou+36));</span><br><span class="line">				System.out.println(&quot;    紧急指针：&quot; + tcp.urgent_pointer);</span><br><span class="line">				System.out.println(&quot;    选项：&quot; + tcp.option);</span><br><span class="line">                 System.out.println();     </span><br><span class="line">                &#125;</span><br><span class="line">else </span><br><span class="line">if(packet[i] instanceof ARPPacket)&#x2F;&#x2F;如果获取的数据包属于ARPPacket包</span><br><span class="line">&#123;</span><br><span class="line">                ARPPacket arp &#x3D; (ARPPacket) packet[i];&#x2F;&#x2F;ARP</span><br><span class="line">                HexBinaryAdapter head &#x3D;  new HexBinaryAdapter();&#x2F;&#x2F;转成16进制</span><br><span class="line">				String str &#x3D; head.marshal(arp.header);</span><br><span class="line">                byte[] b &#x3D; new byte[4];</span><br><span class="line">                String s1 &#x3D; &quot;&quot;;</span><br><span class="line">                String s2 &#x3D; &quot;&quot;;</span><br><span class="line">                b &#x3D; arp.target_protoaddr;</span><br><span class="line">                s1 +&#x3D; String.valueOf((b[0] &amp; 0xff) + &quot;.&quot; + ( b[1] &amp; 0xff) + &quot;.&quot; + (b[2] &amp; 0xff) + &quot;.&quot; + (b[3] &amp; 0xff));</span><br><span class="line">                b &#x3D; arp.sender_protoaddr;</span><br><span class="line">                s2 +&#x3D; String.valueOf((b[0] &amp; 0xff) + &quot;.&quot; + ( b[1] &amp; 0xff) + &quot;.&quot; + (b[2] &amp; 0xff) + &quot;.&quot; + (b[3] &amp; 0xff));</span><br><span class="line">                for (byte d : arp.sender_hardaddr) </span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(Integer.toHexString(d &amp; 0xff) + &quot;:&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                for (byte e : arp.target_hardaddr) </span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(Integer.toHexString(e &amp; 0xff) + &quot;:&quot;);</span><br><span class="line">                &#125;              </span><br><span class="line">                System.out.println(&quot;Packet &quot; + (i+1) + &quot; : ARP&quot; );</span><br><span class="line">                System.out.println(&quot;    数据 : &quot; + str);</span><br><span class="line">                System.out.println(&quot;    Hardware type: &quot; + arp.hardtype);</span><br><span class="line">                System.out.println(&quot;    protocol type : &quot; + arp.prototype); </span><br><span class="line">                System.out.println(&quot;    Hardware size : &quot; + arp.hlen);</span><br><span class="line">                System.out.println(&quot;    protocol size : &quot; + arp.plen);</span><br><span class="line">                System.out.print(&quot;    sender MAC address: &quot;);</span><br><span class="line">                for (byte d : arp.sender_hardaddr) </span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(Integer.toHexString(d &amp; 0xff) + &quot;:&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(&quot;    sender ip address: &quot; + s2);</span><br><span class="line">                System.out.print(&quot;    target MAC address: &quot; );</span><br><span class="line">                for (byte e : arp.target_hardaddr) </span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print(Integer.toHexString(e &amp; 0xff) + &quot;:&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(&quot;    target ip address: &quot; + s1);</span><br><span class="line">                </span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public static void main(String[] args) throws IOException  &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        &#x2F;&#x2F;数组存放数据包</span><br><span class="line">        Packet[] packet &#x3D; new Packet[max];</span><br><span class="line">        &#x2F;&#x2F;初始化数据包捕获的线程</span><br><span class="line">        AThread t &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;获取网络设备并显示</span><br><span class="line">        NetworkInterface[] devices &#x3D; JpcapCaptor.getDeviceList();</span><br><span class="line">        showDeviceList(devices);</span><br><span class="line">        &#x2F;&#x2F;输入选择的监控的网卡</span><br><span class="line">        System.out.print(&quot;选择需要监听的设备序号:&quot;);</span><br><span class="line">        int card &#x3D; scanner.nextInt();</span><br><span class="line">        card &#x3D; card -1;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;打开选择的网络接口</span><br><span class="line">        JpcapCaptor captor &#x3D; openDevice(devices, card);</span><br><span class="line"></span><br><span class="line">        menu:</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            &#x2F;&#x2F;功能菜单</span><br><span class="line">            System.out.println(&quot;选择功能编号：&quot;);</span><br><span class="line">            System.out.println(&quot;1. 捕获当前网卡的数据包&quot;);</span><br><span class="line">            System.out.println(&quot;2. 停止捕获网络数据包&quot;);       </span><br><span class="line">            System.out.println(&quot;3. 显示当前捕获的数据包&quot;);</span><br><span class="line">            System.out.println(&quot;4. 查看数据包详细信息&quot;);</span><br><span class="line">            System.out.println(&quot;5. 分析数据包的协议分布&quot;);</span><br><span class="line">            System.out.println(&quot;6. 退出！&quot;);</span><br><span class="line">            System.out.print(&quot;你的选择：&quot;);</span><br><span class="line">            &#x2F;&#x2F;用户选择</span><br><span class="line">            int choice &#x3D; scanner.nextInt();&#x2F;&#x2F;输入选择项</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;功能执行(通过选各个类型去决定下一步干什么)</span><br><span class="line">            switch (choice)&#123;</span><br><span class="line">                case 1: System.out.println(&quot;正在捕获数据包...&quot;);&#x2F;&#x2F;选择去抓包抓数据包</span><br><span class="line">                        t &#x3D; new AThread(captor);</span><br><span class="line">                        Thread capThread &#x3D; new Thread(t);</span><br><span class="line">                        capThread.start();</span><br><span class="line">                        break;</span><br><span class="line">                case 2: System.out.println(&quot;已停止捕获数据包&quot;);&#x2F;&#x2F;停止抓数据包 </span><br><span class="line">                        t.cancel();&#x2F;&#x2F;调用停止方法cancel将布尔值的中断标志改为false</span><br><span class="line">                        break;       </span><br><span class="line">                case 3: System.out.println(&quot;显示当前捕获的数据包如下：&quot;);&#x2F;&#x2F;如果线程为空那就显示失败</span><br><span class="line">                        if(t &#x3D;&#x3D; null)</span><br><span class="line">                        &#123;</span><br><span class="line">                            System.out.println(&quot;数据包捕获未开启,失败！&quot;);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        packet &#x3D; t.getPacket(); &#x2F;&#x2F;调用获得数据包的方法</span><br><span class="line">                        showPacket(packet);&#x2F;&#x2F;调用展示数据包的方法</span><br><span class="line">                        break;</span><br><span class="line">                case 4: System.out.println(&quot;数据包详细分析：&quot;);&#x2F;&#x2F;调用展示数据包细节的方法</span><br><span class="line">                        showPacketDetail(packet);</span><br><span class="line">                        break;</span><br><span class="line">                case 5: System.out.println(&quot;数据包的协议分布如下：&quot;);</span><br><span class="line">           	     	analyzePacket(packet);&#x2F;&#x2F;调用分析数据包的方法</span><br><span class="line">                		break;           </span><br><span class="line">                case 6: System.out.println(&quot;退出！&quot;);&#x2F;&#x2F;想要结束就break跳出menu</span><br><span class="line">                		break menu;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();&#x2F;&#x2F;分隔一行为了方便查看</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line"> &#x2F;&#x2F;关闭线程和抓包</span><br><span class="line">        captor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>五设计中的问题以及心得</strong></p>
<ol>
<li>一开始不知道怎么去抓获数据包就去上网搜查和查看数据最终发现可以使用JPCAP扩展，jPcap是一个可以让java工作在链路层的类库调用wincap/libpcap，而给JAVA语言提供一个公共的接口，从而使用插件最终得到抓获数据包的操作。</li>
<li>第一步讨论得到后，与组员讨论最终决定使用主函数调用每个功能模块，既使用模块化设计方法得到功能。但是不知道怎么去抓获数据包之后存储，询问其他同学和查看网络API之后发现可以通过数组去存储数据包，从而用循环去不断的操作。</li>
<li>可以在抓取和实现功能后，发现还需要界面设计达到分析协议软件开发，或者通过GUI图形界面显示。</li>
<li>我和组员分工之后，我主要去实现主函数和TCP协议的分析部分，主要是和组员的代码要能配对起来比较麻烦，最终不断地调试和改bug得到了结果。</li>
<li>抓获数据包最终分析的时候，首部其他内容都可以得到调用方法得到结果，但是TCP和IP检验和部分就比较麻烦，我们最终决定使用推算字节数得到答案。<br>以IP检验和为例：<br>创建一个 HexBinaryAdapter的对象将二进制数组转换为十六进制字符串：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HexBinaryAdapter head &#x3D;  new HexBinaryAdapter();</span><br></pre></td></tr></table></figure>
<p>  定义一个字符串存首部长度head的16进制信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; head.marshal(udp.header);</span><br></pre></td></tr></table></figure>
<p>  计算IP首部部分的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	int tou &#x3D; (str.charAt(29)-48)*4*2;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">因为IP之前的MAC帧就有14个字节，而一个字节就是2位十六进制，然后通过减去0的ASCII码转换成相对应的16进制数字。</span><br><span class="line">而为了获得检验和就需要转字节之后加上之前的12个字节，从13到16就是Ip数据包的检验和部分</span><br><span class="line">System.out.println(&quot;    校验和 : &quot; +str.substring(28+tou+12,28+tou+16));</span><br><span class="line">6. 课设答辩的时候薛老师很负责的提出了我们组的设计存在的问题是：一次性显示了所有数据包的信息但是不能去挑选具体的数据包去分析是哪个协议。-&gt;于是我们在判断语句中输入要挑选的数据包，然后去判断是否存在这个数据包，然后输出分析数据包的内容。</span><br><span class="line">具体解决问题的代码如下(附录中也有)：</span><br><span class="line">在循环中输入想查看的包的序号</span><br></pre></td></tr></table></figure>
<pre><code>System.out.print(&quot;输入你想查看的包序号&quot;);
    Scanner input=new Scanner(System.in);
    int num=input.nextInt();//输入你要选择看的包序号
    num=num-1;
    for(int i = 0; packet[i] != null &amp;&amp; i &lt; max-1; i++) </code></pre><p>{<br>          if(i==num) //如果选的那个数字和循环的符合的话去判断是哪个数据包<br>{<br>…//中间的就是确定存在，然后去判断是哪个协议的数据包从而输出<br>}<br>}</p>
<p>```</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E8%AE%BE-%E8%BD%AF%E4%BB%B6%E4%B8%93%E4%B8%9A%E9%A2%98%E7%9B%AE/" rel="tag">计算机网络课设(软件专业题目)</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webserver" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/19/webserver/" class="article-date">
      <time datetime="2019-12-19T13:13:01.000Z" itemprop="datePublished">2019-12-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/19/webserver/">webserver</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、反射：</strong><br>　　<strong>反射</strong>是框架设计的灵魂（<strong><code>框架</code></strong>是半成品软件，可以在框架的基础上进行软件开发，简化编码）。<br>将类的各个组成部分封装成其他对象</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webserver%E7%BC%96%E7%A8%8B/" rel="tag">webserver编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-TCP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/25/TCP/" class="article-date">
      <time datetime="2019-11-25T02:31:30.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/25/TCP/">TCP编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、TCP(面向连接的通信)</strong><br>　　TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分客户端(Client)和服务器(Server)。<br><strong>二、通信步骤(通信原理)</strong></p>
<ol>
<li>服务器端先启动</li>
<li>客户端请求–&gt;服务器端</li>
<li>客户端&lt; – &gt;服务器端【<strong>逻辑连接(有一个对象)</strong>】</li>
<li>逻辑连接含有<strong>客户端提供</strong>的** <code>IO对象</code> **(字节流对象)</li>
</ol>
<p>** <code>IO对象</code> **<br>TCP连接的示意图：</p>
<p><img src="/2019/11/25/TCP/shiyitu1.png" alt></p>
<ul>
<li><strong>注意：</strong></li>
</ul>
<ol>
<li>服务器必须明确和哪个客户端交互，而且需要多个IO流对象。</li>
</ol>
<ul>
<li><strong>服务器端方法</strong> ** <code>accpet</code> **，客户端获取 –&gt; 客户端对象。</li>
<li>服务器(没有IO流) –&gt; 服务器获取请求客户端对象Socket</li>
<li><strong>(服务器用的客户端的IO流交互)</strong></li>
<li>服务器使用客户端的字节<strong>输入流(读取)</strong>客户端发送的数据</li>
<li>服务器使用客户端的字节<strong>输出流(回写)</strong>给客户端数据</li>
</ul>
<p> <strong><code>Server(服务器)</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.指定端口 使用ServerSocket创建服务器</span><br><span class="line">2.阻塞式等待连接accept</span><br><span class="line">3.操作：使用输入输出流操作</span><br><span class="line">4.释放资源</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">public class Server &#123;</span><br><span class="line">	public static void main(String[] args)throws IOException &#123;</span><br><span class="line">		System.out.println(&quot;----Server(服务器)----&quot;);</span><br><span class="line">		&#x2F;&#x2F;1.指定端口 使用ServerSocket创建服务器</span><br><span class="line">		ServerSocket server&#x3D;new ServerSocket(8088);</span><br><span class="line">		&#x2F;&#x2F;2.阻塞式等待连接accept</span><br><span class="line">		Socket client&#x3D;server.accept();</span><br><span class="line">		System.out.println(&quot;一个客户端建立了连接&quot;);</span><br><span class="line">		&#x2F;&#x2F;3.操作：使用输入输出流操作</span><br><span class="line">		DataInputStream shuru&#x3D;new DataInputStream(client.getInputStream());&#x2F;用DataInputStream输入流</span><br><span class="line">		String data&#x3D;shuru.readUTF();&#x2F;&#x2F;输入</span><br><span class="line">		&#x2F;&#x2F;4.释放资源</span><br><span class="line">		shuru.close();&#x2F;&#x2F;释放shuru</span><br><span class="line">		client.close();&#x2F;&#x2F;释放Client</span><br><span class="line">		server.close();&#x2F;&#x2F;释放server服务器对象</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Client(客户端)</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.建立连接：使用Socket建立窗户段+服务的地址和端口</span><br><span class="line">2.第一步连接好了直接操作：使用输入输出流操作</span><br><span class="line">3.释放资源</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) throws UnknownHostException, IOException&#123;</span><br><span class="line">		System.out.println(&quot;----Client(客户端)----&quot;);</span><br><span class="line">		&#x2F;&#x2F;1.建立连接：使用Socket建立窗户段+服务的地址和端口</span><br><span class="line">		Socket client&#x3D;new Socket(&quot;localhost&quot;,8088);&#x2F;&#x2F;创建client对象去接收服务器的东西</span><br><span class="line">		&#x2F;&#x2F;2.第一步连接好了直接操作：使用输入输出流操作</span><br><span class="line">		DataOutputStream shuchu&#x3D;new DataOutputStream(client.getOutputStream());&#x2F;&#x2F;用DataOutputStream输出流</span><br><span class="line">		String data&#x3D;&quot;hello&quot;;&#x2F;&#x2F;输出一个字符串 hello</span><br><span class="line">		shuchu.writeUTF(data);&#x2F;&#x2F;shuchu写入</span><br><span class="line">		shuchu.flush();</span><br><span class="line">		&#x2F;&#x2F;3.释放资源</span><br><span class="line">		shuchu.close();&#x2F;&#x2F;释放输出</span><br><span class="line">		client.close();	&#x2F;&#x2F;释放client对象		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>三、TCP文件上传</strong><br>　　在前面的基础上只需要将传输的数据做更改即可达到单向传输！</p>
<p><strong><code>Client(客户端)</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) throws UnknownHostException, IOException&#123;</span><br><span class="line">		System.out.println(&quot;----Client(客户端)----&quot;);</span><br><span class="line">		</span><br><span class="line">		BufferedReader console&#x3D;new BufferedReader(new InputStreamReader(System.in));&#x2F;&#x2F;用BufferedReader类型去创建输入用户名和密码</span><br><span class="line">		System.out.println(&quot;请输入用户名&quot;);</span><br><span class="line">		String uname&#x3D;console.readLine();</span><br><span class="line">		System.out.println(&quot;请输入密码&quot;);</span><br><span class="line">		String upassword&#x3D;console.readLine();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1.建立连接：使用Socket建立窗户段+服务的地址和端口</span><br><span class="line">		Socket client&#x3D;new Socket(&quot;localhost&quot;,8088);</span><br><span class="line">		&#x2F;&#x2F;2.第一步连接好了直接操作：使用输入输出流操作</span><br><span class="line">		DataOutputStream shuchu&#x3D;new DataOutputStream(client.getOutputStream());&#x2F;&#x2F;输	</span><br><span class="line">		shuchu.writeUTF(&quot;uname&#x3D;&quot;+uname+&quot;&amp;&quot;+&quot;upassword&#x3D;&quot;+upassword);</span><br><span class="line">		shuchu.flush();</span><br><span class="line">		&#x2F;&#x2F;3.释放资源</span><br><span class="line">		shuchu.close();</span><br><span class="line">		client.close();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong><code>Server(服务器)</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">public class Server &#123;</span><br><span class="line">	public static void main(String[] args)throws IOException &#123;</span><br><span class="line">		System.out.println(&quot;----Server(服务器)----&quot;);</span><br><span class="line">		&#x2F;&#x2F;1.指定端口 使用ServerSocket创建服务器</span><br><span class="line">		ServerSocket server&#x3D;new ServerSocket(8088);</span><br><span class="line">		&#x2F;&#x2F;2.阻塞式等待连接accept</span><br><span class="line">		Socket client&#x3D;server.accept();</span><br><span class="line">		System.out.println(&quot;一个客户端建立了连接&quot;);</span><br><span class="line">		&#x2F;&#x2F;3.操作：使用输入输出流操作</span><br><span class="line">		DataInputStream shuru&#x3D;new DataInputStream(client.getInputStream());&#x2F;&#x2F;输入流</span><br><span class="line">		String datas&#x3D;shuru.readUTF();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;分析数据</span><br><span class="line">		String[] dataArray&#x3D;datas.split(&quot;&amp;&quot;);&#x2F;&#x2F;用&amp;分割</span><br><span class="line">		for(String  info:dataArray)&#x2F;&#x2F;增强型for循环输出</span><br><span class="line">		&#123;</span><br><span class="line">			String[] userinfo&#x3D;info.split(&quot;&#x3D;&quot;);</span><br><span class="line">			System.out.println(userinfo[0]+&quot;--&gt;&quot;+userinfo[1]);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;4.释放资源</span><br><span class="line">		shuru.close();</span><br><span class="line">		client.close();</span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong></p>
<ul>
<li><p>客户端的截图：<br><img src="/2019/11/25/TCP/3client.png" alt></p>
</li>
<li><p>服务器的截图：<br><img src="/2019/11/25/TCP/3server.png" alt></p>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">JAVA-网络编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-传输协议" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/17/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/" class="article-date">
      <time datetime="2019-11-17T13:20:25.000Z" itemprop="datePublished">2019-11-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/17/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/">传输协议(UDP)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、网络爬虫(虚拟)</strong></p>
<ol>
<li>获取URL<br> <code>URL url=new URL(&quot;https://www.jd.com&quot;)</code></li>
<li>下载资源</li>
<li>分析</li>
<li>处理</li>
</ol>
<p><strong>代码实现(取京东的数据)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.URL;</span><br><span class="line">public class pachongle&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception  &#123;&#x2F;&#x2F;抛出异常</span><br><span class="line">		URL url&#x3D;new URL(&quot;https:&#x2F;&#x2F;www.jd.com&quot;);&#x2F;&#x2F;获取京东URL</span><br><span class="line">			InputStream is&#x3D;url.openStream();&#x2F;&#x2F;输入流</span><br><span class="line">			BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(is,&quot;UTF-8&quot;));&#x2F;京东的是UTF-8</span><br><span class="line">			String msg&#x3D;null;&#x2F;&#x2F;定义一个字符串msg</span><br><span class="line">			while(null!&#x3D;(msg&#x3D;br.readLine()))</span><br><span class="line">			&#123;			</span><br><span class="line">			System.out.println(msg);&#x2F;&#x2F;输出</span><br><span class="line">			&#125;</span><br><span class="line">			br.close();&#x2F;&#x2F;一定要记得br对象用完之后关闭</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br>京东的所有源文件(浏览器中的源文件)</p>
<hr>
<ul>
<li>有些网址有权限！！！(<a href="https://www.dianping.com" target="_blank" rel="noopener">https://www.dianping.com</a>)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.URL;</span><br><span class="line">public class pachongle&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception  &#123;</span><br><span class="line">		URL url&#x3D;new URL(&quot;https:&#x2F;&#x2F;www.dianping.com&quot;);&#x2F;&#x2F;换成了点评网址</span><br><span class="line">			InputStream is&#x3D;url.openStream();</span><br><span class="line">			BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(is,&quot;UTF-8&quot;));</span><br><span class="line">			String msg&#x3D;null;</span><br><span class="line">			while(null!&#x3D;(msg&#x3D;br.readLine()))</span><br><span class="line">			&#123;			</span><br><span class="line">			System.out.println(msg);</span><br><span class="line">			&#125;</span><br><span class="line">			br.close();</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提示<strong>403问题</strong>(有权限)通过简单的抓取无法做到</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.io.IOException: Server returned HTTP response code: 403 for URL: https:&#x2F;&#x2F;www.dianping.com</span><br><span class="line">	at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(Unknown Source)</span><br><span class="line">	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(Unknown Source)</span><br><span class="line">	at sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(Unknown Source)</span><br><span class="line">	at java.net.URL.openStream(Unknown Source)</span><br><span class="line">	at pachong.pachongle.main(pachongle.java:9)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>模拟浏览器<code>HttpURLConnection</code></strong></li>
</ul>
<ol>
<li>//get从服务器获取资源<pre><code>对象.setRequestMethod(&quot;GET&quot;);</code></pre></li>
<li>//post往服务器上推数据<pre><code>对象.setRequestProperty(&quot;XXXXX&quot;);</code></pre></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.HttpURLConnection;</span><br><span class="line">import java.net.URL;</span><br><span class="line">public class pachongle&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception  &#123;</span><br><span class="line">		URL url&#x3D;new URL(&quot;https:&#x2F;&#x2F;www.dianping.com&quot;);</span><br><span class="line">			&#x2F;&#x2F;用HttpURLConnection类</span><br><span class="line">			HttpURLConnection conn&#x3D;(HttpURLConnection)url.openConnection();</span><br><span class="line">			&#x2F;&#x2F;get从服务器获取资源</span><br><span class="line">			conn.setRequestMethod(&quot;GET&quot;);</span><br><span class="line">			&#x2F;&#x2F;post往服务器上推数据</span><br><span class="line">			conn.setRequestProperty(&quot;XXXXX&quot;);</span><br><span class="line">			 </span><br><span class="line">			BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(conn.InputStream(),&quot;UTF-8&quot;));</span><br><span class="line">			String msg&#x3D;null;</span><br><span class="line">			while(null!&#x3D;(msg&#x3D;br.readLine()))</span><br><span class="line">			&#123;			</span><br><span class="line">			System.out.println(msg);</span><br><span class="line">			&#125;</span><br><span class="line">			br.close();</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>二、UDP(非面向连接)</strong></p>
<ol>
<li>使用基于UDP协议的<strong>Socket网络编程</strong>实现</li>
<li>不需要利用<strong>IO流</strong>实现数据传输</li>
<li>每个数据发送单元被统一<strong>封装</strong>成数据包。发送方将数据包发送到网络中，数据包在网络中寻找目的地。</li>
</ol>
<p><strong>UDP基本概念：</strong></p>
<ul>
<li><code>DatagramSocket</code>：用于发送/接收数据包的套接字</li>
</ul>
<ol>
<li>send(DatagramPacket 对象)</li>
<li>receive(DatagramPacket 对象)</li>
<li>close()</li>
</ol>
<ul>
<li><code>DatagramPacket</code>：数据包<br>主要创建对象new(容器，0，长度)</li>
</ul>
<p><strong>发送端(client)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.使用DatagramSocket端口创建接收端</span><br><span class="line">2.准备数据(转成字节数组)</span><br><span class="line">3.封装成DatagramPacket包裹(指定目的地)</span><br><span class="line">4.发送包裹send(DatagramPacket p)</span><br><span class="line">5.释放资源</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line">public class udpClient&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">			System.out.println(&quot;发送方启动中...&quot;);</span><br><span class="line">			&#x2F;&#x2F;1.使用DatagramSocket端口创建接收端</span><br><span class="line">			DatagramSocket client&#x3D;new DatagramSocket(8888);</span><br><span class="line">			&#x2F;&#x2F;2.准备数据(转成字节数组)</span><br><span class="line">			String data&#x3D;&quot;西安工程大学&quot;;</span><br><span class="line">			byte[] datas&#x3D;data.getBytes();</span><br><span class="line">			&#x2F;&#x2F;3.封装成DatagramPacket包裹(指定目的地)</span><br><span class="line">			DatagramPacket packet&#x3D;new DatagramPacket(datas,0,datas.length,new InetSocketAddress(&quot;localhost&quot;,9999));</span><br><span class="line">			&#x2F;&#x2F;4.发送包裹send(DatagramPacket p)</span><br><span class="line">			client.send(packet);</span><br><span class="line">			&#x2F;&#x2F;5.释放资源</span><br><span class="line">			client.close();</span><br><span class="line">			 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接收端(server)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.使用DatagramSocket端口创建接收端</span><br><span class="line">2.准备容器，封装成DatagramPacket包裹</span><br><span class="line">3.阻塞式接收包裹receive(DatagramPacket p)</span><br><span class="line">4.分析数据 getData()&#x2F;getLength()</span><br><span class="line">5.释放资源</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line">public class udpServer&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;接收方启动中...&quot;);</span><br><span class="line">		&#x2F;&#x2F;1.使用DatagramSocket端口创建接收端</span><br><span class="line">		DatagramSocket server&#x3D;new DatagramSocket(9999);&#x2F;&#x2F;发送的包里面也必须是9999</span><br><span class="line">		 &#x2F;&#x2F;2.准备容器，封装成DatagramPacket包裹</span><br><span class="line">		byte[] container&#x3D;new byte[1024*60];</span><br><span class="line">		DatagramPacket packet&#x3D;new DatagramPacket(container,0,container.length);</span><br><span class="line">		 &#x2F;&#x2F;3.阻塞式接收包裹receive(DatagramPacket p)</span><br><span class="line">		server.receive(packet);</span><br><span class="line">		 &#x2F;&#x2F;4.分析数据 getData()&#x2F;getLength()</span><br><span class="line">		byte[] datas&#x3D;packet.getData();</span><br><span class="line">		int len&#x3D;packet.getLength();</span><br><span class="line">		System.out.println(new String(datas,0,len));</span><br><span class="line">		 &#x2F;&#x2F;5.释放资源	</span><br><span class="line">		server.close();</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/11/17/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/udp.png" alt></p>
<hr>
<ul>
<li><strong>多次交流的前提：(多次输入)</strong></li>
</ul>
<p><strong>发送端(client)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line">public class udpClient&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">			System.out.println(&quot;发送方启动中...&quot;);</span><br><span class="line">			&#x2F;&#x2F;1.使用DatagramSocket端口创建接收端</span><br><span class="line">			DatagramSocket client&#x3D;new DatagramSocket(8888);</span><br><span class="line">			&#x2F;&#x2F;2.准备数据(转成字节数组)</span><br><span class="line">			BufferedReader reader&#x3D;new BufferedReader(new InputStreamReader(System.in));&#x2F;&#x2F;使用这个控制台输入</span><br><span class="line">			</span><br><span class="line">			while(true) &#x2F;&#x2F;多了一个while循环</span><br><span class="line">			&#123;</span><br><span class="line">				String data&#x3D;reader.readLine();&#x2F;&#x2F;对象不断输入</span><br><span class="line">			</span><br><span class="line">			byte[] datas&#x3D;data.getBytes();</span><br><span class="line">			&#x2F;&#x2F;3.封装成DatagramPacket包裹(指定目的地)</span><br><span class="line">			DatagramPacket packet&#x3D;new DatagramPacket(datas,0,datas.length,new InetSocketAddress(&quot;localhost&quot;,9999));</span><br><span class="line">			&#x2F;&#x2F;4.发送包裹send(DatagramPacket p)</span><br><span class="line">			client.send(packet);  </span><br><span class="line">		     	if(data.equals(&quot;bye&quot;))  &#x2F;&#x2F;当输入的数据为bye时输出</span><br><span class="line">			    &#123;</span><br><span class="line">		     		break;</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;5.释放资源</span><br><span class="line">			client.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接收端(server)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line">public class udpServer&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;接收方启动中...&quot;);</span><br><span class="line">		&#x2F;&#x2F;1.使用DatagramSocket端口创建接收端</span><br><span class="line">		DatagramSocket server&#x3D;new DatagramSocket(9999);&#x2F;&#x2F;发送的包里面也必须是9999</span><br><span class="line">		 &#x2F;&#x2F;2.准备容器，封装成DatagramPacket包裹</span><br><span class="line">		while(true) &#123;  &#x2F;&#x2F;比之前的多了一个while循环</span><br><span class="line">		byte[] container&#x3D;new byte[1024*60];</span><br><span class="line">		DatagramPacket packet&#x3D;new DatagramPacket(container,0,container.length);</span><br><span class="line">		 &#x2F;&#x2F;3.阻塞式接收包裹receive(DatagramPacket p)</span><br><span class="line">		server.receive(packet);</span><br><span class="line">		 &#x2F;&#x2F;4.分析数据 getData()&#x2F;getLength()</span><br><span class="line">		byte[] datas&#x3D;packet.getData();</span><br><span class="line">		int len&#x3D;packet.getLength();</span><br><span class="line">		String data&#x3D;new String(datas,0,len);</span><br><span class="line">		System.out.println(data);</span><br><span class="line">		if(data.equals(&quot;bye&quot;))  &#x2F;&#x2F;当最后的数据为bye就结束</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;5.释放资源	</span><br><span class="line">		server.close();</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>三、UDP多次交流(多线程)</strong></p>
<p><strong><code>TalkReceive类</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package UDP;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line">public class TalkReceive implements Runnable &#123;</span><br><span class="line">	private DatagramSocket server;</span><br><span class="line">	&#x2F;&#x2F;1.</span><br><span class="line">	public TalkReceive(int port) &#123;	</span><br><span class="line">		try &#123;</span><br><span class="line">			server&#x3D;new DatagramSocket(port);&#x2F;&#x2F;抛出异常</span><br><span class="line">		&#125; catch (SocketException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;2.</span><br><span class="line">	</span><br><span class="line">	@Override </span><br><span class="line">   public void run() &#123;   &#x2F;&#x2F;将封装udpServer中的while循环内容</span><br><span class="line">		while(true) &#123;</span><br><span class="line">			byte[] container&#x3D;new byte[1024*60];</span><br><span class="line">			DatagramPacket packet&#x3D;new DatagramPacket(container,0,container.length);</span><br><span class="line">			 &#x2F;&#x2F;3.阻塞式接收包裹receive(DatagramPacket p)</span><br><span class="line">			try &#123;</span><br><span class="line">				server.receive(packet);</span><br><span class="line">			 &#x2F;&#x2F;4.分析数据 getData()&#x2F;getLength()</span><br><span class="line">				byte[] datas&#x3D;packet.getData();</span><br><span class="line">				int len&#x3D;packet.getLength();</span><br><span class="line">				String data&#x3D;new String(datas,0,len);</span><br><span class="line">				System.out.println(data);</span><br><span class="line">				if(data.equals(&quot;bye&quot;))</span><br><span class="line">				&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#x2F;&#x2F;5.释放资源	</span><br><span class="line">				server.close();					   </span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>TalkSend类</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 封装updTalkClient</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TalkSend implements Runnable&#123;</span><br><span class="line">   &#x2F;&#x2F;1</span><br><span class="line">	private DatagramSocket client;</span><br><span class="line">	private BufferedReader reader;</span><br><span class="line">	private String toIP;&#x2F;&#x2F;对方地址</span><br><span class="line">	private int toPort;&#x2F;&#x2F;对方端口</span><br><span class="line">   public TalkSend(int port,String toIP,int toPort) &#123;</span><br><span class="line">	   this.toIP&#x3D;toIP;</span><br><span class="line">	   this.toPort&#x3D;toPort;</span><br><span class="line">	   try &#123;</span><br><span class="line">		client&#x3D;new DatagramSocket(port);</span><br><span class="line">		reader&#x3D;new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">	&#125; catch (SocketException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;2  </span><br><span class="line">	@Override</span><br><span class="line">   public void run() &#123; &#x2F;&#x2F;直接将updTalkClient中的while拿过来</span><br><span class="line">		  while(true)</span><br><span class="line">			&#123;</span><br><span class="line">				String data;</span><br><span class="line">				try &#123;</span><br><span class="line">					data &#x3D; reader.readLine();</span><br><span class="line">					byte[] datas&#x3D;data.getBytes();</span><br><span class="line">					&#x2F;&#x2F;3.封装成DatagramPacket包裹(指定目的地)</span><br><span class="line">					DatagramPacket packet&#x3D;new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toPort));&#x2F;&#x2F;将本地主机换成toIP和toPort端口</span><br><span class="line">					&#x2F;&#x2F;4.发送包裹send(DatagramPacket p)</span><br><span class="line">					try &#123;</span><br><span class="line">						client.send(packet);</span><br><span class="line">					&#125; catch (IOException e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				     	if(data.equals(&quot;bye&quot;))</span><br><span class="line">					    &#123;</span><br><span class="line">				     		break;</span><br><span class="line">					    &#125;</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;5.释放资源</span><br><span class="line">				client.close();</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后构建两个对话类</p>
<p><strong><code>TalkTeacher类</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TalkTeacher &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(new TalkReceive(9999)).start();&#x2F;&#x2F;接收9999</span><br><span class="line">		new Thread(new TalkSend(5555,&quot;localhost&quot;,8888)).start();&#x2F;&#x2F;8888发送</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>TalkStudent类</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 加入多线程，实现双向交流 模拟在线咨询</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TalkStudent &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(new TalkSend(7777,&quot;localhost&quot;,9999)).start();&#x2F;&#x2F;9999发送</span><br><span class="line">		new Thread(new TalkReceive(8888)).start();&#x2F;&#x2F;接收8888</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>四、TCP的使用(面向连接可靠)</strong><br>    相对于UDP而言，TCP是一种面向连接的通讯方式，提供一种可靠的方法。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">JAVA-网络编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-第十届蓝桥杯省赛" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/13/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B/" class="article-date">
      <time datetime="2019-11-13T14:52:00.000Z" itemprop="datePublished">2019-11-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/13/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B/">第十届蓝桥杯省赛</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、组队问题</strong></p>
<ul>
<li><strong>问题描述</strong><br>作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。<br>每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1<br>号位至 5 号位的评分之和最大可能是多少？</li>
</ul>
<p><img src="/2019/11/13/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B/diyiti.png" alt></p>
<ul>
<li><p><strong>问题分析</strong>：<br>　　这个题目我记得当时我拿到手里没考虑写代码，就是手算的答案490！今天好好考虑了一下这个题目，其实用<strong>暴力求解</strong>就可以。<br>　　用一个二维数组来存放这个表的信息，然后设置一些变量来代表1-号位，通过判断条件(五个人必须不一样！！)就可以输出结果。</p>
</li>
<li><p><strong>代码如下：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in); </span><br><span class="line">		int[][] team &#x3D; new int[20][5];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 20; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 5; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				team[i][j] &#x3D; input.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		int maxSum &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 20; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 20; j++)</span><br><span class="line">				for (int k &#x3D; 0; k &lt; 20; k++)</span><br><span class="line">					for (int h &#x3D; 0; h &lt; 20; h++)</span><br><span class="line">						for (int g &#x3D; 0; g &lt; 20; g++)</span><br><span class="line">							if ((i !&#x3D; j &amp;&amp; i !&#x3D; k &amp;&amp; i !&#x3D; h &amp;&amp; i !&#x3D; g) &amp;&amp; (j !&#x3D; k &amp;&amp; j !&#x3D; h &amp;&amp; j !&#x3D; g)&amp;&amp; (k !&#x3D; h &amp;&amp; k !&#x3D; g) &amp;&amp; h !&#x3D; g)&#x2F;&#x2F;必须五个人不同才可以</span><br><span class="line">							&#123;</span><br><span class="line">								int max &#x3D; team[i][0] + team[j][1] + team[k][2] + team[h][3] + team[g][4];&#x2F;&#x2F;循环取值计算出每种可能的值</span><br><span class="line">								if (max &gt; maxSum)</span><br><span class="line">									maxSum &#x3D; max;&#x2F;&#x2F;输出最大值的可能取值</span><br><span class="line">							&#125;</span><br><span class="line">		System.out.println(maxSum);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果如下：</strong><br>输出：490</li>
</ul>
<hr>
<p><strong>二、不同子串</strong></p>
<ul>
<li><p><strong>问题描述</strong><br>一个字符串的非空子串是指字符串中长度至少为 1 的连续的一段字符组成 的串。例如，字符串aaab 有非空子串a, b, aa, ab, aaa, aab, aaab，一共 7 个。 注意在计算时，只算本质不同的串的个数。<br>请问，字符串0100110001010001   有多少个不同的非空子串？</p>
</li>
<li><p><strong>问题分析</strong>：<br>　 我记得当时都没算出来，一遇到这种题目我就死了，学完了JAVA的<strong>Set集合</strong>之后发现可以直接调用其中的方法快速解题！(<code>substring(int i,int j)</code>)</p>
</li>
<li><p><strong>代码如下：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	      String s&#x3D;input.nextLine();</span><br><span class="line">	      Set&lt;String&gt; set&#x3D;new TreeSet&lt;String&gt;();</span><br><span class="line">	      for (int i &#x3D; 1; i &lt;&#x3D; s.length(); ++i) </span><br><span class="line">	      &#123;&#x2F;&#x2F; 长度</span><br><span class="line">				for (int j &#x3D; 0; j &lt;&#x3D; s.length() - i; ++j)</span><br><span class="line">				&#123;&#x2F;&#x2F; 起点</span><br><span class="line">					if (!set.contains(s.substring(j, j + i)))</span><br><span class="line">						set.add(s.substring(j, j + i));&#x2F;&#x2F;增加个数</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">     	System.out.println(set.size());&#x2F;&#x2F;输出add之后的长度</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果如下：</strong></li>
</ul>
<p><img src="/2019/11/13/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B/dierti.png" alt></p>
<hr>
<p><strong>三、数列求值</strong></p>
<ul>
<li><strong>问题描述</strong><br>给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求<br>第 20190324 项的最后 4 位数字。</li>
<li><strong>问题分析</strong>：<br>　　首先想到的就是用<strong>递归</strong>求解，但是考虑会超时和内存过大，所以考虑使用<strong>动态规划/循环求解</strong>；接下来考虑求后四位的话我们不用考虑前面的数字，所以每次求解出来答案就对其<strong>与10000取余</strong>得出答案。</li>
<li><strong>循环求解：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package javaapplication1;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class JavaApplication1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">      int n&#x3D;input.nextInt();</span><br><span class="line">      int[] a&#x3D;new int[n];&#x2F;&#x2F;用数组去存放这个结果</span><br><span class="line">      a[0]&#x3D;1;</span><br><span class="line">      a[1]&#x3D;1;</span><br><span class="line">      a[2]&#x3D;1;&#x2F;&#x2F;给前三个数字赋值</span><br><span class="line">      for(int i&#x3D;3;i&lt;n;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          a[i]&#x3D;(a[i-1]+a[i-2]+a[i-3])%10000;&#x2F;&#x2F;算出每一个值就对其取余(前面的位数不考虑)</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(a[n-1]); &#x2F;&#x2F;输出20190324项的结果</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>动态规划：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class qiujie&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a &#x3D; 1, b &#x3D; 1, c &#x3D; 1;</span><br><span class="line">		&#x2F;&#x2F; 要是求第四项，则i &lt; 4, 同理推得求20190324，则i &lt; 20190324。</span><br><span class="line">		for (int i &#x3D; 3; i &lt; 20190324; i++) &#123;</span><br><span class="line">			int temp &#x3D; (a + b + c) % 10000;</span><br><span class="line">			a &#x3D; b;</span><br><span class="line">			b &#x3D; c; &#x2F;&#x2F;不断地更替三个数值，就可以减少重复计算中间值</span><br><span class="line">			c &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果如下：</strong><br>输出：4659</li>
</ul>
<hr>
<p><strong>四、数的分解</strong></p>
<ul>
<li><p><strong>问题描述</strong><br>把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法？<br>注意交换 3 个整数的顺序被视为同一种方法，例如1000+1001+18和1001+1000+18被视为同一种。</p>
</li>
<li><p><strong>问题分析</strong>：<br>　　一开始就想着三个数字从0-2019循环暴力判断符合条件的输出，但是发现三层循环复杂度太大，最后选择两层循环，(第三个值=2019-第一个值-第二个值)。将判断不包含数字 2 和 4的情况写成一个Ok方法。</p>
</li>
<li><p><strong>代码如下：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	      int n&#x3D;input.nextInt();</span><br><span class="line">	      int sum&#x3D;0;</span><br><span class="line">	      for(int i&#x3D;1;i&lt;&#x3D;n&#x2F;2;i++)&#x2F;&#x2F;因为防止重复计数，因此i只能到n&#x2F;2处</span><br><span class="line">	      &#123;</span><br><span class="line">	    	  if(Ok(i))&#x2F;&#x2F;如果满足条件去找j</span><br><span class="line">	    	  &#123;</span><br><span class="line">	    		  for(int j&#x3D;i+1;(j&lt;n)&amp;&amp;(j&lt;(n-i-j));j++)&#x2F;&#x2F;各不相同所以j从i+1开始，并且满足第二个数小于第三个数(递增的思路)</span><br><span class="line">	    		  &#123;</span><br><span class="line">	    			  int k&#x3D;n-i-j;	 &#x2F;&#x2F;直接用减法(减少三层循环的时间复杂度)</span><br><span class="line">	    	    		if(Ok(j)&amp;&amp;Ok(k))</span><br><span class="line">	    	    			 sum++;&#x2F;&#x2F;满足条件就让结果可能+1</span><br><span class="line">	    		  &#125;</span><br><span class="line">	    	  &#125;</span><br><span class="line">	      &#125;</span><br><span class="line">	      </span><br><span class="line">	    	System.out.println(sum);  </span><br><span class="line">	      </span><br><span class="line">	&#125;   </span><br><span class="line"></span><br><span class="line">	private static boolean Ok(int i) &#123;</span><br><span class="line">  	  while(i!&#x3D;0)</span><br><span class="line">  	  &#123;	  </span><br><span class="line">  		  if(i%10&#x3D;&#x3D;2||i%10&#x3D;&#x3D;4)     &#x2F;&#x2F;把数拆开如果有2和4有关就要返回错误(false)</span><br><span class="line">  			  return false;</span><br><span class="line">  		  else</span><br><span class="line">  			  i&#x3D;i&#x2F;10;</span><br><span class="line">  	  &#125; 	  </span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果如下：</strong></li>
</ul>
<p><img src="/2019/11/13/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B/disiti.png" alt></p>
<hr>
<p><strong>五、特别数的和</strong></p>
<ul>
<li><p><strong>问题描述</strong><br>小明对数位中含有 2、0、1、9的数字很感兴趣（不包括前导 0），在1到40 中这样的数包括 1、2、9、10至32、39和40，共28个，他们的和是574。请问，在1到n中，所有这样的数的和是多少？<br>【输入格式】<br>输入一行包含两个整数 n。<br>【输出格式】<br>输出一行，包含一个整数，表示满足条件的数的和。<br>【样例输入】<br>40<br>【样例输出】<br>574<br>【评测用例规模与约定】<br>对于 20% 的评测用例，1 ≤ n ≤ 10。 对于 50% 的评测用例，1 ≤ n ≤ 100。 对于 80% 的评测用例，1 ≤ n ≤ 1000。 对于所有评测用例，1 ≤  n ≤ 10000</p>
</li>
<li><p><strong>问题分析</strong>：<br>　　这道题就是考虑将一<strong>个数字不断地拆开判断每一位是不是和四个数字有关系</strong>，然后编写一个判断函数duibudui()去判断，循环一个一个数字去判断。主要是判断的函数考虑<strong>%10取数</strong>(1234%10=4取出最后一位)，<strong>/10拆数</strong>(1234/10=123拆小一点)。</p>
</li>
<li><p><strong>代码如下：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	      int n&#x3D;input.nextInt();</span><br><span class="line">	      int sum&#x3D;0;</span><br><span class="line">	      for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#x2F;&#x2F;循环调用方法满足就sum加上当前值</span><br><span class="line">	     &#123;</span><br><span class="line">	    	 if(duibudui(i))</span><br><span class="line">	    		 sum+&#x3D;i; </span><br><span class="line">	     &#125;	      </span><br><span class="line">	     System.out.println(sum);&#x2F;&#x2F;输出最终值	     </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static boolean duibudui(int i)  &#x2F;&#x2F;判断是不是满足题意</span><br><span class="line">	&#123;</span><br><span class="line">		每次循环就是将数字拆小(直到最后拆没了就跳出来)</span><br><span class="line">		while(i!&#x3D;0)</span><br><span class="line">		&#123;</span><br><span class="line">			if (i%10&#x3D;&#x3D;2||i%10&#x3D;&#x3D;0||i%10&#x3D;&#x3D;1||i%10&#x3D;&#x3D;9)&#x2F;&#x2F;每次取出一位判断是不是和2&#x2F;0&#x2F;1&#x2F;9四个数字有关(1234%10&#x3D;4)</span><br><span class="line">				return true;</span><br><span class="line">			 i&#x2F;&#x3D;10;&#x2F;&#x2F;将这个判断的数字拆小(1234&#x2F;10&#x3D;123)</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果如下：</strong></li>
</ul>
<p><img src="/2019/11/13/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B/diwuti.png" alt></p>
<hr>
<p><strong>六、年号子串</strong></p>
<ul>
<li><p><strong>问题描述</strong><br>小明用字母 A 对应数字 1，B 对应 2，以此类推，用 Z 对应 26。对于 27 以上的数字，小明用两位或更长位的字符串来对应，例如 AA 对应 27，AB 对 应 28，AZ 对应 52，LQ 对应 329。<br>请问 2019 对应的字符串是什么？</p>
</li>
<li><p><strong>问题分析</strong>：<br>　　当时是手算的答案，现在下来仔细看了看也就是<strong>26进制</strong>，只不过就是拆一次数判断出来的结果放在数组之后要反序输出。</p>
</li>
<li><p><strong>代码如下：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	      int n&#x3D;input.nextInt();</span><br><span class="line">	      char[] a&#x3D;&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;U&#39;,&#39;V&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;&#125;;&#x2F;&#x2F;直接利用下标取数</span><br><span class="line">	      char[] b&#x3D;new char[10];</span><br><span class="line">	      int m&#x3D;1;</span><br><span class="line">	      int i&#x3D;0;</span><br><span class="line">	      if(n&lt;&#x3D;26)</span><br><span class="line">	    	  System.out.println(a[n-1]);&#x2F;&#x2F;26之内就输出对应的结果</span><br><span class="line">	      else</span><br><span class="line">	      &#123;</span><br><span class="line">	    	  while(n!&#x3D;0)</span><br><span class="line">	    	  &#123;</span><br><span class="line">	    		  m&#x3D;n%26;  &#x2F;&#x2F;拆开这个数最低位判断输出哪个字母</span><br><span class="line">	    		  b[i++]&#x3D;a[m-1];&#x2F;&#x2F;因为A是0，所以输出a[m-1]</span><br><span class="line">	    		  n&#x3D;n&#x2F;26;  &#x2F;&#x2F;然后将判断的数组拆成更小的数	    		</span><br><span class="line">	    	  &#125;  </span><br><span class="line">	      &#125;</span><br><span class="line">	     	      </span><br><span class="line">	      for(int j&#x3D;b.length-1;j&gt;&#x3D;0;j--) &#x2F;&#x2F;反序输出</span><br><span class="line">	      &#123;</span><br><span class="line">	    	  if(b[j]!&#x3D;0)</span><br><span class="line">	    	  System.out.print(b[j]); </span><br><span class="line">	      &#125;  </span><br><span class="line">	      </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果如下：</strong></li>
</ul>
<p><img src="/2019/11/13/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B/diliuti.png" alt></p>
<hr>
<p><strong>七、等差数列</strong></p>
<ul>
<li><p><strong>问题描述</strong><br>数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一部分的数列，只记得其中N 个整数。<br>现在给出这N 个整数，小明想知道包含这N 个整数的最短的等差数列有几项？<br>【输入格式】<br>输入的第一行包含一个整数N。<br>第二行包含N 个整数<br>【输出格式】<br>输出一个整数表示答案。<br>【样例输入】<br>5<br>2 6 4 10 20<br>【样例输出】<br>10<br>【样例说明】<br>包含2、6、4、10、20 的最短的等差数列是2、4、6、8、10、12、14、16、18、20。<br>【评测用例规模与约定】<br>对于所有评测用例，2≤N≤1000002≤N≤100000   </p>
</li>
<li><p><strong>问题分析</strong>：<br>　　这道题其实主要是有坑(d=0的情况)，只需要将输入的数字存放在数组中然后排序之后找到两两之间最小的差就是d(因此输入的数字不一定是相邻的，可能是中间隔了好几个数)，利用等差数列的第An项公式：<code>An=A1+(n-1)*d</code>求出n就是所求的值</p>
</li>
<li><p><strong>代码如下：</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	      int n&#x3D;input.nextInt();</span><br><span class="line">	      int[] a&#x3D;new int[n];</span><br><span class="line">	      for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line">	      &#123;</span><br><span class="line">	    	  a[i]&#x3D;input.nextInt();&#x2F;&#x2F;输入数字</span><br><span class="line">	      &#125;</span><br><span class="line">	      Arrays.sort(a);&#x2F;&#x2F;排序</span><br><span class="line">	      int d&#x3D;100;</span><br><span class="line">	      int cha&#x3D;0;</span><br><span class="line">	      for(int i&#x3D;0;i&lt;a.length-1;i++)</span><br><span class="line">	      &#123;</span><br><span class="line">	    	 cha&#x3D;a[i+1]-a[i];</span><br><span class="line">	    	 if(cha&lt;d)&#x2F;&#x2F;依次两两判断最小的差距就是公式d</span><br><span class="line">	    		 d&#x3D;cha;</span><br><span class="line">	      &#125;</span><br><span class="line">	      if(d&#x3D;&#x3D;0)</span><br><span class="line">	    	  System.out.println(n);</span><br><span class="line">	      else</span><br><span class="line">	      &#123;</span><br><span class="line">	    	  n&#x3D;(a[a.length-1]-a[0])&#x2F;d+1;&#x2F;&#x2F;利用数组公式求出n(最小的就应该是排序之后的第一个和最后一个之间的数列)</span><br><span class="line">	    	  System.out.println(n);</span><br><span class="line">	      &#125;	      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果如下：</strong></li>
</ul>
<p><img src="/2019/11/13/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B/diqiti.png" alt></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" rel="tag">蓝桥杯</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
      <time datetime="2019-11-12T03:11:25.000Z" itemprop="datePublished">2019-11-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、网络编程</strong></p>
<ul>
<li><strong>端口：</strong>实现多个电脑软件交互(app之间);</li>
<li><strong>URL：</strong>区分软件的资源;</li>
<li><strong>Ip：</strong>通过ip地址定位电脑(公网-&gt;内网);</li>
<li><strong>协议：</strong>交流的方式(例如：普通话);<br>例如：传输层的TCP/UDP协议</li>
</ul>
<table>
<thead>
<tr>
<th>TCP协议</th>
<th>UDP协议</th>
</tr>
</thead>
<tbody><tr>
<td>面向连接</td>
<td>非面向连接</td>
</tr>
<tr>
<td>不高效</td>
<td>高效</td>
</tr>
<tr>
<td>可靠</td>
<td>不可靠</td>
</tr>
</tbody></table>
<hr>
<p><strong>二、InetAddress类</strong><br> <code>java.net.InetAddress</code>—&gt;表示Internet协议(IP)地址</p>
<ul>
<li>InetAddress类的<strong>静态方法</strong>：</li>
</ul>
<ol>
<li><code>getLocalHost</code>返回本机</li>
<li><code>getByName</code>根据域名DNS/IP地址—&gt;解析IP地址</li>
</ol>
<ul>
<li><strong>成员方法</strong>(对象调用)</li>
</ul>
<ol>
<li><code>getHostAddress</code>返回地址</li>
<li><code>getHostName</code>返回计算机名</li>
</ol>
<p>举例代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">public class JiaNLi &#123;</span><br><span class="line">	public static void main(String[] args) throws UnknownHostException &#123;</span><br><span class="line">	&#x2F;&#x2F;创建getLocalHost方法创建一个InetAddress对象</span><br><span class="line">	InetAddress addr&#x3D;InetAddress.getLocalHost();</span><br><span class="line">	System.out.println(addr.getHostAddress());&#x2F;&#x2F;返回：10.2.41.239</span><br><span class="line">	System.out.println(addr.getHostName());&#x2F;&#x2F;DESKTOP-VMNQVVJ</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;根据域名可以得到netAddress对象</span><br><span class="line">	addr&#x3D;InetAddress.getByName(&quot;www.baidu.com&quot;);&#x2F;&#x2F;使用域名www.baidu.com</span><br><span class="line">	System.out.println(addr.getHostAddress());&#x2F;&#x2F;返回百度服务器的ip:39.156.66.18</span><br><span class="line">	System.out.println(addr.getHostName());&#x2F;&#x2F;www.baidu.com</span><br><span class="line">	</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码结果如下：</p>
<p><img src="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/zhuji.png" alt></p>
<hr>
<p><strong>三、端口(区分软件)</strong></p>
<ul>
<li><strong>端口分类：</strong></li>
</ul>
<table>
<thead>
<tr>
<th>公认端口</th>
<th>注册端口</th>
<th>动态/私有端口</th>
</tr>
</thead>
<tbody><tr>
<td>0-1023</td>
<td>1024-49151</td>
<td>49152-65535</td>
</tr>
<tr>
<td>分配给专用的</td>
<td>用户进程/应用程序</td>
<td>一般设置这个范围</td>
</tr>
</tbody></table>
<ul>
<li><strong>查看端口情况：</strong></li>
</ul>
<p>查看<strong>所有</strong>端口：netstat -ano</p>
<p><img src="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/diyi.png" alt></p>
<p>查看<strong>指定</strong>端口：netstat -aon|findstr “xxx”</p>
<p><img src="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/dier.png" alt></p>
<p>查看指定<strong>进程</strong>：tasklist|findstr “xxx”</p>
<p><img src="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/disan.png" alt></p>
<p>查看<strong>具体程序</strong>：使用任务管理器查看PID</p>
<p><img src="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/disi.png" alt></p>
<hr>
<p><strong>四、InetSocketAddress类</strong><br><code>java.net.InetSocketAddress</code>—&gt;实现<strong>IP套接字地址(IP地址+端口号)</strong>，可以是一对(主机号+端口号)，在这种情况下主机号要DNS一下IP地址。</p>
<ul>
<li><strong>构造器:</strong><br><code>new InetSocketAddress(&quot;地址|域名&quot;,端口)</code><br>例如：<pre><code>`InetSocketAddress socketAddress=new InetSocketAddress(&quot;127.0.0.1&quot;,8080);`
`InetSocketAddress socketAddress2=new InetSocketAddress(&quot;localhost&quot;,9000);`</code></pre></li>
<li><strong>方法：</strong></li>
</ul>
<ol>
<li><code>getAddress：</code>返回地址</li>
<li><code>getPort()：</code>返回端口号</li>
<li><code>getHostString</code>：返回主机号/地址的String形式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">public class JiaNLi &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	&#x2F;&#x2F;构造器：new InetSocketAddress(&quot;地址|域名&quot;,端口)</span><br><span class="line">		InetSocketAddress socketAddress&#x3D;new InetSocketAddress(&quot;127.0.0.1&quot;,8080);</span><br><span class="line">		InetSocketAddress socketAddress2&#x3D;new InetSocketAddress(&quot;localhost&quot;,9000);</span><br><span class="line">		System.out.println(socketAddress.getHostName()); &#x2F;&#x2F;返回主机名--127.0.0.1</span><br><span class="line">		System.out.println(socketAddress2.getAddress());&#x2F;&#x2F;返回地址--localhost&#x2F;127.0.0.1</span><br><span class="line">		System.out.println(socketAddress2.getPort());&#x2F;&#x2F;获取端口号--9000</span><br><span class="line">		System.out.println(socketAddress2.getHostString());返回主机名&#x2F;地址的String形式--localhost</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket.png" alt></p>
<hr>
<p><strong>五、URL(区分软件资源)</strong><br>　　<strong>URI(统一资源标志符)分类：</strong></p>
<table>
<thead>
<tr>
<th>URL</th>
<th>URN</th>
</tr>
</thead>
<tbody><tr>
<td>统一资源定位符</td>
<td>统一资源名称</td>
</tr>
<tr>
<td>一种定位资源的主要访问机制的字符串</td>
<td>特定命名空间的唯一名称/ID来标识资源</td>
</tr>
</tbody></table>
<p>举例：<br>　　在www上，每一信息资源都有统一且唯一的地址(URL)—&gt;<code>http://www.baidu.com:80/index.html?uname=shsxt&amp;age=18#a</code>，由四部分组成：</p>
<ol>
<li>协议：<code>getProtocol()</code></li>
<li>存放资源的主机域名：<code>getHost()</code></li>
<li>端口号(http默认80)：<code>getPort()</code></li>
<li>请求资源：<code>getFile(显示参数)/getPath(不显示参数)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">public class JiaNLi &#123;</span><br><span class="line">	public static void main(String[] args)throws MalformedURLException &#123;</span><br><span class="line">		URL url&#x3D;new URL(&quot;http:&#x2F;&#x2F;www.baidu.com:80&#x2F;index.html?uname&#x3D;shsxt&amp;age&#x3D;18#a&quot;);</span><br><span class="line">		&#x2F;&#x2F;获取四个值</span><br><span class="line">		System.out.println(&quot;协议&quot;+url.getProtocol());&#x2F;&#x2F;协议http</span><br><span class="line">		System.out.println(&quot;域名&quot;+url.getHost());&#x2F;&#x2F;域名www.baidu.com</span><br><span class="line">		System.out.println(&quot;请求资源&quot;+url.getFile());&#x2F;&#x2F;请求资源&#x2F;index.html?uname&#x3D;shsxt&amp;age&#x3D;18</span><br><span class="line">		System.out.println(&quot;请求资源&quot;+url.getPath());&#x2F;&#x2F;请求资源&#x2F;index.html</span><br><span class="line">		System.out.println(&quot;端口&quot;+url.getPort());&#x2F;&#x2F;端口80</span><br><span class="line">		&#96;&#96;&#x2F;&#x2F;参数</span><br><span class="line">		System.out.println(&quot;参数&quot;+url.getQuery());&#x2F;&#x2F;参数uname&#x3D;shsxt&amp;age&#x3D;18</span><br><span class="line">		&#x2F;&#x2F;锚点</span><br><span class="line">		System.out.println(&quot;锚点&quot;+url.getRef());&#x2F;&#x2F;锚点a</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong></p>
<p><img src="/2019/11/12/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/url.png" alt></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">JAVA-网络编程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-等待唤醒机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/11/%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/" class="article-date">
      <time datetime="2019-11-11T12:39:46.000Z" itemprop="datePublished">2019-11-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/11/%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/">等待唤醒机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、线程间通信</strong></p>
<ul>
<li>线程间通信：多个线程在处理同一个资源，但是处理的动作(线程任务)不同。</li>
<li><strong>等待唤醒机制</strong>：—&gt;保证线程间通信有效利用<br>资源！</li>
</ul>
<hr>
<p><strong>二、等待唤醒机制</strong></p>
<ul>
<li><strong>通信</strong>：对包子的状态进行判断</li>
</ul>
<ol>
<li>没有包子–&gt;吃货线程唤醒包子铺线程–&gt;吃货线程等待–&gt;包子铺线程做包子–&gt;做好包子–&gt;修改包子的状态(无–&gt;有)</li>
<li>有包子–&gt;包子铺线程唤醒吃货线程–&gt;包子铺线程等待–&gt;吃货吃包子–&gt;吃完包子–&gt;修改包子的状态(有–&gt;无)</li>
</ol>
<ul>
<li>等待唤醒使用的<code>Object类</code><strong>方法</strong>：</li>
</ul>
<ol>
<li><code>wait</code>：线程<strong>不再活动</strong>，不再参与调度，因此不会浪费cpu资源，也不会去竞争锁(进入waiting状态)–&gt;等待notify()方法进入调度队列。</li>
<li><code>notify</code>：可以唤醒<strong>其中一个</strong>线程(有一定规律)。</li>
<li><code>notifyAll</code>：可以唤醒<strong>所有</strong>线程。</li>
</ol>
<ul>
<li>注意点：</li>
</ul>
<ol>
<li>两个方法必须使用<strong>同一</strong>锁对象调用</li>
<li>两个方法–&gt;Object类的方法</li>
<li>两个方法必须在同步代码块(<code>synchronized(){}</code>)/同步函数中使用(保证唯一和同步机制)</li>
</ol>
<hr>
<p><strong>三、生产者与消费者问题</strong></p>
<ul>
<li><p><strong>资源类：包子类：</strong><br>　包子的属性：皮/馅<br>　包子的状态：有true/无false</p>
</li>
<li><p><strong>生产者(包子铺)类：</strong>是一个线程类，可以继承Thread</p>
</li>
</ul>
<ol>
<li>线程任务(run):生产包子</li>
<li>对包子状态判断</li>
</ol>
<ul>
<li><p>true(有包子)：<br>　　(1)调用wait方法进入等待状态</p>
</li>
<li><p>false(没包子)：<br>　　(1)包子铺生产包子<br>　　(2)生产好包子将状态改为true<br>　　(3)唤醒吃货线程<br>　　(4)吃货线程吃包子</p>
</li>
<li><p><strong>消费者(吃货)类：</strong>是一个线程类，可以继承Thread</p>
</li>
</ul>
<ol>
<li>线程任务(run):吃包子</li>
<li>对包子状态判断</li>
</ol>
<ul>
<li><p>true(有包子)：<br>　　(1)调用wait方法进入等待状态</p>
</li>
<li><p>false(没包子)：<br>　　(1)吃货线程吃包子<br>　　(2)将状态改为false<br>　　(3)唤醒包子铺线程<br>　　(4)生产包子</p>
</li>
<li><p><strong>测试类(含main方法)</strong></p>
</li>
</ul>
<ol>
<li>创建包子对象：</li>
<li>创建包子铺线程：</li>
<li>创建吃货线程：</li>
</ol>
<hr>
<p><strong>四、线程池(容器)</strong></p>
<ul>
<li>容器—&gt;集合(<code>ArrayList&lt;Thread&gt;</code>/<code>HashSet</code>/<code>LinkedList&lt;Thread&gt;</code>/<code>HashMap</code>)</li>
</ul>
<p><strong>(基本使用ArrayList集合/LinkedList集合)</strong></p>
<ul>
<li><strong>分析原理：</strong><br>  当程序第一次启动—&gt;创建多个线程(放入集合)—&gt;需要使用时从集合中取出线程<br>　1. 如果是<strong>List集合</strong>：<br>　　<code>Thread t=list.remove(0)</code>：返回的是被移除的元素(线程只能被一个任务使用)<br>　　<code>list.add(t)</code>:使用完线程，归还给线程池<br>　2. 如果是<strong>Linked集合</strong>：<br>　　<code>Thread t=linked.removeFirst()</code>:一个一个线程被调用<br>　　<code>linked.addLast(t)</code>:使用完线程，归还给线程池</li>
</ul>
<hr>
<p><strong>五、线程池的使用(JDK1.5之后提供的)</strong><br><code>java.util.concurrent.Excutors</code>　　线程池的<strong>工厂类</strong>(用来产生线程池)<br>其中一个方法：<br><code>static ExecutorService newFixedThreadPool(int nThreads)</code>:创建一个可重用固定线程数的线程池<br>　　1. 参数(int nThreads)：创建线程池中包含的<strong>线程数量</strong><br>　　2. 返回值(ExecutorService接口)：返回的是ExecutorService接口的实现类对象，我们可以使用此接口来接受(面向接口编程)<br><strong>例如：</strong><br>    <code>ExecutorService es=Executors.newFixedThreadPool(2);//用ExecutorService接口接着</code></p>
<p><code>java.util.concurrent.ExecutorService接口</code>　　<strong>线程池接口</strong><br>其中一个方法：<br>用来从线程池中获取线程，调用start()方法，执行线程任务：<br>    <code>submit(Runnable task)</code>:提交一个Runnable—任务用于执行<br>    <code>void shutdown()</code>: 关闭/销毁线程池的方法</p>
<hr>
<p><strong>六、线程池的使用步骤</strong></p>
<ol>
<li>使用线程池的工厂类Executors内的静态方法newFixedThreadPool生产一个指定的线程数量的线程池</li>
<li>创建一个类实现Runnable接口—&gt;重写run方法—&gt;设置线程任务</li>
<li>调用ExecutorService中的方法submit—&gt;传递线程任务(实现类)—&gt;开启线程—&gt;执行run方法</li>
<li>调用ExecutorService中的方法shutdown—&gt;销毁线程池(不推荐！！)</li>
</ol>
<p><strong>代码实现如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	&#x2F;&#x2F;1.使用线程池的工厂类Executors内的静态方法newFixedThreadPool生产一个指定的线程数量的线程池</span><br><span class="line">	ExecutorService es&#x3D;Executors.newFixedThreadPool(2); &#x2F;&#x2F;右边返回的就是一个实现类用接口接着(面向接口编程)</span><br><span class="line">	&#x2F;&#x2F;3. 调用ExecutorService中的方法submit---&gt;传递线程任务(实现类)---&gt;开启线程---&gt;执行run方法	</span><br><span class="line">	es.submit(new RunnableImpl());	&#x2F;&#x2F;pool-1-thread-1创建了一个新的线程执行</span><br><span class="line">	&#x2F;&#x2F;线程池一直开启，使用完了会归还给线程池，线程可以继续使用</span><br><span class="line">	es.submit(new RunnableImpl());  &#x2F;&#x2F;pool-1-thread-1创建了一个新的线程执行</span><br><span class="line">	es.submit(new RunnableImpl());  &#x2F;&#x2F;pool-1-thread-2创建了一个新的线程执行</span><br><span class="line">	</span><br><span class="line">	es.shutdown();&#x2F;&#x2F;销毁线程池</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 创建一个类实现Runnable接口---&gt;重写run方法---&gt;设置线程任务</span><br><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+&quot;创建了一个新的线程执行&quot;); &#x2F;&#x2F;获取线程名称的第一种方式	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br><img src="/2019/11/11/%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/xianchengchi.png" alt></p>
<p><strong>代码分析</strong></p>
<ol>
<li><p>使用线程池的工厂类Executors内的静态方法newFixedThreadPool生产一个指定的线程数量的线程池<br> <code>ExecutorService es=Executors.newFixedThreadPool(2);</code>　<strong>用接口来接着(面向接口编程)！！</strong></p>
</li>
<li><p>创建一个类实现Runnable接口—&gt;重写run方法—&gt;设置线程任务<br> <code>public class RunnableImpl implements Runnable {}</code></p>
</li>
<li><p>调用ExecutorService中的方法submit—&gt;传递线程任务(实现类)—&gt;开启线程—&gt;执行run方法<br> <code>es.submit(new RunnableImpl());</code>　<strong>要用实现类传递线程任务(new RunnableImpl())</strong></p>
</li>
<li><p>调用ExecutorService中的方法shutdown—&gt;销毁线程池(不推荐！！)<br> <code>es.shutdown();</code></p>
</li>
</ol>
<hr>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">JAVA-多线程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-蓝桥杯校赛" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/" class="article-date">
      <time datetime="2019-11-07T07:41:19.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/">蓝桥杯校赛</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、分核桃</strong></p>
<ul>
<li><strong>问题描述</strong><br>小张是软件项目经理，他带领3个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是：</li>
</ul>
<ol>
<li>各组的核桃数量必须相同</li>
<li>各组内必须能平分核桃（当然是不能打碎的）</li>
<li>尽量提供满足1,2条件的最小数量（节约闹革命嘛）</li>
</ol>
<p>输入格式<br>输入包含三个正整数a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c&lt;30）<br>输出格式<br>输出一个正整数，表示每袋核桃的数量。</p>
<p>样例输入1<br>2 4 5<br>样例输出1<br>20</p>
<p>样例输入2<br>3 1 1<br>样例输出2<br>3</p>
<ul>
<li><strong>问题分析：</strong><br>　　很明显是两个两个人求<strong>最小公倍数</strong>的问题。</li>
<li><strong>1.暴力法：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	int a&#x3D;input.nextInt();</span><br><span class="line">	int b&#x3D;input.nextInt();</span><br><span class="line">	int c&#x3D;input.nextInt();</span><br><span class="line">	</span><br><span class="line">	for(int i&#x3D;1;i&lt;1000;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(i%a&#x3D;&#x3D;0&amp;&amp;i%b&#x3D;&#x3D;0&amp;&amp;i%c&#x3D;&#x3D;0)  &#x2F;&#x2F;最小的值应该满足同时可以整除三个数字</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>2.最小公倍数法：</strong></li>
</ul>
<ol>
<li>求两个数的<strong>最大值</strong>。</li>
<li>从最大值开始循环找到<strong>第一个</strong>能够<strong>同时整除</strong>的数字。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	int a&#x3D;input.nextInt();</span><br><span class="line">	int b&#x3D;input.nextInt();</span><br><span class="line">	int c&#x3D;input.nextInt();&#x2F;&#x2F;输入三个数字</span><br><span class="line">	int flag&#x3D;0;&#x2F;&#x2F;定义变量存储合适的那个值</span><br><span class="line">	</span><br><span class="line">	int d&#x3D;zuida(a,b);&#x2F;&#x2F;求前两数的最大值</span><br><span class="line">	for(int i&#x3D;d;;i++)&#x2F;&#x2F;从前两数的最大值开始</span><br><span class="line">	&#123;</span><br><span class="line">		if(i%a&#x3D;&#x3D;0&amp;&amp;i%b&#x3D;&#x3D;0) &#x2F;&#x2F;只要能够整除</span><br><span class="line">		&#123;</span><br><span class="line">			flag&#x3D;i;&#x2F;&#x2F;flag存储当前符合的最小公倍数</span><br><span class="line">			break;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int e&#x3D;zuida(flag,c); &#x2F;&#x2F;求第二次的最大值</span><br><span class="line">	for(int i&#x3D;e;;i++) &#x2F;&#x2F;从最大值开始</span><br><span class="line">	&#123;</span><br><span class="line">		if(i%flag&#x3D;&#x3D;0&amp;&amp;i%c&#x3D;&#x3D;0)&#x2F;&#x2F;只要能够整除</span><br><span class="line">		&#123;</span><br><span class="line">			flag&#x3D;i;&#x2F;&#x2F;存储最终满足的值</span><br><span class="line">			break;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	System.out.println(flag); &#x2F;&#x2F;输出答案</span><br><span class="line">	</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	public static int zuida(int i,int j) &#123;  &#x2F;&#x2F;求两个数的最大值</span><br><span class="line">		return i&gt;j?i:j;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果：</strong></li>
</ul>
<p><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/fenhetao.png" alt></p>
<hr>
<p><strong>二、字符删除</strong></p>
<ul>
<li><strong>问题描述</strong><br>编写一个程序，先输入一个字符串str（长度不超过20），再输入单独的一个字符ch，然后程序会把字符串str当中出现的所有的ch字符都删掉，从而得到一个新的字符串str2，然后把这个字符串打印出来。　　</li>
</ul>
<p>输入格式：输入有两行，第一行是一个字符串（内部没有空格），第二行是一个字符。　　<br>输出格式：经过处理以后的字符串。</p>
<p>样例输入<br>123-45-678-<br>样例输出<br>12345678</p>
<ul>
<li><strong>问题分析：</strong><br>将字符串转为数组(<code>toCharArray()</code>)，然后依次循环和ch字符对比，不相等就输出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	String str&#x3D;input.nextLine();  &#x2F;&#x2F;输入一个字符串</span><br><span class="line">	char ch&#x3D;input.next().charAt(0);  &#x2F;&#x2F;输入一个字符</span><br><span class="line">	char[] a&#x3D;str.toCharArray(); &#x2F;&#x2F;字符串转数组</span><br><span class="line">	</span><br><span class="line">	for(int i&#x3D;0;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(a[i]!&#x3D;ch)</span><br><span class="line">			System.out.print(a[i]);  &#x2F;&#x2F;不相等就输出</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果：</strong></li>
</ul>
<p><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/zifushanchu.png" alt></p>
<hr>
<p><strong>三、区间K大数查询</strong></p>
<ul>
<li><strong>问题描述</strong><br>给定一个序列，每次询问序列中第l个数到第r个数中第K大的数是哪个。</li>
</ul>
<p>输入格式<br>　　第一行包含一个数n，表示序列长度。<br>　　第二行包含n个正整数，表示给定的序列。<br>　　第三个包含一个正整数m，表示询问个数。</p>
<p>　　接下来m行，每行三个数l,r,K，表示询问序列从左往右第l个数到第r个数中，从大往小第K大的数是哪个。序列元素从1开始标号。</p>
<p>输出格式<br>　　总共输出m行，每行一个数，表示询问的答案。<br>样例输入<br>5<br>1 2 3 4 5<br>2<br>1 5 2<br>2 3 2<br>样例输出<br>4<br>2<br>数据规模与约定<br>　　对于30%的数据，n,m&lt;=100；<br>　　对于100%的数据，n,m&lt;=1000；</p>
<ul>
<li><strong>问题分析：</strong><br>　　定义一个数组a先往里面放值，然后定义一个r-l+1长的数组b存放要截取的数组，然后定义一个<strong>ans数组</strong>存放每一次循环判断的最k大值(很关键)，然后输入l，r，k之后按顺序存放进数组b，一定要记得<strong>sort</strong>一下(不一定存放的数组就是顺序的！！！)，最后将最k大值放入ans数组！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">		int n &#x3D; in.nextInt();&#x2F;&#x2F;输入数组的长度</span><br><span class="line">		int[] a &#x3D; new int[n];&#x2F;&#x2F;定义一个n长度的数组a</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] &#x3D; in.nextInt(); &#x2F;&#x2F;一位一位输入内容</span><br><span class="line">		&#125;		</span><br><span class="line">		int m &#x3D; in.nextInt();&#x2F;&#x2F;定义找几次</span><br><span class="line">		int[] ans &#x3D; new int[m];&#x2F;&#x2F;按照m定义长度数组ans</span><br><span class="line">	 for(int i&#x3D;0;i&lt;m;i++)&#x2F;&#x2F;找几次就循环几次</span><br><span class="line">		&#123;</span><br><span class="line">			int l &#x3D; in.nextInt();&#x2F;&#x2F;输入要选的左边值</span><br><span class="line">			int r &#x3D; in.nextInt();&#x2F;&#x2F;输入要选的右边值</span><br><span class="line">			int k &#x3D; in.nextInt();&#x2F;&#x2F;输入要选的第k大值</span><br><span class="line">			int[] b &#x3D; new int[r-l+1];&#x2F;&#x2F;定义一个截取范围的数组b</span><br><span class="line">			for(int j&#x3D;0;j&lt;r-l+1;j++)&#x2F;&#x2F;从0到最大值赋值</span><br><span class="line">			&#123;</span><br><span class="line">				b[j]&#x3D;a[j+l-1];&#x2F;&#x2F;依次将对应的值放入b数组中</span><br><span class="line">			&#125;</span><br><span class="line">			Arrays.sort(b);&#x2F;&#x2F;一定要记得排序(输入的数字不一定按顺序排列)</span><br><span class="line">			ans[i]&#x3D;b[r-l+1-k];&#x2F;&#x2F;把那个最k大值放入ans数组值中</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(ans[i]);&#x2F;&#x2F;依次输出的就是找几次的对应的答案</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码结果：</strong></li>
</ul>
<p><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/chaoshi.png" alt></p>
<hr>
<p><strong>四、阶乘(第一个非0数)</strong></p>
<ul>
<li><strong>问题描述</strong><br>　　一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13!就已经比较大了，已经无法存放在一个整型变量中；而35!就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5! = 1<em>2</em>3<em>4</em>5 = 120，因此5!最右边的那个非0的数字是2。再如：7! = 5040，因此7!最右边的那个非0的数字是4。请编写一个程序，输入一个整数n(n&lt;=100)，然后输出n!<br>最右边的那个非0的数字是多少。<br>　　<br>　　输入格式：输入只有一个整数n。<br>　　输出格式：输出只有一个整数，即n! 最右边的那个非0的数字。输入输出样例</li>
</ul>
<p>样例输入<br>6<br>样例输出<br>2</p>
<p>由于只需要阶乘后的最后一个非０数，所以每次阶乘后，如果尾数是０的直接／１０。</p>
<ul>
<li><strong>问题分析：</strong></li>
</ul>
<ol>
<li>先编写一个递归方法求每一个数对应的阶乘。</li>
<li>将结果暂存在数组内，然后设置变量m来遍历直至第一个非0数就跳出判断。</li>
</ol>
<p><strong>解法一(30%)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">	Scanner input&#x3D;new Scanner(System.in);</span><br><span class="line">	int n&#x3D;input.nextInt();</span><br><span class="line">	int[] a&#x3D;new int[1000];</span><br><span class="line">	a[0]&#x3D;jiecheng(n);</span><br><span class="line">	int m&#x3D;1;</span><br><span class="line">	for(int i&#x3D;0;;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m&#x3D;a[0]%10;</span><br><span class="line">		if(m!&#x3D;0)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(m);	</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		a[0]&#x3D;a[0]&#x2F;10;		</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	public static int jiecheng(int n) &#123;</span><br><span class="line">		if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;1)</span><br><span class="line">			return 1;</span><br><span class="line">		else </span><br><span class="line">			return n*jiecheng(n-1);		</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>问题分析：</strong></li>
</ul>
<ol>
<li>和解法一相似使用<strong>数组</strong>一个数字存放数组一个元素之中得到结果。</li>
<li>循环每次判断结果和考虑进位问题以此类推得到结果，最终还是循环判断非0数。</li>
</ol>
<p><strong>解法二(100%)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner sc&#x3D;new Scanner(System.in);</span><br><span class="line">		int n&#x3D;sc.nextInt();</span><br><span class="line">		int a[]&#x3D; new int[4000];</span><br><span class="line">		a[0]&#x3D;1;</span><br><span class="line">		int r1&#x3D;0;&#x2F;&#x2F;考虑进位情况</span><br><span class="line">		for(int i&#x3D;2;i&lt;&#x3D;n;i++) &#123;</span><br><span class="line">			for(int j&#x3D;0;j&lt;4000;j++) &#123;</span><br><span class="line">				r1&#x3D;a[j]*i+r1;</span><br><span class="line">				a[j]&#x3D;r1%10;  &#x2F;&#x2F;如果发生进位将个位赋给当前位置，十位或者和百位一起加到下一次数组乘法</span><br><span class="line">				r1&#x3D;r1&#x2F;10;   &#x2F;&#x2F;依次类推</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int s&#x3D;0;</span><br><span class="line">		for(int i&#x3D;3999;i&gt;&#x3D;0;i--) &#123;</span><br><span class="line">			if(a[i]!&#x3D;0) &#123;</span><br><span class="line">				System.out.print(a[i]);  &#x2F;&#x2F;从后往前倒排，然后判断首位不为空则输出</span><br><span class="line">				s&#x3D;i;   &#x2F;&#x2F;同时记录下标</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>问题分析：</strong></li>
</ul>
<ol>
<li>像解法一一样，如果用int型和递归方法会导致超时等问题，所以考虑使用<strong>BigDecimal类型</strong>存放结果。</li>
<li>考虑将结果用<strong>tosrtring方法</strong>转化为字符串，通过</li>
</ol>
<p><strong>charAt方法</strong>来循环判断是否为0找到最终结果。</p>
<p><strong>解法三(100%)：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.math.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">		int n &#x3D; input.nextInt();</span><br><span class="line">		BigDecimal sum &#x3D; BigDecimal.ONE;&#x2F;&#x2F;使用BigDecimal类型存放答案</span><br><span class="line">		for(int i &#x3D; 1; i &lt;&#x3D; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			sum &#x3D; sum.multiply(BigDecimal.valueOf(i));&#x2F;&#x2F;使用乘法(不使用递归方法！)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	String S &#x3D; sum.toString(); &#x2F;&#x2F;将结果转化为字符串</span><br><span class="line">		for(int i &#x3D; S.length()-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			if(S.charAt(i) !&#x3D; &#39;0&#39;)&#x2F;&#x2F;遇到第一个非0的数字输出 </span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(S.charAt(i));</span><br><span class="line">  			      break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下:</strong></p>
<p><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/jiecheng.png" alt></p>
<hr>
<p><strong>五、最长子序列</strong></p>
<ul>
<li><p><strong>问题描述</strong><br>给定一个长为n的序列，求它的最长上升子序列的长度。<br>输入格式<br>　　输入第一行包含一个整数n。<br>　　第二行包含n个整数，为给定的序列。<br>输出格式<br>　　输出一个非负整数，表示最长上升子序列的长度。<br>样例输入<br>5<br>1 3 2 5 4<br>样例输出<br>3<br>数据规模和约定<br>　　0&lt;n&lt;=1000，每个数不超过10^6。</p>
</li>
<li><p><strong>问题分析：</strong><br>例如：数列(1, 7, 3, 5, 9, 4, 8)的有序上升子序列，像(1, 7)， (3, 4, 8)和许多其他的子序列。在所有的子序列中，最长的上升子序列的长度是4，如(1, 3, 5, 8)</p>
</li>
<li><p><strong>动态规划</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package xiaosai;</span><br><span class="line">import java.math.*;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in); </span><br><span class="line">		int n &#x3D; input.nextInt();</span><br><span class="line">		int[] arr &#x3D; new int[10002];&#x2F;&#x2F;arr数组表示输入的序列</span><br><span class="line">		int[] dp &#x3D; new int[10002];&#x2F;&#x2F;dp数组中存放上升序列的长度，dp[i]表示以arr[i]结尾的子序列的最大长度</span><br><span class="line">		for(int i &#x3D; 1;i &lt;&#x3D; n;i++) &#123;&#x2F;&#x2F;输入序列</span><br><span class="line">			arr[i]&#x3D; input.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		int result &#x3D; -1;&#x2F;&#x2F;记录dp中最大的值				</span><br><span class="line">		for(int i &#x3D; 1;i &lt;&#x3D; n;i++)</span><br><span class="line">		&#123;&#x2F;&#x2F;按顺序计算dp[i]的值			</span><br><span class="line">			dp[i] &#x3D; 1;&#x2F;&#x2F;假设该子序列中只有arr[i]，故长度为1，即其自身成为一个子序列			</span><br><span class="line">			for(int j &#x3D; 1;j &lt; i;j++) </span><br><span class="line">			&#123;&#x2F;&#x2F;如果在i之前有比arr[i]小的数(arr[j])，并且把该数(arr[i])放到以arr[j]结尾的子序列末尾后，&#x2F;&#x2F;其长度比当前以arr[i]结尾的子序列长度要长				</span><br><span class="line">				if(arr[i] &gt; arr[j] &amp;&amp; dp[j] + 1 &gt; dp[i]) </span><br><span class="line">				&#123;					</span><br><span class="line">					dp[i] &#x3D; dp[j] + 1;&#x2F;&#x2F;把arr[i]放到以arr[j]结尾的子序列之后，原来的长度＋1				</span><br><span class="line">				&#125;			</span><br><span class="line">			&#125;</span><br><span class="line">			result &#x3D; Math.max(result, dp[i]);&#x2F;&#x2F;找出在dp数组中最大的一个，即子序列长度最长的一个		</span><br><span class="line">		&#125;</span><br><span class="line">		 System.out.println(result);	</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码结果如下：</strong><br><img src="/2019/11/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B/zuichangzixulie.png" alt></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" rel="tag">蓝桥杯</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-线程状态" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/" class="article-date">
      <time datetime="2019-11-07T07:11:21.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/">线程状态</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、线程状态</strong><br>在API中<code>java.lang.Thread.state</code>介绍了六种线程状态！</p>
<p><img src="/2019/11/07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/xianchengzhuangtaitu.png" alt></p>
<p>参考视频：<br><a href="https://www.bilibili.com/video/av62541169/?p=312" target="_blank" rel="noopener" title="多线程的网址">https://www.bilibili.com/video/av62541169/?p=312</a></p>
<ol>
<li>先<code>new Thread/Thread子类()；</code>—&gt;<strong>新建状态</strong></li>
<li>执行<code>start()方法</code><ul>
<li>抢到cpu—&gt;<strong>运行状态(Runnable)</strong>–<code>run()方法结束</code>/<code>stop()过时</code>就会到<strong>死亡状态(Terminated)</strong></li>
<li>没抢到cpu—&gt;<strong>阻塞状态(Blockerd)</strong></li>
</ul>
</li>
<li>执行<code>sleep(long)方法</code> / <code>wait(long)方法</code>—&gt;<strong>睡眠/休眠状态(Timed_waiting)</strong><ul>
<li>睡眠结束，cpu不空闲—&gt;<strong>阻塞状态</strong></li>
<li>睡眠结束，cpu空闲—&gt;<strong>运行状态</strong></li>
</ul>
</li>
<li>执行<code>Object.wait(无参数)</code>—&gt;<strong>无限/永久等待状态</strong></li>
<li>执行<code>Object.notify()</code>—&gt;只有这个方法才能唤醒。</li>
</ol>
<hr>
<p><strong>二、等待唤醒案例</strong></p>
<ul>
<li>等待唤醒案例：线程之间的通信<br>　　创建一个<strong>顾客线程(消费者)</strong>：告知老板需要包子的种类和数量，调用<strong>wait方法</strong>，放弃cpu的执行，进入到WAITING状态(无限等待)<br>　　创建一个<strong>老板线程(生产者)</strong>：花了s秒生产包子，包子做好，调用<strong>notify()方法</strong>，唤醒顾客吃包子。</li>
<li>注意点：</li>
</ul>
<ol>
<li>顾客和老板线程必须使用同步代码块包裹，而且保证只有一个在执行。(使用同步技术-synchronized(对象)形式)</li>
<li>同步使用的锁对象必须保证唯一。(只有一个obj对象)</li>
<li>只有锁对象才可以使用wait和notify方法。(代码中obj.wait()方法/obj.notify()方法)</li>
</ol>
<p><code>Object类</code>中的方法：</p>
<ol>
<li><code>void wait()</code>：<br> 在其他线程调用此对象的notify()方法/notifyAll()方法前，导致当前线程等待。</li>
<li><code>void notify()</code>：<br> 唤醒在此对象监控器上等待的单个线程<br> 会继续执行wait()方法之后的代码</li>
</ol>
<ul>
<li>具体实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package dengdaihuanxing;</span><br><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建锁对象(唯一)</span><br><span class="line">		Object obj&#x3D;new Object();</span><br><span class="line">		&#x2F;&#x2F;创建一个顾客线程(消费者)---匿名内部类</span><br><span class="line">		new Thread()&#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;保证只有一个执行---同步技术</span><br><span class="line">				synchronized(obj) &#123;</span><br><span class="line">				System.out.println(&quot;告知老板要的包子的种类和数量：&quot;);</span><br><span class="line">				&#x2F;&#x2F;调用wait方法---进入无限等待状态</span><br><span class="line">				try</span><br><span class="line">				&#123;</span><br><span class="line">					obj.wait(); &#x2F;&#x2F;锁对象才可以调用wait方法</span><br><span class="line">				&#125; </span><br><span class="line">				catch (InterruptedException e) </span><br><span class="line">				&#123;			</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;唤醒之后执行的代码</span><br><span class="line">				System.out.println(&quot;包子已经做好了，可以吃了！&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建一个老板线程(生产者)</span><br><span class="line">		new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;花五秒钟做包子</span><br><span class="line">				try </span><br><span class="line">				&#123;</span><br><span class="line">					Thread.sleep(5000);</span><br><span class="line">				&#125; </span><br><span class="line">				catch (InterruptedException e)</span><br><span class="line">				&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#x2F;&#x2F;保证只有一个执行---同步技术</span><br><span class="line">			synchronized(obj) &#123;</span><br><span class="line">				System.out.println(&quot;老板5秒后做好包子,可以来吃包子了&quot;);</span><br><span class="line">				&#x2F;&#x2F;调用notify()方法唤醒吃包子</span><br><span class="line">				obj.notify();&#x2F;&#x2F;锁对象才可以调用notify方法</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;		</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">告知老板要的包子的种类和数量：</span><br><span class="line">(不用输入等待5秒后就会弹出下面的结果)</span><br><span class="line">老板5秒后做好包子,可以来吃包子了</span><br><span class="line">包子已经做好了，可以吃了！</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>三、Object类中wait带参方法和notify方法</strong></p>
<ul>
<li><strong>进入TimeWaiting(计时等待)</strong>有两种方式：</li>
</ul>
<ol>
<li>使用<code>sleep(long m)</code>，在毫秒值结束之后，线程–&gt;Runnable/Blocked状态。</li>
<li>使用<code>wait(long m)</code>：wait方法如果在毫秒值结束之后，还没有被notify方法唤醒，就会自动醒来。</li>
</ol>
<ul>
<li><strong>唤醒</strong>的方法</li>
</ul>
<ol>
<li><code>notify()</code>： —&gt;唤醒<strong>单个</strong>线程</li>
<li><code>notify()All</code>： —&gt;唤醒<strong>所有</strong>线程</li>
</ol>
<hr>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">JAVA-多线程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-线程安全" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/05/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" class="article-date">
      <time datetime="2019-11-05T13:01:27.000Z" itemprop="datePublished">2019-11-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/05/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>一、安全问题</strong><br>  假如一个电影院有一部电影100张票：</p>
<ol>
<li>只有一个窗口卖1-100的票(单线程)：不会出现线程问题。</li>
<li>有三个窗口卖不同范围的票(多线程)：不会出现线程问题，没有访问共享数据，不会产生问题。</li>
<li>有三个窗口卖的都是1-100的票(多线程)：会出现线程<strong>访问共享数据</strong>–&gt;<strong>线程安全问题</strong>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;子类！！！！！</span><br><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个多线程共享的票源：</span><br><span class="line">	private int ticket&#x3D;100;</span><br><span class="line">	&#x2F;&#x2F;设置线程任务:卖票</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	  while(true) </span><br><span class="line">	  &#123;</span><br><span class="line">		&#x2F;&#x2F;先判断票是否存在</span><br><span class="line">		if(ticket&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;提高安全问题出现的概率，让程序睡眠</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(10);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;票存在，卖票 ticket--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">		ticket--;</span><br><span class="line">		&#125;</span><br><span class="line">	  &#125;	</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试类！！！！！！！！！！！！！！！！！</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 模拟卖票案例</span><br><span class="line">	 创建3个线程，同时开始，对共享的票进行出售</span><br><span class="line">	 *&#x2F;</span><br><span class="line">public class ShiXian &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建Runnable接口的实现类对象		</span><br><span class="line">		RunnableImpl run&#x3D;new RunnableImpl();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;三个线程争夺CPU</span><br><span class="line">		Thread t0&#x3D;new Thread(run);&#x2F;&#x2F;抢夺到CPU的执行权-进入到run方法之后执行if语句就会睡眠，失去cpu的执行权</span><br><span class="line">		Thread t1&#x3D;new Thread(run);</span><br><span class="line">		Thread t2&#x3D;new Thread(run);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;调用start()方法开启多线程</span><br><span class="line">		t0.start();</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong><br>Thread-1–&gt;正在卖第100张票<br>Thread-2–&gt;正在卖第100张票<br>Thread-0–&gt;正在卖第100张票<br>…<br>Thread-1–&gt;正在卖第3张票<br>Thread-0–&gt;正在卖第3张票<br>Thread-2–&gt;正在卖第1张票<br>Thread-1–&gt;正在卖第0张票<br>Thread-0–&gt;正在卖第1张票<br>(出现了同时卖出去票的问题！！！！！！)</p>
<hr>
<p><strong>二、线程同步(解决方案)</strong></p>
<ol>
<li>同步代码块</li>
<li>同步方法</li>
<li>锁机制(Lock接口)</li>
</ol>
<ul>
<li><strong>同步代码块(<code>synchronized</code>)：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> synchronized(同步锁)&#123;</span><br><span class="line">	需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>锁对象可以是任意的对象</li>
<li>保证多个线程使用的是同一个锁对象</li>
<li>锁对象的作用：<br> 把同步代码块锁住：只让一个线程在同步代码块中执行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个多线程共享的票源：</span><br><span class="line">	private int ticket&#x3D;100;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;创建一个锁对象</span><br><span class="line">	Object obj&#x3D;new Object();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;设置线程任务:卖票</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	  while(true) </span><br><span class="line">	  &#123;</span><br><span class="line"></span><br><span class="line">		synchronized (obj)   &#x2F;&#x2F;synchronized(锁对象)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		&#x2F;&#x2F;还是原来的那些if语句和sleep语句</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	  &#125;	</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong><br>Thread-0–&gt;正在卖第100张票<br>Thread-2–&gt;正在卖第99张票<br>Thread-2–&gt;正在卖第98张票<br>…(省略)<br>Thread-2–&gt;正在卖第4张票<br>Thread-2–&gt;正在卖第3张票<br>Thread-2–&gt;正在卖第2张票<br>Thread-2–&gt;正在卖第1张票</p>
<hr>
<ul>
<li><strong>同步方法</strong> </li>
</ul>
<ol>
<li>访问了共享数据的代码–&gt;方法</li>
<li>方法上+synchronized修饰符</li>
</ol>
<p>格式：定义方法的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值类型 方法名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package duoxianchegn;</span><br><span class="line"></span><br><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个多线程共享的票源：</span><br><span class="line">	private int ticket&#x3D;100;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;设置线程任务:卖票</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	  while(true) </span><br><span class="line">	  &#123;</span><br><span class="line">		  payTicket();  &#x2F;&#x2F;调用这个方法!</span><br><span class="line">			</span><br><span class="line">	  &#125;	</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;提出来一个payTicket()方法用于把共享的代码锁起来</span><br><span class="line">	public synchronized void payTicket() &#123;</span><br><span class="line">		&#x2F;&#x2F;先判断票是否存在</span><br><span class="line">		if(ticket&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;提高安全问题出现的概率，让程序睡眠</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(10);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;票存在，卖票 ticket--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">		ticket--;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码结果如下：</strong><br>Thread-0–&gt;正在卖第100张票<br>Thread-2–&gt;正在卖第99张票<br>Thread-2–&gt;正在卖第98张票<br>…(省略)<br>Thread-2–&gt;正在卖第4张票<br>Thread-2–&gt;正在卖第3张票<br>Thread-2–&gt;正在卖第2张票<br>Thread-2–&gt;正在卖第1张票</p>
<hr>
<ul>
<li><p><strong>锁机制(Lock锁)</strong><br><code>java.util.concurrent.locks.lock接口</code></p>
</li>
<li><p><strong>lock接口</strong>(比synchronized更好)<br>　1. 使用<strong>获取锁<code>void lock()</code>/释放锁<code>void unlock()</code></strong>方法。<br>　2. 实现类<code>ReentrantLock</code> <strong>implements</strong> <code>Lock接口</code></p>
</li>
<li><p>使用步骤：</p>
</li>
</ul>
<ol>
<li>在成员位置–&gt;ReentrantLock对象</li>
<li>在可能会出现安全问题的代码<strong>前</strong>调用Lock方法<strong>获取锁</strong></li>
<li>在可能会出现安全问题的代码<strong>后</strong>调用Lock方法<strong>释放锁</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">public class RunnableImpl implements Runnable &#123;</span><br><span class="line">	&#x2F;&#x2F;定义一个多线程共享的票源：</span><br><span class="line">	private int ticket&#x3D;100;</span><br><span class="line">	&#x2F;&#x2F;定义一个对象</span><br><span class="line">	Lock l&#x3D;new ReentrantLock();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;设置线程任务:卖票</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	  while(true) </span><br><span class="line">	  &#123;</span><br><span class="line">		 	l.lock();&#x2F;&#x2F;加一个锁</span><br><span class="line">		&#x2F;&#x2F;先判断票是否存在</span><br><span class="line">		if(ticket&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;提高安全问题出现的概率，让程序睡眠</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(10);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				&#x2F;&#x2F; TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;票存在，卖票 ticket--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">		ticket--;</span><br><span class="line">		&#125;</span><br><span class="line">		l.unlock();&#x2F;&#x2F;释放一个锁</span><br><span class="line">	  &#125;</span><br><span class="line">	 					&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">JAVA-多线程</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/24/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/26/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2024 Larkkkkkkk
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="http://bestwing.me" target="_blank">Sw'blog</a> by Swing
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


    <script type="text/javascript">
      window.onload = function(){
        document.getElementById("search").onclick = function(){
            console.log("search")
            search();
        }
      }
      function search(){
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','A1Pz-LKMXbrzcFg2FWi6','2.0.0');
      }
    </script>

  </div>
</body>
</html>